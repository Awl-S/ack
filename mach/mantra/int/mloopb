_sigtrp:	move.l	(sp)+,d2	!save return address
		mov	(sp)+,d1	!trapno in d1
		mov	(sp)+,d4	!signo in d4
		extend	d4
		extend	d1
		comp	#16,d4
		bhi	sig_bad
		tst.l	d4
		beq	sig_bad
		move.l	d4,a0
		add.l	a0,a0
		add.l	a0,a0
		lea	sig_trp-4(a0),a5
		move.l	(a5),d2		!previous trap number in d2
		comp	#256,d1		!-2 and -1 special
		bcc	1f
		move.l	sig_adr-4(a0),d3	!Get the pointer to the trap- 
		bne	2f		!procedure to give as argument to
sig_bad:	mov	22,-(sp)	!_signal. If pointer 0 trapping is
		mov	22,-(sp)	!not legal
		jmp	(a4)
1:		comp	#-3,d1		!-2:reset default , -3: ignore
		bmi	sig_bad
		move.l	d1,d3
		ad	#2,d3		!0:reset default for signal, -1: ignore
2:		move.l	d1,(a5)		!set new trapno
		move.l	d3,-(sp)		!set arguments to signal:
		mov	d4,-(sp)		!pointer ,signo to be trapped
		bsr	_signal
		jmp	(a4)
	.data
sig_adr:	.long	sig1 ;	.long	sig2 ;	.long sig3 ;	.long	0
		.long	0 ;	.long	0 ;	.long 0 ;	.long	0
		.long	0 ;	.long	0 ;	.long sig11 ;	.long	sig12
		.long	sig13 ;	.long	sig14 ;	.long sig15 ;	.long	sig16
sig_trp:	.long	-2  ;	.long	-2  ;	.long	-2  ;	.long	-2  
		.long	-2  ;	.long	-2  ;	.long	-2  ;	.long	-2  
		.long	-2  ;	.long	-2  ;	.long	21  ;	.long	25  
		.long	-2  ;	.long	-2  ;	.long	-2  ;	.long	-2  
	.text
!the next procedures map the catched signal to em errors. The em error
!procedure will handle this.
sig1:		pea	retutrap
		move.l	sig_trp,d0
		mov	d0,-(sp)
		bra	error
sig2: 		pea	retutrap
		move.l	sig_trp+4,d0
		mov	d0,-(sp)
		bra	error
sig3:		pea	retutrap
		move.l	sig_trp+8,d0
		mov	d0,-(sp)
		bra	error
sig8: 		pea	retutrap
		move.l	sig_trp+28,d0
		mov	d0,-(sp)
		bra	error
sig13:		pea	retutrap
		move.l	sig_trp+48,d0
		mov	d0,-(sp)
		bra	error
sig14:		pea	retutrap
		move.l	sig_trp+52,d0
		mov	d0,-(sp)
		bra	error
sig15:		pea	retutrap
		move.l	sig_trp+56,d0
		mov	d0,-(sp)
		bra	error
sig16:		pea	retutrap
		move.l	sig_trp+60,d0
		mov	d0,-(sp)
		bra	error
retutrap:	add.l	#4,sp		!remove signumber
		rtr

sig12:		pea	sig12
		mov	#12,-(sp)
		bsr	_signal
		bsr	e_badmon
		rtr
sig11:		move.l	4(a1),d0
		sub.l	sp,d0
		bcs	e_memflt	!in this case error handling possible
		move.l	ml,sp		!refresh stack and stop .
		bra	notrap1

