/*
  (c) copyright 1988 by the Vrije Universiteit, Amsterdam, The Netherlands.
  See the copyright notice in the ACK home directory, in the file "Copyright".
*/

/* $Header$ */

/* 
   #define CODE_GENERATOR for code generator
   #define CODE_EXPANDER for code expander

   #define IEEEFLOAT for machines using IEEE floating point format
   #define PDPFLOAT for machines using the PDP-11 floating point format
   If none of these are defined, the format of the machine on which the
   code generator runs is used.
   Returns 1 if sz has an illegal value, 2 in case of overflow,
   and 0 if all went well.
   If neither IEEEFLOAT nor PDPFLOAT are defined, the return value is not
   trustworthy.
*/
#ifdef IEEEFLOAT
#define USE_FLT
#endif
#ifdef PDPFLOAT
#define USE_FLT
#endif

#ifndef USE_FLT
static int
float_cst(str, sz, buf)
	char *str, *buf;
	int sz;
{
	int i;
	char *p;
	float fl;
	double f;
	double atof();

	if (sz!= 4 && sz!= 8)	{
		return 1;
	}
	f = atof(str);
	if (sz == 4) {
		fl = f;
		p = (char *) &fl;
	}
	else {
		p = (char *) &f;
	}
	for (i = sz; i; i--) {
		*buf++ = *p++;
	}
	return 0;
}
#else /* USE_FLT */

#include <ctype.h>
#include <flt_arith.h>

int
float_cst(str, sz, buf)
	char *str, *buf;
	int sz;
{
	int i;
	int overflow = 0;
	flt_arith e;

	if (sz!= 4 && sz!= 8)	{
		return 1;
	}
	flt_str2flt(str, &e);
#ifdef IEEEFLOAT
	if (sz == 4) {
#endif
		e.flt_exp += 127;
		if (e.flt_mantissa.flt_h_32 == 0) e.flt_exp = 0;
#ifdef IEEEFLOAT
		if (e.flt_mantissa.flt_l_32 & 0x80) {
			/* rounding */
			if ((e.flt_mantissa.flt_h_32 & 0xffffff00) == 0xffffff00) {
				e.flt_exp++;
				e.flt_mantissa.flt_h_32 = 0x80000000;
			}
			else {
				e.flt_mantissa.flt_h_32 += 0x80;
			}
		}
		if (e.flt_exp >= 255) {
			overflow = 1;
			e.flt_exp = 255;
			e.flt_mantissa.flt_h_32 = e.flt_mantissa.flt_l_32 = 0;
		}
		if (e.flt_exp <= 0) {
			flt_b64_sft(&(e.flt_mantissa), 1);
			if (e.flt_exp < 0) {
				flt_b64_sft(&(e.flt_mantissa), -e.flt_exp);
				e.flt_exp = 0;
			}
		}
#endif
		buf[0] = (e.flt_sign << 7) | (e.flt_exp >> 1);
		buf[1] = ((e.flt_exp&1) << 7) |
				((e.flt_mantissa.flt_h_32 & 0x7fffffff) >> 24);
		buf[2] = e.flt_mantissa.flt_h_32 >> 16;
		buf[3] = e.flt_mantissa.flt_h_32 >> 8;
#ifndef IEEEFLOAT
		if (sz == 8) {
			buf[4] = e.flt_mantissa.flt_h_32;
			buf[5] = e.flt_mantissa.flt_l_32 >> 24;
			buf[6] = e.flt_mantissa.flt_l_32 >> 16;
			buf[7] = e.flt_mantissa.flt_l_32 >> 8;
			flt_b64_sft(&(e.flt_mantissa), -56);
		}
		else
#endif
			flt_b64_sft(&(e.flt_mantissa), -24);
#ifdef IEEEFLOAT
	}
	else {
		e.flt_exp += 1023;
		if (e.flt_mantissa.flt_h_32 == 0) e.flt_exp = 0;
		if (e.flt_mantissa.flt_l_32 & 0x400) {
			/* rounding */
			if ((e.flt_mantissa.flt_l_32 & 0xfffff800) == 0xfffff800) {
				e.flt_mantissa.flt_l_32 = 0;
				if ((e.flt_mantissa.flt_h_32 += 1) == 0) {
					e.flt_exp++;
					e.flt_mantissa.flt_h_32 = 0x80000000;
				}
			}
			else {
				e.flt_mantissa.flt_l_32 += 0x400;
			}
		}
		if (e.flt_exp >= 2047) {
			overflow = 1;
			e.flt_exp = 2047;
			e.flt_mantissa.flt_h_32 = e.flt_mantissa.flt_l_32 = 0;
		}
		if (e.flt_exp <= 0) {
			flt_b64_sft(&(e.flt_mantissa), 1);
			if (e.flt_exp < 0) {
				flt_b64_sft(&(e.flt_mantissa), -e.flt_exp);
				e.flt_exp = 0;
			}
		}
		buf[0] = (e.flt_sign << 7) | (e.flt_exp >> 4);
		buf[1] = ((e.flt_exp & 017)<< 4) | ((e.flt_mantissa.flt_h_32 >> 27) & 017);
		buf[2] = e.flt_mantissa.flt_h_32 >> 19;
		buf[3] = e.flt_mantissa.flt_h_32 >> 11;
		buf[4] = e.flt_mantissa.flt_h_32 >> 3;
		buf[5] = (e.flt_mantissa.flt_h_32 << 5) | ((e.flt_mantissa.flt_l_32 >> 27) & 037);
		buf[6] = e.flt_mantissa.flt_l_32 >> 19;
		buf[7] = e.flt_mantissa.flt_l_32 >> 11;
		flt_b64_sft(&(e.flt_mantissa), -53);
	}
#endif
	if (overflow) {
		return 2;
	}
	return 0;
}
#endif /* USE_FLT */

#ifdef CODE_GENERATOR
con_float()
{
	char buf[8];
	int rval = float_cst(str, argval, buf);
	int i;

	if (rval == 1) {
		fprintf(stderr,"float constant size = %d\n",argval);
		fatal("bad fcon size");
	}
	fprintf(codefile,"!float %s sz %d\n", str, argval);
	if (rval == 2) {
		fprintf(stderr, "Warning: overflow in floating point constant %s\n", str);
	}
	fprintf(codefile, ".data1 0%o", buf[0] & 0377);
	for (i = 1; i < argval; i++) {
		fprintf(codefile, ",0%o", buf[i] & 0377);
	}
	putc('\n', codefile);
}
#endif /* CODE_GENERATOR */

#ifdef CODE_EXPANDER
con_float(str, argval)
	char *str;
{
	char buf[8];
	int rval = float_cst(str, argval, buf);
	int i;

	if (rval == 1) {
		argval = 8;
		rval = float_cst(str, argval, buf);
	}
	for (i = 0; i < argval; i++) {
		gen1(buf[i]);
	}
}
#endif /* CODE_EXPANDER */
