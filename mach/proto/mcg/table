REGISTERS

	r0  bytes4 int ret;
	r1  bytes4 int;
	r2  bytes4 int;
	r3  bytes4 int;
	r4  bytes4 int;
	r5  bytes4 int;
	r6  bytes4 int;
	r7  bytes4 int;
	r8  bytes4 int;
	r9  bytes4 int;
	r10 bytes4 int;
	r11 bytes4 int;

	s0  bytes4 float;
	s1  bytes4 float;
	s2  bytes4 float;
	s3  bytes4 float;
	s4  bytes4 float;
	s5  bytes4 float;
	s6  bytes4 float;
	s7  bytes4 float;
	s8  bytes4 float;
	s9  bytes4 float;

	cc  cc;


DECLARATIONS

	cc;

	address   fragment;
	aluparam  fragment;


PATTERNS

/* Special */

	PAIR(BLOCK4, BLOCK4);


/* Miscellaneous special things */

	PUSH4(in:(int)reg)
		emit "push %in"
		cost 4;

	out:(int)reg = POP4
		emit "pop %out"
		cost 4;

	RET
		emit "ret"
		cost 4;

	SETRET4(in:(ret)reg)
		emit "mov r0, %in"
		cost 4;

	STACKADJUST4(delta:aluparam)
		emit "add sp, sp, %delta"
		cost 4;


/* Memory operations */

	STORE4(addr:address, value:(int)reg)
		emit "str %value, %addr"
		cost 4;

	STORE1(addr:address, value:(int)reg)
		emit "strb %value, %addr"
		cost 4;

	out:(int)reg = LOAD4(addr:address)
		emit "ldr %out, %addr"
		cost 4;

	out:(int)reg = LOAD1(addr:address)
		emit "ldrb %out, %addr"
		cost 4;

	out:(int)reg = CIU14(LOAD1(addr:address))
		emit "ldrb %out, %addr"
		cost 4;
	
	out:(int)reg = CII14(CIU41(CIU14(LOAD1(addr:address))))
		emit "ldrsb %out, %addr"
		cost 4;


/* Locals */

	out:(int)reg = in:LOCAL4
		emit "add %out, fp, #$in"
		cost 4;

	address = in:LOCAL4
		emit "[fp, #$in]";


/* Memory addressing modes */

	address = ADD4(addr:(int)reg, offset:CONST4)
		emit "[%addr, #$offset]";

	address = ADD4(addr1:(int)reg, addr2:(int)reg)
		emit "[%addr1, %addr2]";

	address = addr:(int)reg
		emit "[%addr]";



/* Branches */

	JUMP(addr:BLOCK4)
		emit "b $addr"
		cost 4;

	CJUMPEQ(value:(cc)cc, PAIR(true:BLOCK4, false:BLOCK4))
		emit "beq $true"
		emit "b $false"
		cost 8;

	CJUMPLE(value:(cc)cc, PAIR(true:BLOCK4, false:BLOCK4))
		emit "ble $true"
		emit "b $false"
		cost 8;

	CJUMPLT(value:(cc)cc, PAIR(true:BLOCK4, false:BLOCK4))
		emit "blt $true"
		emit "b $false"
		cost 8;

	CALL(dest:LABEL4)
		emit "bl $dest"
		cost 4;


/* Comparisons */

	(cc)cc = COMPARES4(left:(int)reg, right:aluparam)
		emit "cmp %left, %right"
		cost 4;

	(cc)cc = COMPARES4(COMPARES4(left:(int)reg, right:aluparam), CONST4)
		emit "cmp %left, %right"
		cost 4;

	out:(int)reg = (cc)cc
		emit "mov %out, #0"
		emit "movlt %out, #-1"
		emit "movgt %out, #1"
		cost 12;


/* Conversions */

	out:(int)reg = CII14(CIU41(value:(int)reg))
		emit "sxtb %out, %value"
		cost 4;

	out:(int)reg = CIU41(in:(int)reg)
		emit "and %out, %in, #0xff"
		cost 4;


/* ALU operations */

	out:(int)reg = ADD4(left:(int)reg, right:aluparam)
		emit "add %out, %left, %right"
		cost 4;

	out:(int)reg = ADD4(left:aluparam, right:(int)reg)
		emit "add %out, %right, %left"
		cost 4;

	out:(int)reg = MOD4(left:(int)reg, right:(int)reg)
		emit "udiv %out, %left, %right"
		emit "mls %out, %out, %right, %left"
		cost 8;

	out:(int)reg = DIV4(left:(int)reg, right:aluparam)
		emit "div %out, %left, %right"
		cost 4;

	aluparam = value:CONST4
		emit "#$value";

	aluparam = value:(int)reg
		emit "%value";

	out:(int)reg = value:aluparam
		emit "mov %out, %value"
		cost 4;

	out:(int)reg = value:LABEL4
		emit "adr %out, $value"
		cost 4;

	out:(int)reg = value:BLOCK4
		emit "adr %out, $value"
		cost 4;

	out:(int)reg = value:CONST4
		emit "ldr %out, address-containing-$value"
		cost 8;

	out:(int)reg = value:CONSTF4
		emit "vldr %out, address-containing-$value"
		cost 8;

/* FPU operations */

	out:(float)reg = ADDF4(left:(float)reg, right:(float)reg)
		emit "fadds %out, %left, %right"
		cost 4;

/* vim: set sw=4 ts=4 expandtab : */

