/*
 * (c) copyright 1987 by the Vrije Universiteit, Amsterdam, The Netherlands.
 * See the copyright notice in the ACK home directory, in the file "Copyright".
 */

rscid = "$Header$"

			/********************************
			 *				*
			 *    68000, 68010 and 68020    *
			 *	      back end table	*
			 *				*
			 ********************************/

#include "whichone.h"

#if TBL68881 && ! TBL68020
Something very wrong here!
#endif

/*#define	FANCY_MODES
/*	On the M68020, there are some real fancy addressing modes.
	Their use makes the code a bit shorter, but also much slower.
	The FANCY_MODES #define enables the use of these addressing
	modes.
*/

#define small(x) ((x)>=1 && (x)<=8)
#define abs_small(x)	((x)>=0-8 && (x)<=8)
#define nicesize(x) ((x)==1||(x)==2||(x)==4||(x)==8)
#define lowb(x) ((x) & 0377)
#define loww(x) ((x) & 0177777)
#define in_1(x) ((x)>=0-128 && (x)<128)
#define in_2(x) ((x)>=0-32768 && (x)<32768)


EM_WSIZE = 4
EM_PSIZE = 4
EM_BSIZE = 8

SL = 8

TIMEFACTOR = 1/2


PROPERTIES

D_REG		/* data registers */
A_REG		/* address registers */
DD_REG		/* allocatable D_REG, may not be a register variable */
AA_REG		/* allocatable A_REG, may not be a register variable */
RD_REG		/* data register, register var */
RA_REG		/* address register, register var */
#if TBL68881
FS_REG		/* floating point register */
FD_REG(8)	/* double floating point register */
#endif



REGISTERS

d0, d1, d2			:D_REG, DD_REG.
d3, d4, d5, d6, d7		:D_REG, RD_REG regvar.
a0, a1				:A_REG, AA_REG.
a2, a3, a4, a5			:A_REG, RA_REG regvar(reg_pointer).
lb ("a6"), sp			:A_REG.	/* localbase and stack pointer */
#if TBL68881
F0 ("fp0"), F1 ("fp1"), F2 ("fp2"), F3 ("fp3"), F4 ("fp4"), F5 ("fp5"),
F6 ("fp6"), F7 ("fp7")		:FS_REG.
fp0=F0,fp1=F1,fp2=F2,fp3=F3,fp4=F4,fp5=F5,fp6=F6,fp7=F7
				:FD_REG.
#endif



TOKENS

	/* Not all addressing modes available on the MC68020 are used in this
	 * table. E.g (Dn), data register indirect is not used. Compared to
	 * (An), address register indirect, (Dn) requires two more bytes and
	 * several more clock cycles. Using (Dn) is even more expensive in
	 * time than first moving Dn to an address register An, and then using
	 * (An). For this kind of reasons several addressing modes are
	 * not used in this table.
	 *
	 * Cost in bytes may sometimes be incorrect. Several effective addresses
	 * use displacements that can occupy either 2 or 4 bytes. These are not
	 * considered different TOKENS in this table.
	 *
	 * Data registers are the only registers used as index registers in this
	 * table; address registers are only used to hold addresses.
	 *
	 * For the m68k4 table: the MC68000 and MC68010 have two modes that use
	 * displacements (offsets) of limited size:
	 * 	- offset(A_REG, Index_reg), where offset is only 8 bits, and
	 *	- offset(A_REG), where offset can only be 16 bits.
	 * To make sure that no output is given with offsets too large, two
	 * extra tokens are declared: t_regAregXcon and t_regAcon. These are
	 * used as addresses to these modes. Whenever the displacements become
	 * too large, they are transformed into different tokens.
	 *
	 * Sometimes some TOKENS are used with displacements (offsets) of 0.
	 * It would have been possible to provide separate TOKENS for these, in
	 * case the assembler doesn't handle zero offsets optimally. This
	 * however would mean a very large amount of extra TOKENS and SETS for
	 * a very small profit in code bytes, so we won't do that.
	 *
	 * To prevent the TOKENS list from getting too unreadable, #ifdefs are
	 * used to form three parts: 
	 *	(i)   the common part;
	 *	(ii)  the m68k4 part;
	 *	(iii) the m68020 part;
	 */

	/* Part (i) */
zero_const	= {INT num;} 4 cost(0,0) "#" num .
small_const	= {INT num;} 4 cost(0,0) "#" num .
bconst		= {INT num;} 4 cost(0,0) "#" num .
const		= {INT num;} 4 cost(4,4) "#" num .
indirect4	= {A_REG reg;} 4 cost(0,4) "(" reg ")" .
post_inc4	= {A_REG reg;} 4 cost(0,4) "(" reg ")+" .
pre_dec4	= {A_REG reg;} 4 cost(0,5) "-(" reg ")" .
dreg4		= {D_REG reg;} 4 cost(0,0) reg .
areg		= {A_REG reg;} 4 cost(0,0) reg .
dreg2		= {D_REG reg;} 4 cost(0,0) reg .
indirect2	= {A_REG reg;} 4 cost(0,4) "(" reg ")" .
post_inc2	= {A_REG reg;} 4 cost(0,4) "(" reg ")+" .
pre_dec2	= {A_REG reg;} 4 cost(0,5) "-(" reg ")" .
dreg1		= {D_REG reg;} 4 cost(0,0) reg .
indirect1	= {A_REG reg;} 4 cost(0,4) "(" reg ")" .
post_inc1	= {A_REG reg;} 4 cost(0,4) "(" reg ")+" .
pre_dec1	= {A_REG reg;} 4 cost(0,5) "-(" reg ")" .

ext_addr	= {ADDR bd;} 4 cost(4,5) "#" bd .
llabel		= {ADDR bd;} 4 cost(2,0) bd .
slabel		= {ADDR bd;} 4 cost(0,0) bd .

extend1		= {D_REG reg;} 4 cost(0,0) reg .
extend2		= {D_REG reg;} 4 cost(0,0) reg .

#ifndef TBL68020
	/* Part (ii) */
absolute4	= {ADDR bd;} 4 cost(4,8) bd .
offsetted4	= {A_REG reg; INT bd;} 4 cost(2,6) bd "(" reg ")" .
index_off4	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,7)
			    bd "(" reg "," xreg ".l)" .
absolute2	= {ADDR bd;} 4 cost(4,6) bd .
offsetted2	= {A_REG reg; INT bd;} 4 cost(2,4) bd "(" reg ")" .
index_off2	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,5)
			    bd "(" reg "," xreg ".l)" .
absolute1	= {ADDR bd;} 4 cost(4,6) bd .
offsetted1	= {A_REG reg; INT bd;} 4 cost(2,4) bd "(" reg ")" .
index_off1	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,5)
			    bd "(" reg "," xreg ".l)" .

LOCAL		= {INT bd;} 4 cost(2,6) bd "(a6)" .

local_addr	= {INT bd;} 4 cost(2,6) bd "(a6)" .
regAcon		= {A_REG reg; INT bd;} 4 cost(2,6) bd "(" reg ")" .
regAregXcon	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,8)
				bd "(" reg "," xreg ".l)" .
			/* note: in the m68k4 version %sc always equals 1 */

t_regAregXcon	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,8) .
t_regAcon	= {A_REG reg; INT bd;} 4 cost(2,6) .

#else TBL68020
	/* Part (iii) */
absolute4	= {ADDR bd;} 4 cost(4,7) "(" bd ")" .
offsetted4	= {A_REG reg; INT bd;} 4 cost(2,6) "(" bd "," reg ")" .
index_off4	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(4,9)
			    "(" bd "," reg "," xreg ".l*" sc ")" .
abs_index4	= {INT sc; D_REG xreg; ADDR bd;} 4 cost(6,9)
			    "(" bd "," xreg ".l*" sc ")" .
OFF_off4	= {A_REG reg; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," od ")" .
OFF_indoff4	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," xreg ".l*" sc "," od ")" .
INDOFF_off4	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "," xreg ".l*" sc "]," od ")" .
ABS_off4	= {ADDR bd; ADDR od;} 4 cost(8,22) "([" bd "]," od ")" .
ABS_indoff4	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "]," xreg ".l*" sc "," od ")" .
ABSIND_off4	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "," xreg ".l*" sc "]," od ")" .

absolute2	= {ADDR bd;} 4 cost(4,7) "(" bd ")" .
offsetted2	= {A_REG reg; INT bd;} 4 cost(2,6) "(" bd "," reg ")" .
index_off2	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(4,9)
			    "(" bd "," reg "," xreg ".l*" sc ")" .
abs_index2	= {INT sc; D_REG xreg; ADDR bd;} 4 cost(6,9)
			    "(" bd "," xreg ".l*" sc ")" .
OFF_off2	= {A_REG reg; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," od ")" .
OFF_indoff2	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," xreg ".l*" sc "," od ")" .
INDOFF_off2	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "," xreg ".l*" sc "]," od ")" .
ABS_off2	= {ADDR bd; ADDR od;} 4 cost(8,22) "([" bd "]," od ")" .
ABS_indoff2	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "]," xreg ".l*" sc "," od ")" .
ABSIND_off2	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "," xreg ".l*" sc "]," od ")" .

absolute1	= {ADDR bd;} 4 cost(4,7) "(" bd ")" .
offsetted1	= {A_REG reg; INT bd;} 4 cost(2,6) "(" bd "," reg ")" .
index_off1	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(4,9)
			    "(" bd "," reg "," xreg ".l*" sc ")" .
abs_index1	= {INT sc; D_REG xreg; ADDR bd;} 4 cost(6,9)
			    "(" bd "," xreg ".l*" sc ")" .
OFF_off1	= {A_REG reg; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," od ")" .
OFF_indoff1	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "]," xreg ".l*" sc "," od ")" .
INDOFF_off1	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,19)
			    "([" bd "," reg "," xreg ".l*" sc "]," od ")" .
ABS_off1	= {ADDR bd; ADDR od;} 4 cost(8,22) "([" bd "]," od ")" .
ABS_indoff1	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "]," xreg ".l*" sc "," od ")" .
ABSIND_off1	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,22)
			    "([" bd "," xreg ".l*" sc "]," od ")" .

LOCAL		= {INT bd;} 4 cost(2,6) "(" bd ",a6)" .
ILOCAL		= {INT bd;} 4 cost(4,16) "([" bd ",a6])" .

local_addr	= {INT bd;} 4 cost(2,3) "(" bd ",a6)" .
regAcon		= {A_REG reg; INT bd;} 4 cost(2,3) "(" bd "," reg ")" .
regAregXcon	= {A_REG reg; D_REG xreg; INT sc; INT bd;} 4 cost(2,7)
				"(" bd "," reg "," xreg ".l*" sc ")" .
off_con		= {A_REG reg; INT bd; ADDR od;} 4 cost(6,18)
				"([" bd "," reg "]," od ")".
off_regXcon	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,18)
				"([" bd "," reg "]," xreg ".l*" sc "," od ")" .
indoff_con	= {A_REG reg; D_REG xreg; INT sc; INT bd; ADDR od;} 4 cost(6,18)
				"([" bd "," reg "," xreg ".l*" sc "]," od ")" .
abs_con		= {ADDR bd; ADDR od;} 4 cost(8,21) "([" bd "]," od ")" .
abs_regXcon	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,21)
				"([" bd "]," xreg ".l*" sc "," od ")" .
absind_con	= {INT sc; D_REG xreg; ADDR bd; ADDR od;} 4 cost(8,21)
				"([" bd "," xreg ".l*" sc "]," od ")" .
ext_regX	= {INT sc; D_REG xreg; ADDR bd;} 4 cost(6,15)
				"(" bd "," xreg ".l*" sc ")" .

regX		= {INT sc; D_REG xreg;} 4 cost(2,7) "(" xreg ".l*" sc ")" .
DREG_pair	= {D_REG reg1; D_REG reg2;} 8 cost(2,0) reg1 ":" reg2 .

#define	t_regAregXcon	regAregXcon
#define t_regAcon	regAcon

#endif TBL68020

SETS

		/* The SETS list cannot be kept as 'readable' as the TOKENS list
		 * because cgg is one pass.
		 */

sconsts		= small_const + bconst .
consts		= const + sconsts + zero_const .
#ifndef TBL68020
	/* A m68k4 part */
data4		= D_REG + LOCAL + consts + post_inc4 + pre_dec4 +
		  indirect4 + offsetted4 + index_off4 + absolute4 +
		  ext_addr + dreg4 .
memory4		= data4 - D_REG - dreg4 .
control4	= indirect4 + offsetted4 + index_off4 + absolute4 +
		  LOCAL .
alterable4	= data4 + A_REG - consts - ext_addr .
any4		= data4 + A_REG . /* all four above together */

data2		= dreg2 + post_inc2 + pre_dec2 + indirect2 +
		  offsetted2 + index_off2 + absolute2 + consts .
memory2		= data2 - dreg2 .
control2	= indirect2 + offsetted2 + index_off2 + absolute2 .
alterable2	= data2 + D_REG - consts .
any2		= data2 + D_REG.

data1		= dreg1 + post_inc1 + pre_dec1 + indirect1 +
		  offsetted1 + index_off1 + absolute1 + consts .
memory1		= data1 - dreg1 .
control1	= indirect1 + offsetted1 + index_off1 + absolute1 .
alterable1	= data1 + D_REG - consts .
any1		= data1 + D_REG.

#else TBL68020

data4		= D_REG + indirect4 + post_inc4 + pre_dec4 + index_off4 +
		  offsetted4 + OFF_off4 + OFF_indoff4 +
		  INDOFF_off4 + dreg4 +
		  ABS_off4 + ABS_indoff4 + ABSIND_off4 +
		  absolute4 + abs_index4 + consts + ext_addr +
		  LOCAL + ILOCAL .
memory4		= data4 - D_REG - dreg4 .
control4	= memory4 - (post_inc4 + pre_dec4 + consts + ext_addr).
alterable4	= data4 + A_REG - consts - ext_addr .
any4		= data4 + A_REG . /* all four above together */

data2		= dreg2 + indirect2 + post_inc2 + pre_dec2 + index_off2 +
		      offsetted2 + OFF_off2 + OFF_indoff2 +
		  INDOFF_off2 +
		  ABS_off2 + ABS_indoff2 + ABSIND_off2 +
		  absolute2 + abs_index2 + consts .
memory2		= data2 - dreg2 .
control2	= memory2 - (post_inc2 + pre_dec2 + consts ) .
alterable2	= data2 + D_REG - consts .
any2		= data2 + D_REG. /* all four above together */

data1		= dreg1 + indirect1 + post_inc1 + pre_dec1 + index_off1 +
		      offsetted1 + OFF_off1 + OFF_indoff1 +
		  INDOFF_off1 +
		  ABS_off1 + ABS_indoff1 + ABSIND_off1 +
		  absolute1 + abs_index1 + consts .
memory1		= data1 - dreg1 .
control1	= memory1 - (post_inc1 + pre_dec1 + consts ) .
alterable1	= data1 + D_REG - consts .
any1		= data1  + D_REG. /* all four above together */

#endif TBL68020
	/* This is a common part */
any		= any4 + any2 + any1 .
absolute	= absolute4 + absolute2 + absolute1 .
control		= control4 + control2 + control1 .
indirect	= indirect4 + indirect2 + indirect1 .
pre_post	= pre_dec4 + pre_dec2 + pre_dec1 +
		  post_inc4 + post_inc2 + post_inc1 .
offsetted	= offsetted4 + offsetted2 + offsetted1 .
index_off	= index_off4 + index_off2 + index_off1 .

#ifndef TBL68020
	/* A m68k4 part */
regind_addr	= regAcon + regAregXcon + t_regAcon + t_regAregXcon .
address		= ext_addr + local_addr + regAcon + regAregXcon .
all_regind	= indirect + offsetted + pre_post + index_off +
		      regind_addr .
all_indir	= all_regind .
allexceptcon	= ALL - ( D_REG + A_REG + consts + dreg2 + dreg1 +
		    local_addr + ext_addr + regAcon + regAregXcon +
		    t_regAcon + t_regAregXcon ) .
use_index	= index_off4 + index_off2 + index_off1 .

#else TBL68020

reg_memind4	= OFF_off4 + OFF_indoff4 + INDOFF_off4 .
memind4		= reg_memind4 +
		  ABS_off4 + ABS_indoff4 .
reg_memind2	= OFF_off2 + OFF_indoff2 + INDOFF_off2 .
memind2		= reg_memind2 +
		  ABS_off2 + ABS_indoff2 .
reg_memind1	= OFF_off1 + OFF_indoff1 + INDOFF_off1 .
memind1		= reg_memind1 +
		  ABS_off1 + ABS_indoff1 .
reg_memind	= reg_memind4 + reg_memind2 + reg_memind1 .
memind		= memind4 + memind2 + memind1 .
regind_addr	= regAcon + regAregXcon +
		  off_con + off_regXcon +
		  indoff_con .
address		= regind_addr +
		  ext_addr + local_addr +
		  abs_con + abs_regXcon +
		  absind_con +
		  ext_regX .
all_regind	= indirect + offsetted + index_off + pre_post +
		      reg_memind + regind_addr .
all_indir	= all_regind + memind + ILOCAL .
allexceptcon	= ALL - ( D_REG + A_REG + consts + dreg2 + dreg1 +
		    local_addr + ext_addr + regAcon + regAregXcon + ext_regX ) .
use_index4	= index_off4 + abs_index4 +
		  OFF_indoff4 + INDOFF_off4 +
		  ABS_indoff4 + ABSIND_off4 .
use_index2	= index_off2 + abs_index2 +
		  OFF_indoff2 + INDOFF_off2 +
		  ABS_indoff2 + ABSIND_off2 .
use_index1	= index_off1 + abs_index1 +
		  OFF_indoff1 + INDOFF_off1 +
		  ABS_indoff1 + ABSIND_off1 .
use_indaddr	= regAregXcon + 
		  off_regXcon + indoff_con +
		  abs_regXcon + absind_con +
		  ext_regX .

use_index	= use_index4 + use_index2 + use_index1 + use_indaddr + regX .

#endif TBL68020
	/* A common part */
posextern	= absolute + all_indir .

genreg		= D_REG + A_REG.
label		= llabel + slabel .
immediate4	= consts + ext_addr .
conreg4		= D_REG + immediate4 .
conreg2		= dreg2 + consts + D_REG .
conreg1		= dreg1 + consts + D_REG .
conreg		= conreg1 + conreg2 + conreg4 .
shconreg	= D_REG + small_const .
datalt4		= data4 * alterable4 .
datalt2		= data2 * alterable2 .
datalt1		= data1 * alterable1 .
datalt		= datalt4 + datalt2 + datalt1 .
memalt4		= memory4 * alterable4 .
memalt2		= memory2 * alterable2 .
memalt1		= memory1 * alterable1 .

#ifndef TBL68020
	/* A m68k4 part */
imm_cmp4	= alterable4 - A_REG .
imm_cmp2	= alterable2 + D_REG .
imm_cmp1	= datalt1 + D_REG .

test_set4	= datalt4 + extend2 + extend1 .
test_set2	= datalt2 .
test_set1	= datalt1 .

#else TBL68020

imm_cmp4	= any4 - immediate4 - A_REG .
imm_cmp2	= any2 - consts .
imm_cmp1	= any1 - consts .

test_set4	= any4 - immediate4 + extend2 + extend1 .
test_set2	= data2 - consts .
test_set1	= data1 - consts .

#endif TBL68020

test_set	= test_set4 + test_set2 + test_set1 .

#ifndef TBL68020
t_address	= address + t_regAregXcon + t_regAcon .
#else TBL68020
#define	t_address	address
#endif TBL68020

#if TBL68881
freg		= FD_REG + FS_REG .
store4		= any4 + FS_REG .
#else
store4		= any4 .
#endif
dups4		= genreg .

INSTRUCTIONS

	/* Since the 68000 , the 68010 and the 68020 instruction sets are rather
	 * extensive, especially because e.g. 'add.l' and 'add.w' are
	 * considered different instructions, only those instructions are
	 * listed here that are used in the rest of this table.
	 *
	 * Instruction timing cost cannot be accurately given, nor the timing
	 * cost for getting operands. Detailed information about this can be
	 * found in the "MC68020 User's Manual", section 9, about instruction
	 * timing. The cost used in this table are 'worst case' cost, as
	 * mentioned in section 9 of the user's manual.
	 *
	 * The first few instructions had to be added because register
	 * variables are used. The LOCALs below are register variables.
	 * One may not conclude that these operations are also allowed
	 * on LOCALs that are not register variables.
	 * The cost have been adapted, but are not accurate; when 'real'
	 * LOCALs are used the cost are very inaccurate.
	 */

add_l  "add.l"	any4:ro,	LOCAL:rw:cc		cost(0,0).
lea		address:ro,	LOCAL:wo		cost(0,0).
sub_l  "sub.l"	any4:ro,	LOCAL:rw:cc		cost(0,0).
sh   "illegal"	shconreg+LOCAL:ro,	LOCAL:rw:cc		cost(0,0).
xxx  "illegal"	data4:ro,	LOCAL:rw:cc		cost(0,0).
xxx  "illegal"	LOCAL:ro,	alterable4:rw:cc	cost(0,0).
#ifdef TBL68020
divs_l "divs.l" data4:ro,	LOCAL:rw:cc		cost(0,90).
divu_l "divu.l" data4:ro,	LOCAL:rw:cc		cost(0,78).
muls_l "muls.l" data4:ro,	LOCAL:rw:cc		cost(0,44).
mulu_l "mulu.l" data4:ro,	LOCAL:rw:cc		cost(0,44).
#endif TBL68020

add_l  "add.l"	any4:ro,	D_REG+LOCAL:rw:cc	cost(2,3).
add_l  "add.l"	any4:ro,	A_REG+LOCAL+areg:rw	cost(2,3).
add_l  "add.l"	conreg4:ro,	alterable4:rw:cc	cost(2,6).
and_l  "and.l"	data4:ro,	D_REG:rw:cc		cost(2,3).
and_l  "and.l"	D_REG:ro,	memalt4:rw:cc		cost(2,6).
and_l  "and.l"	consts:ro,	datalt4:rw:cc		cost(2,6).
asl_l  "asl.l"	shconreg:ro,	D_REG:rw:cc		cost(2,5).
asl   "asl #1,"	memalt2:rw:cc				cost(2,4).
asr_l  "asr.l"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
asr   "asr #1,"	memalt2:rw:cc				cost(2,4).
bclr		const:ro,	D_REG:rw kills:cc	cost(2,4).
bra		label					cost(2,5).
bcc		label					cost(2,5).
bcs		label					cost(2,5).
beq		label					cost(2,5).
bge		label					cost(2,5).
bgt		label					cost(2,5).
bhi		label					cost(2,5).
ble		label					cost(2,5).
bls		label					cost(2,5).
blt		label					cost(2,5).
bmi		label					cost(2,5).
bne		label					cost(2,5).
bpl		label					cost(2,5).
bvc		label					cost(2,5).
bvs		label					cost(2,5).
bset		conreg2:ro,	D_REG:rw kills :cc	cost(2,4).
btst		conreg2:ro,	any1:rw kills :cc	cost(2,3).
clr_l  "clr.l"	D_REG+dreg4:wo:cc			cost(2,3).
clr_l  "clr.l"	memalt4:wo:cc				cost(2,6).
clr_w  "clr.w"	D_REG+dreg4:wo:cc			cost(2,2).
clr_w  "clr.w"	memalt2:wo:cc				cost(2,4).
clr_b  "clr.b"	D_REG+dreg4:wo:cc			cost(2,2).
clr_b  "clr.b"	memalt1:wo:cc				cost(2,4).
cmp_l  "cmp.l"	any4:ro,	genreg:ro kills :cc	cost(2,3).
cmp_l  "cmp.l"	post_inc4:ro,	post_inc4:ro kills :cc 	cost(2,2).
cmp_l  "cmp.l"	immediate4:ro,	imm_cmp4:ro kills :cc	cost(2,2).
cmp_w  "cmp.w"	any2+extend2:ro,	dreg2+extend2:ro kills :cc	cost(2,3).
cmp_w  "cmp.w"	post_inc2:ro,	post_inc2:ro kills :cc 	cost(2,2).
cmp_w  "cmp.w"	consts:ro,	imm_cmp2:ro kills :cc	cost(2,2).
cmp_b  "cmp.b"	any1+extend1:ro,	dreg1+extend1:ro kills :cc	cost(2,3).
cmp_b  "cmp.b"	post_inc1:ro,	post_inc1:ro kills :cc 	cost(2,2).
cmp_b  "cmp.b"	consts:ro,	imm_cmp1:ro kills :cc	cost(2,2).
dbf		D_REG:rw,	label			cost(2,5).
eor_l  "eor.l"	conreg4:ro,	datalt4:rw:cc		cost(2,6).
/* in the next two instructions: LOCAL only allowed if register var */
ext_l  "ext.l"	extend1+extend2+D_REG+LOCAL:rw:cc			cost(2,2).
ext_w  "ext.w"	extend1+D_REG+LOCAL:rw:cc			cost(2,2).
jmp		address+control4			cost(2,0).
jsr		address+control4 kills :cc d0 d1 d2 a0 a1 cost(2,3).
lea		address+control4:ro, A_REG+areg:wo	cost(2,0).
lsl_l  "lsl.l"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
lsl   "lsl #1,"	memalt2:rw:cc				cost(2,4).
lsr_l  "lsr.l"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
lsr   "lsr #1,"	memalt2:rw:cc				cost(2,4).
/* move_l does not set the condition codes if the destination is an
   address register!
*/
move_l "move.l" any4:ro,	A_REG+areg:wo		cost(2,2).
move_l "move.l" any4:ro,	alterable4+dreg4:wo:cc	cost(2,2).
move_w "move.w" any2:ro,	alterable2+dreg4:wo:cc	cost(2,2).
move_b "move.b" any1:ro,	alterable1+dreg4:wo:cc	cost(2,2).
neg_b  "neg.b"	D_REG:rw:cc				cost(2,3).
neg_l  "neg.l"	D_REG:rw:cc				cost(2,3).
neg_l  "neg.l"	memory4:rw:cc				cost(2,6).
not_l  "not.l"	D_REG:rw:cc				cost(2,3).
not_l  "not.l"	memory4:rw:cc				cost(2,6).
or_l   "or.l"	data4:ro,	D_REG:rw:cc		cost(2,3).
or_l   "or.l"	D_REG:ro,	memalt4:rw:cc		cost(2,6).
or_l   "or.l"	consts:ro,	datalt4:rw:cc		cost(2,6).
rol_l  "rol.l"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
rol   "rol #1,"	memalt2:rw:cc				cost(2,4).
ror_l  "ror.l"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
ror   "ror #1,"	memalt2:rw:cc				cost(2,4).
roxl "roxl #1,"	memalt2:rw:cc				cost(2,4).
roxr "roxr #1,"	memalt2:rw:cc				cost(2,4).
sne		datalt1:rw				cost(2,3).
sub_l  "sub.l"	any4:ro,	D_REG:rw:cc		cost(2,3).
sub_l  "sub.l"	any4+areg:ro,	A_REG+areg:rw		cost(2,3).
sub_l  "sub.l"	conreg4:ro,	alterable4:rw:cc	cost(2,6).
tst_l  "tst.l"	test_set4:ro:cc				cost(2,3).
tst_w  "tst.w"	test_set2+extend2:ro:cc				cost(2,3).
tst_b  "tst.b"	test_set1+extend1:ro:cc				cost(2,3).
unlk		A_REG					cost(2,6).

bxx  "illegal"	label					cost(2,5).
sxx  "illegal"	any4:wo					cost(2,5).
xxx  "illegal"	any4:ro,	any4:rw:cc		cost(2,3).
bit  "illegal"	control4:rw:cc				cost(2,6).
sh   "illegal"	shconreg:ro,	D_REG:rw:cc		cost(2,4).
shw  "illegal"	control2:rw:cc				cost(2,4).

#ifdef TBL68020
cmp2_l "cmp2.l" address+control4:ro, genreg:ro kills :cc cost(2,18).
divs_l "divs.l" data4:ro,	D_REG:rw:cc		cost(2,90).
divsl_l "divsl.l" data4:ro,	DREG_pair:rw kills :cc	cost(2,90).
divu_l "divu.l" data4:ro,	D_REG:rw:cc		cost(2,78).
divul_l "divul.l" data4:ro,	DREG_pair:rw kills :cc	cost(2,78).
/* in the next instruction: LOCAL only allowed if register var */
extb_l "extb.l" extend1+D_REG+LOCAL:rw:cc			cost(2,4).
muls_l "muls.l" data4:ro,	D_REG+LOCAL:rw:cc		cost(2,44).
mulu_l "mulu.l" data4:ro,	D_REG+LOCAL:rw:cc		cost(2,44).
pea		address+control4+regX			cost(2,4).
#else TBL68020
pea		address+control4			cost(2,4).
#endif TBL68020

	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 * Extra pseudo instruction; it just kills a D_REG;
	 * it is necessary with long divides where remainders are important;
	 * see also: 'pat rmi' and 'pat rmu'
	 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
killreg "! kill" D_REG+A_REG:wo				cost(0,0).
#if TBL68881
/* These descriptions are not very accurate, because we have no
   other 8-byte objects in the table.
 */
fmove_s "fmove.s" data4:ro, freg:wo			cost(4,100).
fmove_s "fmove.s" freg:ro, data4:wo			cost(4,100).
fmove_d "fmove.d" freg:ro, data4:wo			cost(4,100).
fmove_d "fmove.d" data4:ro, freg:ro			cost(4,100).
fmove_l "fmove.l" freg:ro, D_REG:wo			cost(4,100).
fmove_l "fmove.l" data4:ro, freg:wo			cost(4,100).
fmove freg:ro,freg:wo					cost(4,100).
fadd_s "fadd.s" data4:ro, freg:rw			cost(4,100).
fadd_d "fadd.d" data4:ro, freg:rw			cost(4,100).
fsub_s "fsub.s" data4:ro, freg:rw			cost(4,100).
fsub_d "fsub.d" data4:ro, freg:rw			cost(4,100).
fsub freg:ro, freg:rw					cost(4,100).
fmul freg:ro, freg:rw					cost(4,100).
fmul_s "fmul.s" data4:ro, freg:rw			cost(4,100).
fmul_d "fmul.d" data4:ro, freg:rw			cost(4,100).
fdiv freg:ro, freg:rw					cost(4,100).
fdiv_s "fdiv.s" data4:ro, freg:rw			cost(4,100).
fdiv_d "fdiv.d" data4:ro, freg:rw			cost(4,100).
fcmp freg:ro, freg:ro					cost(4,100).
fbeq label:ro						cost(4,4).
fblt label:ro						cost(4,4).
fmovecr const:ro, freg:rw				cost(4,100).
fabs freg:rw						cost(4,100).
fneg freg:rw						cost(4,100).
fgetman freg:rw						cost(4,100).
fintrz freg:ro, freg:wo					cost(4,100).
fgetexp freg:ro, freg:wo				cost(4,100).
fsub_l "fsub.l" const:ro, freg:rw			cost(4,100).
#endif

MOVES

from consts %num==0 to D_REG+dreg4
    gen clr_l %2

from consts %num==0 to A_REG+areg
    gen sub_l %2,%2

from consts %num==0 to memalt4
    gen clr_l %2

from consts %num==0 to memalt2
    gen clr_w %2

from consts %num==0 to memalt1
    gen clr_b %2

from consts to memalt1
    gen move_b {const, lowb(%1.num)}, %2

from consts to memalt2
    gen move_w {const, loww(%1.num)}, %2

from regAcon %bd==0 to A_REG+areg
    gen move_l %1.reg, %2

#ifndef TBL68020
from t_regAregXcon sfit(%bd, 8) to A_REG+areg
    gen lea {regAregXcon, %1.reg, %1.xreg, 1, %1.bd}, %2

from t_regAregXcon to A_REG+areg
    gen lea {regAregXcon, %1.reg, %1.xreg, 1, 0}, %2
	add_l {const, %1.bd}, %2

from t_regAcon sfit(%bd, 16) to A_REG+areg
    gen lea {regAcon, %1.reg, %1.bd}, %2

from t_regAcon to A_REG+areg
    gen move_l %1.reg, %2
	add_l {const, %1.bd}, %2
#endif TBL68020

from address - ext_addr to A_REG+areg
    gen lea %1, %2

from any4 to alterable4
    gen move_l %1, %2

from any4 to areg
    gen move_l %1, %2

from any2 to alterable2
    gen move_w %1, %2

from any1 to alterable1
    gen move_b %1, %2

from any2 to dreg4
    gen clr_l %2
	move_w %1, %2

from any1 to dreg4
    gen clr_l %2
	move_b %1, %2

#if TBL68881
from data4 to FS_REG
    gen fmove_s %1, %2

from FS_REG to datalt4
    gen fmove_s %1, %2
#endif

TESTS


to test test_set4-(extend2+extend1)
    gen tst_l %1

to test test_set2+extend2
    gen tst_w %1

to test test_set1+extend1
    gen tst_b %1


STACKINGRULES


from consts %num==0 to STACK
    gen clr_l {pre_dec4, sp}

#ifndef TBL68020
from t_regAregXcon sfit(%bd, 8) to STACK
    gen pea {regAregXcon, %1.reg, %1.xreg, 1, %1.bd}

from t_regAregXcon to STACK
    gen pea {regAregXcon, %1.reg, %1.xreg, 1, 0}
	add_l {const, %1.bd}, {indirect4, sp}

from t_regAcon sfit(%bd, 16) to STACK
    gen pea {regAcon, %1.reg, %1.bd}

from t_regAcon to STACK
    gen move_l %1.reg, {pre_dec4, sp}
	add_l {const, %1.bd}, {indirect4, sp}
#endif TBL68020

from A_REG to STACK
    gen pea {indirect4, %1}

from address - ext_addr to STACK
    gen pea %1

from ext_addr to STACK
    gen pea {absolute4, %1.bd}

from consts to STACK
    gen pea {absolute4, %1.num}

from any4 to STACK
    gen move_l %1, {pre_dec4, sp}

from any2 to STACK
  uses DD_REG
    gen clr_l %a
	move_w %1, {dreg2, %a}
	move_l %a, {pre_dec4, sp}

from any2 to STACK
    gen clr_l {pre_dec4, sp}
	move_w %1, {offsetted2, sp, 2}

from data1 to STACK
  uses DD_REG
    gen clr_l %a
	move_b %1, {dreg1, %a}
	move_l %a, {pre_dec4, sp}

from data1 to STACK
    gen clr_l {pre_dec4, sp}
	move_b %1, {offsetted1, sp, 3}

from extend2 to STACK
    gen ext_l	%1.reg
	move_l	%1.reg,{pre_dec4, sp}

from extend1 to STACK
#ifdef TBL68020
    gen extb_l	%1.reg
#else
    gen	ext_w	%1.reg
	ext_l	%1.reg
#endif
	move_l	%1.reg,{pre_dec4, sp}

#ifdef TBL68020
from regX to STACK
    gen pea %1
#endif TBL68020
	/* This last stackingrule is never used: whenever regX is put on
	 * the fakestack, some em-instuctions are left that remove it
	 * immediately. However cgg complained about not having a
	 * stackingrule for regX, so here it is
	 */

#if TBL68881
from FS_REG to STACK
    gen fmove_s %1,{pre_dec4,sp}

from FD_REG to STACK
    gen fmove_d %1,{pre_dec4,sp}
#endif
COERCIONS


from STACK
    uses DD_REG
    gen move_l {post_inc4, sp}, %a
			yields	%a

from STACK
    uses AA_REG
    gen move_l {post_inc4, sp}, %a
			yields	%a

#ifdef TBL68881
from STACK
    uses FS_REG
    gen fmove_s {post_inc4, sp}, %a
			yields	%a
from STACK
    uses FD_REG
    gen fmove_d {post_inc4, sp}, %a
			yields	%a
#endif

#ifndef TBL68020
from t_regAregXcon sfit(%bd, 8)
			yields	{regAregXcon, %1.reg, %1.xreg, 1, %1.bd}

from t_regAregXcon
    uses AA_REG=%1.reg
    gen add_l {const, %1.bd}, %a
			yields	{regAregXcon, %a, %1.xreg, 1, 0}

from t_regAcon sfit(%bd, 16)
			yields	{regAcon, %1.reg, %1.bd}

from t_regAcon
    uses reusing %1, AA_REG=%1.reg
    gen add_l {const, %1.bd}, %a
			yields	%a
#endif TBL68020

from t_address
    uses reusing %1, AA_REG = %1
			yields	%a

from any4
    uses reusing %1, DD_REG = %1
			yields	%a

from any4
    uses reusing %1, AA_REG = %1
			yields	%a
#if TBL68881
from data4
    uses reusing %1, FS_REG = %1
			yields	%a
#endif

from memory2
    uses DD_REG = {const, 0}
    gen move_w %1, %a	yields	%a

from memory1
    uses DD_REG = {const, 0}
    gen move_b %1, %a	yields	%a

from memory2
    uses DD_REG
    gen move_w %1, %a	yields	{dreg2, %a}

from memory1
    uses DD_REG
    gen move_b %1, %a	yields	{dreg1, %a}

from extend2
    gen ext_l	%1.reg	yields	%1.reg

from extend1
#ifdef TBL68020
    gen extb_l	%1.reg	yields	%1.reg
#else
    gen	ext_w	%1.reg
	ext_l	%1.reg	yields	%1.reg
#endif


PATTERNS

/********************************
 * First some longer patterns	*
 ********************************/

pat lol sbi stl $1==$3 && $2==4 && inreg($1)==reg_any
with any4
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen sub_l %1, {LOCAL, $1}
	neg_l {LOCAL, $1}

pat lol sbi stl $1==$3 && $2==4 && inreg($1)!=reg_pointer
with conreg4-bconst
    kills all_indir, LOCAL %bd==$1
    gen sub_l %1, {LOCAL, $1}
	neg_l {LOCAL, $1}

pat lol sbu stl $1==$3 && $2==4 
			leaving lol $1 sbi 4 stl $1

pat lil sbi sil $1==$3 && $2==4 && inreg($1)==reg_pointer
with conreg4-bconst
    kills allexceptcon
    gen sub_l %1, {indirect4, regvar($1, reg_pointer)}
	neg_l {indirect4, regvar($1, reg_pointer)}

pat lil sbi sil $1==$3 && $2==4 && inreg($1)!=reg_any
with conreg4-bconst
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}
    gen	sub_l %1, {indirect4, %a}
	neg_l {indirect4, %a}

pat lil sbu sil $1==$3 && $2==4
			leaving lil $1 sbi 4 sil $1

proc lolrbitstl example lol ngi stl
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen bit* {LOCAL, $1}

pat lol ngi stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolrbitstl("neg.l")
pat lol com stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolrbitstl("not.l")

proc lolbitstl example lol ngi stl
    kills all_indir, LOCAL %bd==$1
    gen bit* {LOCAL, $1}

pat lol ngi stl $1==$3 && $2==4		call lolbitstl("neg.l")
pat lol com stl $1==$3 && $2==4		call lolbitstl("not.l")

proc loebitste example loe ngi ste
    kills posextern
    gen bit* {absolute4, $1}

pat loe ngi ste $1==$3 && $2==4		call loebitste("neg.l")
pat loe com ste $1==$3 && $2==4		call loebitste("not.l")

proc lilrbitsil example lil ngi sil
    kills allexceptcon
    gen bit* {indirect4, regvar($1, reg_pointer)}

pat lil ngi sil $1==$3 && $2==4 && inreg($1)==reg_pointer
					call lilrbitsil("neg.l")
pat lil com sil $1==$3 && $2==4 && inreg($1)==reg_pointer
					call lilrbitsil("not.l")
pat lil dec sil $1==$3 && inreg($1)==reg_pointer
					call lilrbitsil("sub.l #1,")
pat lil inc sil $1==$3 && inreg($1)==reg_pointer
					call lilrbitsil("add.l #1,")

proc lilbitsil example lil ngi sil
    kills allexceptcon
#if TBL68020
    gen bit* {ILOCAL, $1}
#else
    uses AA_REG = {LOCAL, $1}
    gen bit* {indirect4, %a}
#endif

pat lil ngi sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilbitsil("neg.l")
pat lil com sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilbitsil("not.l")
pat lil dec sil $1==$3 && inreg($1)!=reg_any
					call lilbitsil("sub.l #1,")
pat lil inc sil $1==$3 && inreg($1)!=reg_any
					call lilbitsil("add.l #1,")

proc lolcshstl example lol loc sli stl
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen sh* {small_const, $2}, {LOCAL, $1}

pat lol loc sli stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("asl.l")
pat lol loc sri stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("asr.l")
pat lol loc slu stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("asl.l")
pat lol loc sru stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("lsr.l")
pat lol loc rol stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("rol.l")
pat lol loc ror stl $1==$4 && small($2) && $3==4 && inreg($1)==reg_any
					call lolcshstl("ror.l")

proc lolrshstl example lol lol sli stl
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen sh* {LOCAL, $2}, {LOCAL, $1}

pat lol lol sli stl $1==$4 && inreg($1)==reg_any && $3==4 && inreg($2)==reg_any
					call lolrshstl("asl.l")
pat lol lol slu stl $1==$4 && inreg($1)==reg_any && $3==4 && inreg($2)==reg_any
					call lolrshstl("asl.l")
pat lol lol sri stl $1==$4 && inreg($1)==reg_any && $3==4 && inreg($2)==reg_any
					call lolrshstl("asr.l")
pat lol lol sru stl $1==$4 && inreg($1)==reg_any && $3==4 && inreg($2)==reg_any
					call lolrshstl("lsr.l")
pat lol lol rol stl $1==$4 && inreg($2)==reg_any && $3==4 && inreg($1)==reg_any
					call lolrshstl("rol.l")
pat lol lol ror stl $1==$4 && inreg($2)==reg_any && $3==4 && inreg($1)==reg_any
					call lolrshstl("ror.l")

proc lil1shlsil example lil loc sli sil		/* only left */
    kills allexceptcon
    gen shw* {offsetted2, regvar($1, reg_pointer), 2}
	roxl {indirect2, regvar($1, reg_pointer)}

pat lil loc sli sil $1==$4 && $2==1 && $3==4 && inreg($1)==reg_pointer
					call lil1shlsil("asl #1,")
pat lil loc slu sil $1==$4 && $2==1 && $3==4 && inreg($1)==reg_pointer
					call lil1shlsil("asl #1,")

proc lil1shrsil example lil loc sli sil		/* only right */
    kills allexceptcon
    gen shw* {indirect2, regvar($1, reg_pointer)}
	roxr {offsetted2, regvar($1, reg_pointer), 2}

pat lil loc sri sil $1==$4 && $2==1 && $3==4 && inreg($1)==reg_pointer
					call lil1shrsil("asr #1,")
pat lil loc sru sil $1==$4 && $2==1 && $3==4 && inreg($1)==reg_pointer
					call lil1shrsil("lsr #1,")



pat lol lof inc lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
    kills allexceptcon
    gen add_l {const, 1}, {offsetted4, regvar($1, reg_pointer), $2}

pat lol lof dec lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
    kills allexceptcon
    gen sub_l {const, 1}, {offsetted4, regvar($1, reg_pointer), $2}

pat lol lof adp lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
    kills allexceptcon
    gen add_l {const, $3}, {offsetted4, regvar($1, reg_pointer), $2}

pat loe lof adp loe stf $1==$4 && $2==$5
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen add_l {const, $3}, {ABS_off4, $1, $2}
#else
    uses AA_REG={absolute4, $1}
    gen add_l {const, $3}, {offsetted4, %a, $2}
#endif

pat loe loi adp loe sti $1==$4 && $2==4 && $5==4
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen add_l {const, $3}, {ABS_off4, $1, 0}
#else
    uses AA_REG={absolute4, $1}
    gen add_l {const, $3}, {indirect4, %a}
#endif

pat lil lof adp lil stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen add_l {const, $3}, {OFF_off4, regvar($1, reg_pointer), 0, $2}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen add_l {const, $3}, {offsetted4, %a, $2}
#endif

pat lil loi adp lil sti $1==$4 && $2==4 && $5==4 && inreg($1)==reg_pointer
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen add_l {const, $3}, {OFF_off4, regvar($1, reg_pointer), 0, 0}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen add_l {const, $3}, {indirect4, %a}
#endif

pat lol inl $1==$2 && inreg($1)==reg_any
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    uses DD_REG = {LOCAL, $1}
    gen add_l {const, 1}, {LOCAL, $1}
	killreg %a
			yields %a

pat lol del $1==$2 && inreg($1)==reg_any
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    uses DD_REG = {LOCAL, $1}
    gen sub_l {const, 1}, {LOCAL, $1}
	killreg %a
			yields %a


proc lolxxstl example lol and stl
with data4-bconst
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen xxx* %1, {LOCAL, $1}

pat lol adi stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolxxstl("add.l")
pat lol adu stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolxxstl("add.l")
pat lol and stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolxxstl("and.l")
pat lol ior stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolxxstl("or.l")
pat lol xor stl $1==$3 && $2==4 && inreg($1)==reg_any
					call lolxxstl("eor.l")
#ifdef TBL68020
pat lol mli stl $1==$3 && $2==4 && inreg($1)==reg_any
with data4
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen muls_l %1, {LOCAL, $1}
pat lol mlu stl $1==$3 && $2==4 && inreg($1)==reg_any
with data4
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen mulu_l %1, {LOCAL, $1}
#endif TBL68020

proc lolxxxstl example lol adi stl
with conreg4-bconst
    kills all_indir, LOCAL %bd==$1
    gen xxx* %1, {LOCAL, $1}

pat lol adi stl $1==$3 && $2==4		call lolxxxstl("add.l")
pat lol adu stl $1==$3 && $2==4		call lolxxxstl("add.l")
pat lol and stl $1==$3 && $2==4 && inreg($1)!=reg_pointer
					call lolxxxstl("and.l")
pat lol ior stl $1==$3 && $2==4 && inreg($1)!=reg_pointer
					call lolxxxstl("or.l")
pat lol xor stl $1==$3 && $2==4 && inreg($1)!=reg_pointer
					call lolxxxstl("eor.l")

proc lilxxsil example lil and sil
with conreg4-bconst
    kills allexceptcon
    gen xxx* %1, {indirect4, regvar($1, reg_pointer)}

pat lil adi sil $1==$3 && $2==4 &&inreg($1)==reg_pointer
					call lilxxsil("add.l")
pat lil adu sil $1==$3 && $2==4 &&inreg($1)==reg_pointer
					call lilxxsil("add.l")
pat lil ads sil $1==$3 && $2==4 &&inreg($1)==reg_pointer
					call lilxxsil("add.l")
pat lil and sil $1==$3 && $2==4 &&inreg($1)==reg_pointer
					call lilxxsil("and.l")
pat lil ior sil $1==$3 && $2==4 && inreg($1)==reg_pointer
					call lilxxsil("or.l")
pat lil xor sil $1==$3 && $2==4 &&inreg($1)==reg_pointer
					call lilxxsil("eor.l")

proc lilxxxsil example lil adi sil
with conreg4-bconst
    kills allexceptcon
#if TBL68020
    gen xxx* %1, {ILOCAL, $1}
#else
    uses AA_REG = {LOCAL, $1}
    gen xxx* %1, {indirect4, %a}
#endif

pat lil adi sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("add.l")
pat lil adu sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("add.l")
pat lil ads sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("add.l")
pat lil and sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("and.l")
pat lil ior sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("or.l")
pat lil xor sil $1==$3 && $2==4 && inreg($1)!=reg_any
					call lilxxxsil("eor.l")

proc loexxxste example loe adi ste
with conreg4-bconst
    kills posextern
    gen xxx* %1, {absolute4, $1}

pat loe adi ste $1==$3 && $2==4		call loexxxste("add.l")
pat loe adu ste $1==$3 && $2==4		call loexxxste("add.l")
pat loe ads ste $1==$3 && $2==4		call loexxxste("add.l")
pat loe and ste $1==$3 && $2==4		call loexxxste("and.l")
pat loe ior ste $1==$3 && $2==4		call loexxxste("or.l")
pat loe xor ste $1==$3 && $2==4		call loexxxste("eor.l")

proc lolfrxlolf example lol lof and lol stf
with conreg4-bconst
    kills allexceptcon
    gen xxx* %1, {offsetted4, regvar($1, reg_pointer), $2}

pat lol lof adi lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("add.l")
pat lol lof adu lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("add.l")
pat lol lof ads lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("add.l")
pat lol lof and lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("and.l")
pat lol lof ior lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("or.l")
pat lol lof xor lol stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lolfrxlolf("eor.l")

proc lolfxxlolf example lol lof and lol stf
with conreg4-bconst
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen xxx* %1, {OFF_off4, lb, $1, $2}
#else
    uses AA_REG={LOCAL, $1}
    gen xxx* %1, {offsetted4, %a, $2}
#endif

pat lol lof adi lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("add.l")
pat lol lof adu lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("add.l")
pat lol lof ads lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("add.l")
pat lol lof and lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("and.l")
pat lol lof ior lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("or.l")
pat lol lof xor lol stf $1==$4 && $2==$5 && $3==4
					call lolfxxlolf("eor.l")

proc lilfxxlilf example lil lof and lil stf
with conreg4-bconst
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen xxx* %1, {OFF_off4, regvar($1, reg_pointer), 0, $2}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen xxx* %1, {offsetted4, %a, $2}
#endif

pat lil lof adi lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil lof adu lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil lof ads lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil lof and lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("and.l")
pat lil lof ior lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("or.l")
pat lil lof xor lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("eor.l")

proc lefxxxsef example loe lof and loe stf
with conreg4-bconst
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen xxx* %1, {ABS_off4, $1, $2}
#else
    uses AA_REG={absolute4, $1}
    gen xxx* %1, {offsetted4, %a, $2}
#endif

pat loe lof adi loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("add.l")
pat loe lof adu loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("add.l")
pat loe lof ads loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("add.l")
pat loe lof and loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("and.l")
pat loe lof ior loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("or.l")
pat loe lof xor loe stf $1==$4 && $2==$5 && $3==4
					call lefxxxsef("eor.l")

proc lilixxlili example lil loi and lil sti
with conreg4-bconst
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen xxx* %1, {OFF_off4, regvar($1, reg_pointer), 0, 0}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen xxx* %1, {indirect4, %a}
#endif

pat lil loi adi lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil loi adu lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil loi ads lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("add.l")
pat lil loi and lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("and.l")
pat lil loi ior lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("or.l")
pat lil loi xor lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call lilfxxlilf("eor.l")

proc leixxxsei example loe loi and loe sti
with conreg4-bconst
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen xxx* %1, {ABS_off4, $1, 0}
#else
    uses AA_REG={absolute4, $1}
    gen xxx* %1, {indirect4, %a}
#endif

pat loe loi adi loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("add.l")
pat loe loi adu loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("add.l")
pat loe loi ads loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("add.l")
pat loe loi and loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("and.l")
pat loe loi ior loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("or.l")
pat loe loi xor loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leixxxsei("eor.l")

proc lofruxxsof example lol lof inc lol stf
    kills allexceptcon
    gen bit* {offsetted4, regvar($1, reg_pointer), $2}

pat lol lof inc lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
					call lofruxxsof("add.l #1,")
pat lol lof dec lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
					call lofruxxsof("sub.l #1,")
pat lol lof ngi lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer && $3==4
					call lofruxxsof("neg.l")
pat lol lof com lol stf $1==$4 && $2==$5 && inreg($1)==reg_pointer && $3==4
					call lofruxxsof("not.l")

proc lofuxxsof example lol lof inc lol stf
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen bit* {OFF_off4, lb, $1, $2}
#else
    uses AA_REG={LOCAL,$1}
    gen bit* {offsetted4,%a,$2}
#endif

pat lol lof inc lol stf $1==$4 && $2==$5
					call lofuxxsof("add.l #1,")
pat lol lof dec lol stf $1==$4 && $2==$5
					call lofuxxsof("sub.l #1,")
pat lol lof ngi lol stf $1==$4 && $2==$5 && $3==4
					call lofuxxsof("neg.l")
pat lol lof com lol stf $1==$4 && $2==$5 && $3==4
					call lofuxxsof("not.l")

proc lifuxxsif example lil lof inc lil stf
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen bit* {OFF_off4, regvar($1, reg_pointer), 0, $2}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen bit* {offsetted4,%a,$2}
#endif

pat lil lof inc lil stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
					call lifuxxsif("add.l #1,")
pat lil lof dec lil stf $1==$4 && $2==$5 && inreg($1)==reg_pointer
					call lifuxxsif("sub.l #1,")
pat lil lof ngi lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lifuxxsif("neg.l")
pat lil lof com lil stf $1==$4 && $2==$5 && $3==4 && inreg($1)==reg_pointer
					call lifuxxsif("not.l")

proc liiuxxsii example lil loi inc lil sti
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen bit* {OFF_off4, regvar($1, reg_pointer), 0, 0}
#else
    uses AA_REG={indirect4, regvar($1, reg_pointer)}
    gen bit* {indirect4, %a}
#endif

pat lil loi inc lil sti $1==$4 && $2==4 && $5==4 && inreg($1)==reg_pointer
					call liiuxxsii("add.l #1,")
pat lil loi dec lil sti $1==$4 && $2==4 && $5==4 && inreg($1)==reg_pointer
					call liiuxxsii("sub.l #1,")
pat lil loi ngi lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call liiuxxsii("neg.l")
pat lil loi com lil sti $1==$4 && $2==4 && $5==4 && $3==4 && inreg($1)==reg_pointer
					call liiuxxsii("not.l")

proc lefuxxsef example loe lof inc loe stf
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen bit* {ABS_off4, $1, $2}
#else
    uses AA_REG={absolute4, $1}
    gen bit* {offsetted4, %a, $2}
#endif

pat loe lof inc loe stf $1==$4 && $2==$5
					call lefuxxsef("add.l #1,")
pat loe lof dec loe stf $1==$4 && $2==$5
					call lefuxxsef("sub.l #1,")
pat loe lof ngi loe stf $1==$4 && $2==$5 && $3==4
					call lefuxxsef("neg.l")
pat loe lof com loe stf $1==$4 && $2==$5 && $3==4
					call lefuxxsef("not.l")

proc leiuxxsei example loe loi inc loe sti
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen bit* {ABS_off4, $1, 0}
#else
    uses AA_REG={absolute4, $1}
    gen bit* {indirect4, %a}
#endif

pat loe loi inc loe sti $1==$4 && $2==4 && $5==4
					call leiuxxsei("add.l #1,")
pat loe loi dec loe sti $1==$4 && $2==4 && $5==4
					call leiuxxsei("sub.l #1,")
pat loe loi ngi loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leiuxxsei("neg.l")
pat loe loi com loe sti $1==$4 && $2==4 && $5==4 && $3==4
					call leiuxxsei("not.l")

proc lolcxxstl example lol loc and stl
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen xxx* {const, $2}, {LOCAL, $1}

pat lol loc adi stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("add.l")
pat lol loc adu stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("add.l")
pat lol loc sbi stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("sub.l")
pat lol loc sbu stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("sub.l")
pat lol loc and stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("and.l")
pat lol loc ior stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("or.l")
pat lol loc xor stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("eor.l")
#ifdef TBL68020
pat lol loc dvi stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("divs.l")
pat lol loc dvu stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("divu.l")
pat lol loc mli stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("muls.l")
pat lol loc mlu stl $1==$4 && $3==4 && inreg($1)==reg_any
					call lolcxxstl("mulu.l")
#endif

proc lolcxxxstl example lol loc adi stl
    kills all_indir, LOCAL %bd==$1
    gen xxx* {const, $2}, {LOCAL, $1}

pat lol loc adi stl $1==$4 && $3==4	call lolcxxxstl("add.l")
pat lol loc adu stl $1==$4 && $3==4	call lolcxxxstl("add.l")
pat lol loc sbi stl $1==$4 && $3==4	call lolcxxxstl("sub.l")
pat lol loc sbu stl $1==$4 && $3==4	call lolcxxxstl("sub.l")
pat lol loc and stl $1==$4 && $3==4 && inreg($1)!=reg_pointer
					call lolcxxxstl("and.l")
pat lol loc ior stl $1==$4 && $3==4 && inreg($1)!=reg_pointer
					call lolcxxxstl("or.l")
pat lol loc xor stl $1==$4 && $3==4 && inreg($1)!=reg_pointer
					call lolcxxxstl("eor.l")

proc lilcxxsil example lil loc and sil
    kills allexceptcon
    gen xxx* {const, $2}, {indirect4, regvar($1, reg_pointer)}

pat lil loc adi sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("add.l")
pat lil loc adu sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("add.l")
pat lil loc sbi sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("sub.l")
pat lil loc sbu sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("sub.l")
pat lil loc and sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("and.l")
pat lil loc ior sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("or.l")
pat lil loc xor sil $1==$4 && $3==4 && inreg($1)==reg_pointer
					call lilcxxsil("eor.l")

proc lilcxxxsil example lil loc adi sil
    kills allexceptcon
#if TBL68020
    gen xxx* {const, $2}, {ILOCAL, $1}
#else
    uses AA_REG = {LOCAL, $1}
    gen xxx* {const, $2}, {indirect4, %a}
#endif

pat lil loc adi sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("add.l")
pat lil loc adu sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("add.l")
pat lil loc sbi sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("sub.l")
pat lil loc sbu sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("sub.l")
pat lil loc and sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("and.l")
pat lil loc ior sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("or.l")
pat lil loc xor sil $1==$4 && $3==4 && inreg($1)!=reg_any
					call lilcxxxsil("eor.l")

proc loecxxxste example loe loc adi ste
    kills posextern
    gen xxx* {const, $2}, {absolute4, $1}

pat loe loc adi ste $1==$4 && $3==4	call loecxxxste("add.l")
pat loe loc adu ste $1==$4 && $3==4	call loecxxxste("add.l")
pat loe loc sbi ste $1==$4 && $3==4	call loecxxxste("sub.l")
pat loe loc sbu ste $1==$4 && $3==4	call loecxxxste("sub.l")
pat loe loc and ste $1==$4 && $3==4	call loecxxxste("and.l")
pat loe loc ior ste $1==$4 && $3==4	call loecxxxste("or.l")
pat loe loc xor ste $1==$4 && $3==4	call loecxxxste("eor.l")

proc lolrxxstl example lol lol and stl
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen xxx* {LOCAL, $2}, {LOCAL, $1}

pat lol lol adi stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("add.l")
pat lol lol adu stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("add.l")
pat lol lol sbi stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("sub.l")
pat lol lol sbu stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("sub.l")
pat lol lol and stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("and.l")
pat lol lol ior stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("or.l")
pat lol lol xor stl $1==$4 && $3==4 && inreg($1)==reg_any && inreg($2)==reg_any
					call lolrxxstl("eor.l")

proc lolrxxxstl example lol lol adi stl
    kills all_indir, LOCAL %bd==$1
    gen xxx* {LOCAL, $2}, {LOCAL, $1}

pat lol lol adi stl $1==$4 && $3==4 && inreg($2)==reg_any
					call lolrxxxstl("add.l")
pat lol lol adu stl $1==$4 && $3==4 && inreg($2)==reg_any
					call lolrxxxstl("add.l")
pat lol lol ads stl $1==$4 && $3==4 && inreg($2)==reg_any
					call lolrxxxstl("add.l")
pat lol lol sbi stl $1==$4 && $3==4 && inreg($2)==reg_any
					call lolrxxxstl("sub.l")
pat lol lol sbu stl $1==$4 && $3==4 && inreg($2)==reg_any
					call lolrxxxstl("sub.l")
pat lol lol and stl $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_pointer
					call lolrxxxstl("and.l")
pat lol lol ior stl $1==$4 && $3==4 && inreg($2)==reg_any &&
			inreg($1)!=reg_pointer
					call lolrxxxstl("or.l")
pat lol lol xor stl $1==$4 && $3==4 && inreg($2)==reg_any &&
			inreg($1)!=reg_pointer
					call lolrxxxstl("eor.l")

proc lilrxxsil example lil lol and sil
    kills allexceptcon
    gen xxx* {LOCAL, $2}, {indirect4, regvar($1, reg_pointer)}

pat lil lol adi sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("add.l")
pat lil lol adu sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("add.l")
pat lil lol ads sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("add.l")
pat lil lol sbi sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("sub.l")
pat lil lol sbu sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("sub.l")
pat lil lol and sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("and.l")
pat lil lol ior sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("or.l")
pat lil lol xor sil $1==$4 && $3==4 && inreg($1)==reg_pointer &&
						inreg($2)==reg_any
					call lilrxxsil("eor.l")

proc lilrxxxsil example lil lol adi sil
    kills allexceptcon
#if TBL68020
    gen xxx* {LOCAL, $2}, {ILOCAL, $1}
#else
    uses AA_REG = {LOCAL, $1}
    gen xxx* {LOCAL, $2}, {indirect4, %a}
#endif

pat lil lol adi sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("add.l")
pat lil lol adu sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("add.l")
pat lil lol ads sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("add.l")
pat lil lol sbi sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("sub.l")
pat lil lol sbu sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("sub.l")
pat lil lol and sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("and.l")
pat lil lol ior sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("or.l")
pat lil lol xor sil $1==$4 && $3==4 && inreg($2)==reg_any && inreg($1)!=reg_any
					call lilrxxxsil("eor.l")

proc loerxxxste example loe lol adi ste
    kills posextern
    gen xxx* {LOCAL, $2}, {absolute4, $1}

pat loe lol adi ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("add.l")
pat loe lol adu ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("add.l")
pat loe lol ads ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("add.l")
pat loe lol sbi ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("sub.l")
pat loe lol sbu ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("sub.l")
pat loe lol and ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("and.l")
pat loe lol ior ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("or.l")
pat loe lol xor ste $1==$4 && $3==4 && inreg($2)==reg_any
					call loerxxxste("eor.l")

proc xxxstl example adi stl
with any4-RD_REG-dreg4 any-RD_REG-dreg4
    kills regvar($2, reg_any), use_index %xreg==regvar($2, reg_any)
    gen	move %2,{dreg4, regvar($2)}
	xxx* %1,{LOCAL,$2}
with exact any4-RD_REG-dreg4 STACK
    kills regvar($2, reg_any), use_index %xreg==regvar($2, reg_any)
    gen move_l {post_inc4, sp}, {dreg4, regvar($2)}
	xxx* %1,{LOCAL,$2}

pat adi stl $1==4 && inreg($2)==reg_any	call xxxstl("add.l")
pat adu stl $1==4 && inreg($2)==reg_any	call xxxstl("add.l")
pat sbi stl $1==4 && inreg($2)==reg_any	call xxxstl("sub.l")
pat sbu stl $1==4 && inreg($2)==reg_any	call xxxstl("sub.l")
pat and stl $1==4 && inreg($2)==reg_any	call xxxstl("and.l")
pat ior stl $1==4 && inreg($2)==reg_any	call xxxstl("or.l")
pat xor stl $1==4 && inreg($2)==reg_any	call xxxstl("eor.l")

pat ads stl $1==4 && inreg($2)==reg_pointer
with any4-areg-RA_REG any4+address-areg-RA_REG
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move %2,{areg,regvar($2,reg_pointer)}
	add_l %1,{areg,regvar($2,reg_pointer)}
#ifdef TBL68020
with regX any4+address-areg-RA_REG
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move %2,{areg,regvar($2,reg_pointer)}
	move {regAregXcon, regvar($2,reg_pointer), %1.xreg, %1.sc, 0},{areg,regvar($2,reg_pointer)}
with exact regX STACK
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move {post_inc4, sp},{areg,regvar($2,reg_pointer)}
	move {regAregXcon, regvar($2,reg_pointer), %1.xreg, %1.sc, 0},{areg,regvar($2,reg_pointer)}
with exact regX regAcon	
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move {regAregXcon, %2.reg, %1.xreg, %1.sc, %2.bd},{areg,regvar($2,reg_pointer)}
with exact regX local_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {regAregXcon, lb, %1.xreg, %1.sc, %2.bd},{areg,regvar($2,reg_pointer)}
#ifdef FANCY_MODES
with exact regX indirect4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, %2.reg, %1.xreg,%1.sc,0,0},{areg,regvar($2,reg_pointer)}
with exact regX offsetted4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, %2.reg, %1.xreg, %1.sc, %2.bd, 0},{areg,regvar($2,reg_pointer)}
with exact regX LOCAL
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, lb, %1.xreg, %1.sc, %2.bd, 0},{areg,regvar($2,reg_pointer)}
with exact regX off_con
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, %2.reg, %1.xreg,%1.sc,%2.bd,%2.od},{areg,regvar($2,reg_pointer)}
with exact regX ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move{ext_regX, %1.sc, %1.xreg, %2.bd},{areg,regvar($2,reg_pointer)}
with exact regX absolute4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {abs_regXcon, %1.sc, %1.xreg, %2.bd, 0},{areg,regvar($2,reg_pointer)}
with exact regX abs_con
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {abs_regXcon, %1.sc, %1.xreg, %2.bd, %2.od},{areg,regvar($2,reg_pointer)}
with exact indirect4 ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_con, %1.reg, 0, %2.bd},{areg,regvar($2,reg_pointer)}
with exact offsetted4 ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_con, %1.reg, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
with exact LOCAL ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_con, lb, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
with exact index_off4 ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {indoff_con, %1.reg, %1.xreg, %1.sc,%1.bd,%2.bd},{areg,regvar($2,reg_pointer)}
with exact absolute4 ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {abs_con, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
with exact abs_index4 ext_addr
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {absind_con, %1.sc, %1.xreg, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
with exact indirect4 ext_regX
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, %1.reg, %2.xreg, %2.sc, 0, %2.bd},{areg,regvar($2,reg_pointer)}
with exact offsetted4 ext_regX
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, %1.reg, %2.xreg,%2.sc,%1.bd,%2.bd},{areg,regvar($2,reg_pointer)}
with exact LOCAL ext_regX
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {off_regXcon, lb, %2.xreg, %2.sc, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
with exact absolute4 ext_regX
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move {abs_regXcon, %2.sc, %2.xreg, %1.bd, %2.bd},{areg,regvar($2,reg_pointer)}
#endif
#endif
	


proc xxxdupstl example adi dup stl
with any4-RD_REG-dreg4 any-RD_REG-dreg4
    kills regvar($3, reg_any), use_index %xreg==regvar($3, reg_any)
    gen	move %2,{dreg4, regvar($3)}
	xxx* %1,{LOCAL,$3}		yields {LOCAL, $3}
with exact any4-RD_REG-dreg4 STACK
    kills regvar($3, reg_any), use_index %xreg==regvar($3, reg_any)
    gen move_l {post_inc4, sp}, {dreg4, regvar($3)}
	xxx* %1,{LOCAL,$3}		yields {LOCAL, $3}

pat adi dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("add.l")
pat adu dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("add.l")
pat sbi dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("sub.l")
pat sbu dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("sub.l")
pat and dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("and.l")
pat ior dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("or.l")
pat xor dup stl $1==4 && $2==4 && inreg($3)==reg_any	call xxxdupstl("eor.l")

pat dup stl $1==4 && inreg($2)==reg_any
with any4
    kills regvar($2, reg_any), use_index %xreg==regvar($2, reg_any)
    gen move %1,{dreg4, regvar($2,reg_any)}
					yields {LOCAL, $2}

pat dup stl $1==4 && inreg($2)==reg_pointer
with any4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen move_l %1,{areg, regvar($2, reg_pointer)}
					yields {LOCAL, $2}

pat dup lol sti lol adp stl zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==1 && $5==1
    with any1
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_b %1,{post_inc1, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol sti lol adp stl zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==1 && $5==1
    with any1
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_b %1,{post_inc1, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat dup lol sti lol adp stl zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==2 && $5==2
    with any2
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_w %1,{post_inc2, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol sti lol adp stl zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==2 && $5==2
    with any2
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_w %1,{post_inc2, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat dup lol sti lol adp stl zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==4 && $5==4
    with any4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_l %1,{post_inc4, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol sti lol adp stl zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $2==$6 && $3==4 && $5==4
    with any4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_l %1,{post_inc4, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat dup lol adp stl lol sti zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==1 && $4==(0-1)
    with any1
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_b %1,{pre_dec1, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol adp stl lol sti zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==1 && $4==(0-1)
    with any1
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_b %1,{pre_dec1, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat dup lol adp stl lol sti zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==2 && $4==(0-2)
    with any2
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_w %1,{pre_dec2, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol adp stl lol sti zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==2 && $4==(0-2)
    with any2
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_w %1,{pre_dec2, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat dup lol adp stl lol sti zne $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==4 && $4==(0-4)
    with any4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_l %1,{pre_dec4, regvar($2,reg_pointer)}
	bne {llabel, $7}

pat dup lol adp stl lol sti zeq $1==4 && inreg($2)==reg_pointer &&
				$2==$4 && $4==$5 && $6==4 && $4==(0-4)
    with any4
    kills regvar($2, reg_pointer), all_regind %reg==regvar($2, reg_pointer)
    gen	move_l %1,{pre_dec4, regvar($2,reg_pointer)}
	beq {llabel, $7}

pat lol ads stl $1==$3 && $2==4 && inreg($1)==reg_pointer
    with data4-sconsts
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen add_l %1, {LOCAL, $1}

pat lil lil inc sil $1==$2 && $1==$4 && inreg($1)==reg_pointer
    kills allexceptcon
    uses DD_REG = {indirect4, regvar($1, reg_pointer)}
    gen add_l {const, 1}, {indirect4, regvar($1, reg_pointer)}
    killreg %a
			yields	%a

pat lil lil dec sil $1==$2 && $1==$4 && inreg($1)==reg_pointer
    kills allexceptcon
    uses DD_REG = {indirect4, regvar($1, reg_pointer)}
    gen sub_l {const, 1}, {indirect4, regvar($1, reg_pointer)}
    killreg %a
			yields	%a

pat lol lof dup adp lol stf sti $3==4 && $1==$5 && $2==$6 && inreg($1)==reg_pointer && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {offsetted4, regvar($1, reg_pointer), $2}
    gen add_l {const, $4}, {offsetted4, regvar($1, reg_pointer), $2}
    killreg %a
			yields	%1 %a		leaving sti $7

pat lol lof dup adp lol stf $3==4 && $1==$5 && $2==$6 && inreg($1)==reg_pointer
    kills allexceptcon
    uses AA_REG = {offsetted4, regvar($1, reg_pointer), $2}
    gen add_l {const, $4}, {offsetted4, regvar($1, reg_pointer), $2}
    killreg %a
			yields	%a

pat lol lof dup adp lol stf sti $3==4 && $1==$5 && $2==$6 && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%1 %b		leaving sti $7

pat lol lof dup adp lol stf $3==4 && $1==$5 && $2==$6
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%b

pat loe lof dup adp loe stf sti $3==4 && $1==$5 && $2==$6 && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {absolute4, $1}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%1 %b		leaving sti $7

pat loe lof dup adp loe stf $3==4 && $1==$5 && $2==$6
    kills allexceptcon
    uses AA_REG = {absolute4, $1}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%b

pat lil lof dup adp lil stf sti $3==4 && $1==$5 && $2==$6 && inreg($1)==reg_pointer && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%1 %b		leaving sti $7

pat lil lof dup adp lil stf $3==4 && $1==$5 && $2==$6 && inreg($1)==reg_pointer
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}, AA_REG
    gen move_l {offsetted4, %a, $2}, %b
	add_l {const, $4}, {offsetted4, %a, $2}
			yields	%b

pat loe loi dup adp loe sti sti $3==4 && $1==$5 && $2==4 && $6==4 && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {absolute4, $1}, AA_REG
    gen move_l {indirect4, %a}, %b
	add_l {const, $4}, {indirect4, %a}
			yields	%1 %b		leaving sti $7

pat loe loi dup adp loe sti $3==4 && $1==$5 && $2==4 && $6==4
    kills allexceptcon
    uses AA_REG = {absolute4, $1}, AA_REG
    gen move_l {indirect4, %a}, %b
	add_l {const, $4}, {indirect4, %a}
			yields	%b

pat lil loi dup adp lil sti sti $3==4 && $1==$5 && $2==4 && $6==4 && $7 <= 4
    with conreg
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}, AA_REG
    gen move_l {indirect4, %a}, %b
	add_l {const, $4}, {indirect4, %a}
			yields	%1 %b		leaving sti $7

pat lil loi dup adp lil sti $3==4 && $1==$5 && $2==4 && $6==4
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}, AA_REG
    gen move_l {indirect4, %a}, %b
	add_l {const, $4}, {indirect4, %a}
			yields	%b

pat lol lol adp stl lae cmp $1==$2 && $2==$4 && inreg($1)==reg_pointer && $3 < 0
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen	sub_l {const,0-$3},{LOCAL,$1}
			yields {LOCAL,$1} {ext_addr, $5+$3}
					leaving cmu 4

pat lol lol adp stl lae cmp $1==$2 && $2==$4 && inreg($1)==reg_pointer && $3 > 0
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen	add_l {const,$3},{LOCAL,$1}
			yields {LOCAL,$1} {ext_addr, $5+$3}
					leaving cmu 4

pat lol lol adp stl loi $1==$2 && $1==$4 && $3==4 && $5==4 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{post_inc4, regvar($1, reg_pointer)}

pat lol lol adp stl loi $1==$2 && $1==$4 && $3==$5 && inreg($1)==reg_pointer
				leaving lol $1 loi $5 lol $2 adp $3 stl $4

pat lol loi lol adp stl $1==$3 && $1==$5 && $2==1 && $4==1 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{post_inc1, regvar($1, reg_pointer)}

pat lol loi lol adp stl $1==$3 && $1==$5 && $2==2 && $4==2 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{post_inc2, regvar($1, reg_pointer)}

pat lil lol adp stl $1==$2 && $1==$4 && $3==4 && inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{post_inc4, regvar($1, reg_pointer)}

pat lol lol adp stl sti $1==$2 && $1==$4 && $3==$5 && inreg($1)==reg_pointer
				leaving lol $1 sti $5 lol $2 adp $3 stl $4

pat lol sti lol adp stl $1==$3 && $1==$5 && $2==1 && $4==1 &&
						inreg($1)==reg_pointer
with any1
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_b %1, {post_inc1, regvar($1, reg_pointer)}

pat lol sti lol adp stl $1==$3 && $1==$5 && $2==2 && $4==2 &&
						inreg($1)==reg_pointer
with any2
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_w %1, {post_inc2, regvar($1, reg_pointer)}

pat lol lol adp stl sti $1==$2 && $1==$4 && $3==4 && $5==4 &&
						inreg($1)==reg_pointer
with any4-sconsts
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_l %1, {post_inc4, regvar($1, reg_pointer)}

pat sil lol adp stl $1==$2 && $1==$4 && $3==4 && inreg($1)==reg_pointer
with any4-sconsts
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_l %1, {post_inc4, regvar($1, reg_pointer)}

pat lol adp stl lol loi $1==$3 && $1==$4 && $2==0-1 && $5==1 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{pre_dec1, regvar($1, reg_pointer)}

pat lol adp stl lol loi $1==$3 && $1==$4 && $2==0-2 && $5==2 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{pre_dec2, regvar($1, reg_pointer)}

pat lol adp stl lil $1==$3 && $1==$4 && $2==0-4 &&
						inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
			yields	{pre_dec4, regvar($1, reg_pointer)}

pat lol adp stl lol sti $1==$3 && $1==$4 && $2==0-1 && $5==1 &&
						inreg($1)==reg_pointer
with any1
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_b %1, {pre_dec1, regvar($1, reg_pointer)}

pat lol adp stl lol sti $1==$3 && $1==$4 && $2==0-2 && $5==2 &&
						inreg($1)==reg_pointer
with any2
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_w %1, {pre_dec2, regvar($1, reg_pointer)}

pat lol adp stl sil $1==$3 && $1==$4 && $2==0-4 &&
						inreg($1)==reg_pointer
with any4-sconsts
    kills allexceptcon, regvar($1, reg_pointer)
    gen move_l %1, {pre_dec4, regvar($1, reg_pointer)}

pat lol lol adp stl $1==$2 && $1==$4 && inreg($1)==reg_pointer && abs_small($3)
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    uses AA_REG = {LOCAL, $1}
    gen add_l {const, $3}, {LOCAL, $1}
    killreg %a
			yields	%a

pat lol lol adp stl $1==$2 && $1==$4 && inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    uses AA_REG = {LOCAL, $1}, DD_REG = {const, $3}
    gen add_l %b, {LOCAL, $1}
    killreg %a
			yields	%a

pat lol lol adp stl $1==$2 && $1==$4 && abs_small($3)
    kills all_indir, LOCAL %bd==$1
    uses AA_REG = {LOCAL, $1}, DD_REG = {const, $3}
    gen add_l %b, {LOCAL, $1}
    killreg %a
			yields	%a

pat lol lol adp stl $1==$2 && $1==$4
    kills all_indir, LOCAL %bd==$1
    uses AA_REG = {LOCAL, $1}
    gen add_l {const, $3}, {LOCAL, $1}
    killreg %a
			yields	%a

pat lol adp stl $1==$3 && inreg($1)==reg_pointer && abs_small($2)
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen add_l {const, $2}, {LOCAL, $1}

pat lol adp stl $1==$3 && inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    uses DD_REG = {const, $2}
    gen add_l %a, {LOCAL, $1}

pat lol adp stl $1==$3 && abs_small($2)
    kills all_indir, LOCAL %bd==$1
    uses DD_REG = {const, $2}
    gen add_l %a, {LOCAL, $1}

pat lol adp stl $1==$3
    kills all_indir, LOCAL %bd==$1
    gen add_l {const, $2}, {LOCAL, $1}

pat lil lil adp sil sti $1==$2 && $1==$4 && inreg($1)==reg_pointer && $5<=4
    with conreg
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}
    gen add_l {const, $3}, {indirect4, regvar($1, reg_pointer)}
    killreg %a
			yields	%1 %a

pat lil lil adp sil $1==$2 && $1==$4 && inreg($1)==reg_pointer
    kills allexceptcon
    uses AA_REG = {indirect4, regvar($1, reg_pointer)}
    gen add_l {const, $3}, {indirect4, regvar($1, reg_pointer)}
    killreg %a
			yields	%a

pat lil lil adp sil $1==$2 && $1==$4
    kills allexceptcon
    uses AA_REG, AA_REG = {LOCAL, $1}
    gen move {indirect4, %b}, %a
	add_l {const, $3}, {indirect4, %b}
	killreg %a
			yields	%a

pat lil adp sil $1==$3 && inreg($1)==reg_pointer
    kills allexceptcon
    gen add_l {const, $2}, {indirect4, regvar($1, reg_pointer)}

pat lil adp sil $1==$3 && inreg($1)!=reg_any
    kills allexceptcon
#if TBL68020
    gen add_l {const, $2}, {ILOCAL,$1}
#else
    uses AA_REG = {LOCAL, $1}
    gen add_l {const, $2}, {indirect4, %a}
#endif

pat loe loe adp ste $1==$2 && $1==$4
    kills posextern
    uses AA_REG = {absolute4, $1}
    gen add_l {const, $3}, {absolute4, $1}
    killreg %a
			yields	%a

pat loe adp ste $1==$3
    kills posextern
    gen add_l {const, $2}, {absolute4, $1}

pat loc and $1==255 && $2==4
    with exact absolute4	yields {absolute1,%1.bd+3}
    with exact offsetted4	yields {offsetted1,%1.reg,%1.bd+3}
    with exact LOCAL		yields {offsetted1,lb,%1.bd+3}
    with			yields {const, $1}		leaving and 4
			
/************************************************
 * Group 1: load instructions			*
 ************************************************/

pat loc $1==0		yields	{zero_const, $1}

pat loc small($1)	yields	{small_const, $1}

pat loc in_1($1)	yields	{bconst, $1}

pat loc			yields	{const, $1}

pat ldc				leaving loc 18 trp

pat lol inreg($1)==reg_pointer
    kills pre_post %reg==regvar($1, reg_pointer)
			yields	{LOCAL, $1}

pat lol			yields	{LOCAL, $1}

pat ldl				leaving lol $1+4 lol $1

pat loe			yields	{absolute4, $1}

pat loe loe $1==$2		leaving loe $1 dup 4

/* replace ste loe by dup ste, but not if followed by a test ... */
proc steloezxx example ste loe zne
with any4-sconsts
    kills posextern
    gen move %1, {absolute4, $1}
	bxx* {llabel, $3}
with exact STACK
    kills posextern
    gen move_l {post_inc4, sp}, {absolute4, $1}
	bxx* {llabel, $3}

pat ste loe zlt $1==$2			call steloezxx("blt")
pat ste loe zle	$1==$2			call steloezxx("ble")
pat ste loe zeq	$1==$2			call steloezxx("beq")
pat ste loe zne	$1==$2			call steloezxx("bne")
pat ste loe zge	$1==$2			call steloezxx("bge")
pat ste loe zgt	$1==$2			call steloezxx("bgt")

pat ste loe $1==$2		leaving dup 4 ste $1

pat lil inreg($1)==reg_pointer
    kills pre_post %reg==regvar($1, reg_pointer)
			yields	{indirect4, regvar($1, reg_pointer)}
pat lil inreg($1)==reg_any
    uses AA_REG = { LOCAL, $1}
			yields  {indirect4, %a}

pat lil
#if TBL68020
			yields	{ILOCAL, $1}
#else
    uses AA_REG = {LOCAL, $1}
			yields	{indirect4, %a}
#endif

	/* When using the 'offsetted' intructions regAregXcon cannot be used
	 * for the m68k4; there is no way of knowing about the size of
	 * %1.bd+$1, because expressions are not allowed in stack patterns, and
	 * this may lead to outputting too large displacements. With regAcon
	 * the chance that this will happen is very slim, because it can 
	 * have displacements of 16 bits. Besides, leaving out regAcon here
	 * would make it very hard to handle this instruction efficiently.
	 */
pat lof
with A_REG		yields	{offsetted4, %1, $1}
with exact local_addr	yields	{LOCAL, %1.bd+$1}
with exact ext_addr	yields	{absolute4, %1.bd+$1}
#ifndef TBL68020
with regAcon		yields	{offsetted4, %1.reg, %1.bd+$1}
#else TBL68020
with exact regAcon	yields	{offsetted4, %1.reg, %1.bd+$1}
with exact regAregXcon	yields	{index_off4, %1.reg, %1.xreg, %1.sc, %1.bd+$1}
#ifdef FANCY_MODES
with exact offsetted4	yields	{OFF_off4, %1.reg, %1.bd, $1}
with exact indirect	yields	{OFF_off4, %1.reg, 0, $1}
with exact LOCAL	yields	{OFF_off4, lb, %1.bd, $1}
with exact off_con	yields	{OFF_off4, %1.reg, %1.bd, %1.od+$1}
with exact index_off4	yields	{INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, $1}
with exact indoff_con	yields	{INDOFF_off4,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact off_regXcon	yields	{OFF_indoff4,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact absolute4	yields	{ABS_off4, %1.bd, $1}
with exact abs_con	yields	{ABS_off4, %1.bd, %1.od+$1}
with exact abs_regXcon	yields	{ABS_indoff4, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact abs_index4	yields	{ABSIND_off4, %1.sc, %1.xreg, %1.bd, $1}
with exact absind_con	yields	{ABSIND_off4, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact ext_regX	yields	{abs_index4, %1.sc, %1.xreg, %1.bd+$1}
#endif
#endif TBL68020

pat lal			yields	{local_addr, $1}

pat lae			yields	{ext_addr, $1}

pat lxl $1==0		yields	lb

pat lxl $1==1		yields	{LOCAL, SL}

pat lxl $1==2
#if TBL68020 && FANCY_MODES
			yields	{OFF_off4, lb, SL, SL}
#else
    uses AA_REG = {LOCAL, SL}
			yields	{offsetted4, %a, SL}
#endif

pat lxl $1==3
#if TBL68020 && FANCY_MODES
    uses AA_REG = {OFF_off4, lb, SL, SL}
#else
    uses AA_REG = {LOCAL, SL}
    gen move_l {offsetted4, %a, SL}, %a
#endif
			yields	{offsetted4, %a, SL}

pat lxl $1>3
    uses AA_REG = {LOCAL, SL},
	 DD_REG = {const, $1-2}
    gen 1: 
        move_l {offsetted4, %a, SL} ,%a
	dbf %b, {slabel, 1b}
			yields	%a

pat lxa $1==0		yields	{local_addr, SL}

pat lxa $1==1
#if TBL68020 && FANCY_MODES
			yields	{off_con, lb, SL, SL}
#else
    uses AA_REG = {LOCAL, SL}
			yields	{regAcon, %a, SL}
#endif

pat  lxa $1==2
#if TBL68020 && FANCY_MODES
    uses AA_REG = {OFF_off4, lb, SL, SL}
#else
    uses AA_REG = {LOCAL, SL}
    gen move_l {offsetted4, %a, SL}, %a
#endif
			yields	{regAcon, %a, SL}

pat lxa $1>2
    uses AA_REG = {LOCAL, SL},
	 DD_REG = {const, $1-2}
    gen 1: 
        move_l {offsetted4, %a, SL} ,%a
	dbf %b, {slabel, 1b}
			yields	{regAcon, %a, SL}

pat loi $1==1
with A_REG		yields	{indirect1, %1}
with exact local_addr	yields	{offsetted1, lb, %1.bd}
with exact ext_addr	yields	{absolute1, %1.bd}
#ifndef TBL68020
with regAcon		yields	{offsetted1, %1.reg, %1.bd}
with regAregXcon	yields	{index_off1, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon	yields	{offsetted1, %1.reg, %1.bd}
with exact regAregXcon	yields	{index_off1, %1.reg, %1.xreg, %1.sc, %1.bd}
#ifdef FANCY_MODES
with exact indirect4	yields	{OFF_off1, %1.reg, 0, 0}
with exact offsetted4	yields	{OFF_off1, %1.reg, %1.bd, 0}
with exact LOCAL	yields	{OFF_off1, lb, %1.bd, 0}
with exact off_con	yields	{OFF_off1, %1.reg, %1.bd, %1.od}
with exact index_off4	yields	{INDOFF_off1, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con	yields	{INDOFF_off1,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon	yields	{OFF_indoff1,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4	yields	{ABS_off1, %1.bd, 0}
with exact abs_con	yields	{ABS_off1, %1.bd, %1.od}
with exact abs_regXcon	yields	{ABS_indoff1, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4	yields	{ABSIND_off1, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con	yields	{ABSIND_off1, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX	yields	{abs_index1, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat loi $1==2
with A_REG		yields	{indirect2, %1}
with exact local_addr	yields	{offsetted2, lb, %1.bd}
with exact ext_addr	yields	{absolute2, %1.bd}
#ifndef TBL68020
with regAcon		yields	{offsetted2, %1.reg, %1.bd}
with regAregXcon	yields	{index_off2, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon	yields	{offsetted2, %1.reg, %1.bd}
with exact regAregXcon	yields	{index_off2, %1.reg, %1.xreg, %1.sc, %1.bd}
#ifdef FANCY_MODES
with exact indirect4	yields	{OFF_off2, %1.reg, 0, 0}
with exact offsetted4	yields	{OFF_off2, %1.reg, %1.bd, 0}
with exact LOCAL	yields	{OFF_off2, lb, %1.bd, 0}
with exact off_con	yields	{OFF_off2, %1.reg, %1.bd, %1.od}
with exact index_off4	yields	{INDOFF_off2, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con	yields	{INDOFF_off2,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon	yields	{OFF_indoff2,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4	yields	{ABS_off2, %1.bd, 0}
with exact abs_con	yields	{ABS_off2, %1.bd, %1.od}
with exact abs_regXcon	yields	{ABS_indoff2, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4	yields	{ABSIND_off2, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con	yields	{ABSIND_off2, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX	yields	{abs_index2, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat loi $1==4
with A_REG		yields	{indirect4, %1}
with exact local_addr	yields	{LOCAL, %1.bd}
with exact ext_addr	yields	{absolute4, %1.bd}
#ifndef TBL68020
with regAcon		yields	{offsetted4, %1.reg, %1.bd}
with regAregXcon	yields	{index_off4, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon	yields	{offsetted4, %1.reg, %1.bd}
with exact regAregXcon	yields	{index_off4, %1.reg, %1.xreg, %1.sc, %1.bd}
with exact LOCAL	yields	{ILOCAL, %1.bd}
#ifdef FANCY_MODES
with exact indirect4	yields	{OFF_off4, %1.reg, 0, 0}
with exact offsetted4	yields	{OFF_off4, %1.reg, %1.bd, 0}
with exact off_con	yields	{OFF_off4, %1.reg, %1.bd, %1.od}
with exact index_off4	yields	{INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con	yields	{INDOFF_off4,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon	yields	{OFF_indoff4,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4	yields	{ABS_off4, %1.bd, 0}
with exact abs_con	yields	{ABS_off4, %1.bd, %1.od}
with exact abs_regXcon	yields	{ABS_indoff4, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4	yields	{ABSIND_off4, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con	yields	{ABSIND_off4, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX	yields	{abs_index4, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat loi $1==8			leaving ldf 0

pat loi $1==12
with AA_REG STACK
    kills ALL
    uses DD_REG={const,$1}
    gen add_l %a, %1
	move_l {pre_dec4, %1},{pre_dec4, sp}
	move_l {pre_dec4, %1},{pre_dec4, sp}
	move_l {pre_dec4, %1},{pre_dec4, sp}

pat loi $1==16
with AA_REG STACK
    kills ALL
    uses DD_REG={const,$1}
    gen add_l %a, %1
	move_l {pre_dec4, %1},{pre_dec4, sp}
	move_l {pre_dec4, %1},{pre_dec4, sp}
	move_l {pre_dec4, %1},{pre_dec4, sp}
	move_l {pre_dec4, %1},{pre_dec4, sp}

pat loi $1>16
with AA_REG STACK
    kills ALL
    uses DD_REG = {const, $1/4 -1}
    gen add_l {const, $1}, %1
	1:
	move_l {pre_dec4, %1}, {pre_dec4, sp}
	dbf %a, {slabel, 1b}

pat los $1==4
with STACK
    kills ALL
    gen jsr {absolute4, ".los"}

pat lde			yields	{absolute4, $1+4}
				{absolute4, $1}

pat ldf
with A_REG		yields	{offsetted4, %1, $1+4}
				{offsetted4, %1, $1}
with exact local_addr	yields	{LOCAL, %1.bd+$1+4}
				{LOCAL, %1.bd+$1}
with regAcon		yields	{offsetted4, %1.reg, %1.bd+$1+4}
				{offsetted4, %1.reg, %1.bd+$1}

pat lpi			yields	{ext_addr, $1}



/************************************************
 * Group 2: store instructions			*
 ************************************************/

pat stl inreg($1)==reg_any
with exact memory1-consts
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen	clr_l {LOCAL, $1}
	move_b %1, {dreg1, regvar($1,reg_any)}
with exact memory2-consts
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen	clr_l {LOCAL, $1}
	move_w %1, {dreg2, regvar($1,reg_any)}
with store4
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen move %1, {LOCAL, $1}
with exact STACK
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen move_l {post_inc4, sp}, {LOCAL, $1}

pat stl inreg($1)==reg_pointer
with any4-sconsts
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen move_l %1, {areg, regvar($1, reg_pointer)}
with exact ext_addr
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen move_l %1, {areg, regvar($1, reg_pointer)}
with exact address-ext_addr
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen lea %1, {areg, regvar($1, reg_pointer)}
with exact STACK
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen move_l {post_inc4, sp}, {areg, regvar($1, reg_pointer)}

pat stl
with store4-sconsts
    kills all_indir, LOCAL %bd==$1
    gen move %1, {LOCAL, $1}
with exact STACK
    kills all_indir, LOCAL %bd==$1
    gen move_l {post_inc4,sp}, {LOCAL, $1}

pat ste
with store4-sconsts
    kills posextern
    gen move %1, {absolute4, $1}
with exact STACK
    kills posextern
    gen move_l {post_inc4, sp}, {absolute4, $1}

pat sil inreg($1)==reg_pointer
with store4-sconsts
    kills allexceptcon
    gen move %1, {indirect4, regvar($1, reg_pointer)}
with exact STACK
    kills allexceptcon
    gen move_l {post_inc4, sp}, {indirect4, regvar($1, reg_pointer)}

pat sil inreg($1)==reg_any
with store4-sconsts
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}
    gen move %1, {indirect4, %a}
with exact STACK
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}
    gen move_l {post_inc4, sp}, {indirect4, %a}

pat sil
#if TBL68020
with store4-sconsts
    kills allexceptcon
    gen move %1, {ILOCAL, $1}
with exact STACK
    kills allexceptcon
    gen move_l {post_inc4, sp}, {ILOCAL, $1}
#else
with store4-sconsts
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}
    gen move %1, {indirect4, %a}
with exact STACK
    kills allexceptcon
    uses AA_REG = {LOCAL, $1}
    gen move_l {post_inc4, sp}, {indirect4, %a}
#endif

pat stf
with A_REG store4-sconsts
    kills allexceptcon
    gen move %2, {offsetted4, %1, $1}
with exact any4 STACK
    kills allexceptcon
    uses AA_REG = %1
    gen move_l {post_inc4, sp}, {offsetted4, %a, $1}
with exact STACK
    kills allexceptcon
    uses AA_REG
    gen move_l {post_inc4, sp}, %a
	move_l {post_inc4, sp}, {offsetted4, %a, $1}
with exact local_addr store4
    kills allexceptcon
    gen move %2, {LOCAL, %1.bd+$1}
with exact ext_addr store4
    kills allexceptcon
    gen move %2, {absolute4, %1.bd+$1}
#ifndef TBL68020
with regAcon store4
    kills allexceptcon
    gen move %2, {offsetted4, %1.reg, %1.bd+$1}
#else TBL68020
with exact regAcon store4
    kills allexceptcon
    gen move %2, {offsetted4, %1.reg, %1.bd+$1}
with exact regAregXcon store4
    kills allexceptcon
    gen move %2, {index_off4, %1.reg, %1.xreg, %1.sc, %1.bd+$1}
#ifdef FANCY_MODES
with exact indirect4 store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, 0, $1}
with exact offsetted4 store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, %1.bd, $1}
with exact LOCAL store4
    kills allexceptcon
    gen move %2, {OFF_off4, lb, %1.bd, $1}
with exact off_con store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, %1.bd, %1.od+$1}
with exact index_off4 store4
    kills allexceptcon
    gen move %2, {INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, $1}
with exact indoff_con store4
    kills allexceptcon
    gen move %2, {INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact off_regXcon store4
    kills allexceptcon
    gen move %2, {OFF_indoff4, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact absolute4 store4
    kills allexceptcon
    gen move %2, {ABS_off4, %1.bd, $1}
with exact abs_con store4
    kills allexceptcon
    gen move %2, {ABS_off4, %1.bd, %1.od+$1}
with exact abs_regXcon store4
    kills allexceptcon
    gen move %2, {ABS_indoff4, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact abs_index4 store4
    kills allexceptcon
    gen move %2, {ABSIND_off4, %1.sc, %1.xreg, %1.bd, $1}
with exact absind_con store4
    kills allexceptcon
    gen move %2, {ABSIND_off4, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact ext_regX store4
    kills allexceptcon
    gen move %2, {abs_index4, %1.sc, %1.xreg, %1.bd+$1}
#endif
#endif TBL68020

pat sti $1==1
with A_REG any1
    kills allexceptcon
    gen move %2, {indirect1, %1}
with local_addr any1
    kills allexceptcon
    gen move %2, {offsetted1, lb, %1.bd}
with exact ext_addr any1
    kills allexceptcon
    gen move %2, {absolute1, %1.bd}
#ifndef TBL68020
with regAcon any1
    kills allexceptcon
    gen move %2, {offsetted1, %1.reg, %1.bd}
with regAregXcon any1
    kills allexceptcon
    gen move %2, {index_off1, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon any1
    kills allexceptcon
    gen move %2, {offsetted1, %1.reg, %1.bd}
with exact regAregXcon any1
    kills allexceptcon
    gen move %2, {index_off1, %1.reg, %1.xreg, %1.sc, %1.bd}
#ifdef FANCY_MODES
with exact indirect4 any1
    kills allexceptcon
    gen move %2, {OFF_off1, %1.reg, 0, 0}
with exact offsetted4 any1
    kills allexceptcon
    gen move %2, {OFF_off1, %1.reg, %1.bd, 0}
with exact LOCAL any1
    kills allexceptcon
    gen move %2, {OFF_off1, lb, %1.bd, 0}
with exact off_con any1
    kills allexceptcon
    gen move %2, {OFF_off1, %1.reg, %1.bd, %1.od}
with exact index_off4 any1
    kills allexceptcon
    gen move %2, {INDOFF_off1, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con any1
    kills allexceptcon
    gen move %2, {INDOFF_off1, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon any1
    kills allexceptcon
    gen move %2, {OFF_indoff1, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4 any1
    kills allexceptcon
    gen move %2, {ABS_off1, %1.bd, 0}
with exact abs_con any1
    kills allexceptcon
    gen move %2, {ABS_off1, %1.bd, %1.od}
with exact abs_regXcon any1
    kills allexceptcon
    gen move %2, {ABS_indoff1, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4 any1
    kills allexceptcon
    gen move %2, {ABSIND_off1, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con any1
    kills allexceptcon
    gen move %2, {ABSIND_off1, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX any1
    kills allexceptcon
    gen move %2, {abs_index1, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat sti $1==2
with A_REG any2
    kills allexceptcon
    gen move %2, {indirect2, %1}
with local_addr any2
    kills allexceptcon
    gen move %2, {offsetted2, lb, %1.bd}
with exact ext_addr any2
    kills allexceptcon
    gen move %2, {absolute2, %1.bd}
#ifndef TBL68020
with regAcon any2
    kills allexceptcon
    gen move %2, {offsetted2, %1.reg, %1.bd}
with regAregXcon any2
    kills allexceptcon
    gen move %2, {index_off2, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon any2
    kills allexceptcon
    gen move %2, {offsetted2, %1.reg, %1.bd}
with exact regAregXcon any2
    kills allexceptcon
    gen move %2, {index_off2, %1.reg, %1.xreg, %1.sc, %1.bd}
#ifdef FANCY_MODES
with exact indirect4 any2
    kills allexceptcon
    gen move %2, {OFF_off2, %1.reg, 0, 0}
with exact offsetted4 any2
    kills allexceptcon
    gen move %2, {OFF_off2, %1.reg, %1.bd, 0}
with exact LOCAL any2
    kills allexceptcon
    gen move %2, {OFF_off2, lb, %1.bd, 0}
with exact off_con any2
    kills allexceptcon
    gen move %2, {OFF_off2, %1.reg, %1.bd, %1.od}
with exact index_off4 any2
    kills allexceptcon
    gen move %2, {INDOFF_off2, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con any2
    kills allexceptcon
    gen move %2, {INDOFF_off2, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon any2
    kills allexceptcon
    gen move %2, {OFF_indoff2, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4 any2
    kills allexceptcon
    gen move %2, {ABS_off2, %1.bd, 0}
with exact abs_con any2
    kills allexceptcon
    gen move %2, {ABS_off2, %1.bd, %1.od}
with exact abs_regXcon any2
    kills allexceptcon
    gen move %2, {ABS_indoff2, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4 any2
    kills allexceptcon
    gen move %2, {ABSIND_off2, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con any2
    kills allexceptcon
    gen move %2, {ABSIND_off2, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX any2
    kills allexceptcon
    gen move %2, {abs_index2, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat sti $1==4
with A_REG store4-sconsts
    kills allexceptcon
    gen move %2, {indirect4, %1}
with exact any4 STACK
    kills allexceptcon
    uses AA_REG = %1
    gen move_l {post_inc4, sp}, {indirect4, %a}
with exact STACK
    kills allexceptcon
    uses AA_REG
    gen move_l {post_inc4, sp}, %a
	move_l {post_inc4, sp}, {indirect4, %a}
with exact local_addr store4
    kills allexceptcon
    gen move %2, {LOCAL, %1.bd}
with exact ext_addr store4
    kills allexceptcon
    gen move %2, {absolute4, %1.bd}
#ifndef TBL68020
with regAcon store4-sconsts
    kills allexceptcon
    gen move %2, {offsetted4, %1.reg, %1.bd}
with regAregXcon store4-sconsts
    kills allexceptcon
    gen move %2, {index_off4, %1.reg, %1.xreg, %1.sc, %1.bd}
#else TBL68020
with exact regAcon store4
    kills allexceptcon
    gen move %2, {offsetted4, %1.reg, %1.bd}
with exact regAregXcon store4
    kills allexceptcon
    gen move %2, {index_off4, %1.reg, %1.xreg, %1.sc, %1.bd}
with exact LOCAL store4
    kills allexceptcon
    gen move %2, {ILOCAL, %1.bd}
#ifdef FANCY_MODES
with exact indirect4 store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, 0, 0}
with exact offsetted4 store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, %1.bd, 0}
with exact off_con store4
    kills allexceptcon
    gen move %2, {OFF_off4, %1.reg, %1.bd, %1.od}
with exact index_off4 store4
    kills allexceptcon
    gen move %2, {INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, 0}
with exact indoff_con store4
    kills allexceptcon
    gen move %2, {INDOFF_off4, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact off_regXcon store4
    kills allexceptcon
    gen move %2, {OFF_indoff4, %1.reg, %1.xreg, %1.sc, %1.bd, %1.od}
with exact absolute4 store4
    kills allexceptcon
    gen move %2, {ABS_off4, %1.bd, 0}
with exact abs_con store4
    kills allexceptcon
    gen move %2, {ABS_off4, %1.bd, %1.od}
with exact abs_regXcon store4
    kills allexceptcon
    gen move %2, {ABS_indoff4, %1.sc, %1.xreg, %1.bd, %1.od}
with exact abs_index4 store4
    kills allexceptcon
    gen move %2, {ABSIND_off4, %1.sc, %1.xreg, %1.bd, 0}
with exact absind_con store4
    kills allexceptcon
    gen move %2, {ABSIND_off4, %1.sc, %1.xreg, %1.bd, %1.od}
with exact ext_regX store4
    kills allexceptcon
    gen move %2, {abs_index4, %1.sc, %1.xreg, %1.bd}
#endif
#endif TBL68020

pat sti $1==8		leaving sdf 0

pat sti $1==12
    with AA_REG STACK
    kills ALL
    gen	move_l {post_inc4, sp},{post_inc4,%1}
    	move_l {post_inc4, sp},{post_inc4,%1}
    	move_l {post_inc4, sp},{post_inc4,%1}

pat sti $1==16
    with AA_REG STACK
    kills ALL
    gen	move_l {post_inc4, sp},{post_inc4,%1}
    	move_l {post_inc4, sp},{post_inc4,%1}
    	move_l {post_inc4, sp},{post_inc4,%1}
    	move_l {post_inc4, sp},{post_inc4,%1}

pat sti $1>16
with AA_REG STACK
    kills ALL
    uses DD_REG = {const, $1/4 -1}
    gen 1:
	move_l {post_inc4, sp}, {post_inc4, %1}
	dbf %a, {slabel, 1b}

pat sts $1==4
with STACK
    kills ALL
    gen jsr {absolute4, ".sts"}

pat sdl
with any4-sconsts any4-sconsts
    kills all_indir, LOCAL %bd==$1
    gen move %1, {LOCAL, $1} 
        move %2, {LOCAL, $1+4}
with exact STACK
    kills all_indir, LOCAL %bd==$1
    gen move_l {post_inc4, sp}, {LOCAL,$1}
        move_l {post_inc4, sp}, {LOCAL,$1+4}

pat sde
with any4-sconsts any4-sconsts
    kills posextern
    gen move %1, {absolute4, $1}
	move %2, {absolute4, $1+4}
with exact STACK
    kills posextern
    gen move_l {post_inc4, sp}, {absolute4,$1}
        move_l {post_inc4, sp}, {absolute4,$1+4}

pat sdf
with A_REG any4-sconsts any4-sconsts
    kills allexceptcon
    gen move %2, {offsetted4, %1, $1}
	move %3, {offsetted4, %1, $1+4}
with exact local_addr any4 any4
    kills allexceptcon
    gen move %2, {LOCAL, %1.bd+$1}
	move %3, {LOCAL, %1.bd+$1+4}
with regAcon any4-sconsts any4-sconsts
    kills allexceptcon
    gen move %2, {offsetted4, %1.reg, %1.bd+$1}
	move %3, {offsetted4, %1.reg, %1.bd+$1+4}



/************************************************
 * Group 3: integer arithmetic.			*
 ************************************************/


pat adi $1==4
with any4-bconst DD_REG
    gen add_l %1, %2	yields	%2
with DD_REG any4-DD_REG-bconst
    gen add_l %2, %1	yields	%1
with exact any4 STACK
    uses reusing %1,DD_REG=%1
    gen add_l {post_inc4, sp}, %a
			yields	%a

pat sbi $1==4
with any4-bconst DD_REG
    gen sub_l %1, %2	yields	%2
with DD_REG any4-DD_REG-bconst
    gen sub_l %2, %1
	neg_l %1	yields	%1
with exact any4 STACK
    uses reusing %1,DD_REG=%1
    gen sub_l {post_inc4, sp}, %a
	neg_l %a	yields	%a
with any4-bconst AA_REG
    gen sub_l %1, %2	yields	%2

pat mli $1==4
#ifdef TBL68020
with data4 DD_REG
    gen muls_l %1, %2	yields	%2
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".mli"}
			yields	d1
#endif TBL68020

pat dvi $1==4
#ifdef TBL68020
with data4-sconsts DD_REG
    gen divs_l %1, %2	yields	%2
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".dvi"}
			yields	d1
#endif TBL68020

pat rmi $1==4
#ifdef TBL68020
with data4-sconsts DD_REG
    uses DD_REG
    gen divsl_l %1, {DREG_pair, %a, %2}
	killreg %2
		/* !!!! contents of %2 have changed: make this known to cg */
			yields	%a
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".dvi"}
			yields	d0
#endif TBL68020

pat ngi $1==4
with DD_REG
    gen neg_l %1	yields	%1

pat sli $1==4
with shconreg DD_REG
    gen asl_l %1, %2	yields	%2

pat sri $1==4
with shconreg DD_REG
    gen asr_l %1, %2	yields	%2



/************************************************
 * Group 4: unsigned arithmetic.		*
 ************************************************/


pat adu				leaving adi $1

pat sbu				leaving sbi $1

pat mlu $1==4
#ifdef TBL68020
with data4-sconsts DD_REG
    gen mulu_l %1, %2	yields	%2
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".mlu"}
			yields	d1
#endif TBL68020

pat dvu $1==4
#ifdef TBL68020
with data4-sconsts DD_REG
    gen divu_l %1, %2	yields	%2
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".dvu"}
			yields	d1
#endif TBL68020

pat rmu $1==4
#ifdef TBL68020
with data4-sconsts DD_REG
    uses DD_REG
    gen divul_l %1, {DREG_pair, %a, %2}
	killreg %2
		/* !!!! contents of %2 have changed: make this known to cg */
			yields	%a
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".dvu"}
			yields	d0
#endif TBL68020

pat slu				leaving sli $1

pat sru $1==4
with shconreg DD_REG
    gen lsr_l %1, %2	yields	%2



/************************************************
 * Group 5: floating point arithmetic		*
 ************************************************/

/* Floating point stuff
 * Arithmetic instructions
 */
 
#if TBL68881
pat adf $1==4
    with FS_REG STACK
    gen fadd_s {indirect4,sp},%1
	fmove_s %1,{indirect4,sp}
pat adf $1==8
    with FD_REG STACK
    gen fadd_d {indirect4,sp},%1
	fmove_d %1,{indirect4,sp}
pat sbf $1==4
    with FS_REG FS_REG STACK
    gen fsub %1,%2
	fmove_s %2,{pre_dec4,sp}
pat sbf $1==8
    with FD_REG FD_REG STACK
    gen fsub %1,%2
	fmove_d %2,{pre_dec4,sp}
pat mlf $1==4
    with FS_REG STACK
    gen fmul_s {indirect4,sp},%1
	fmove_s %1,{indirect4,sp}
pat mlf $1==8
    with FD_REG STACK
    gen fmul_d {indirect4,sp},%1
	fmove_d %1,{indirect4,sp}
pat dvf $1==4
    with FS_REG FS_REG STACK
    gen fdiv %1,%2
	fmove_s %2,{pre_dec4,sp}
pat dvf $1==8
    with FD_REG FD_REG STACK
    gen fdiv %1,%2
	fmove_d %2,{pre_dec4,sp}
pat ngf $1==4
    with FS_REG STACK
    gen fneg %1
	fmove_s %1,{pre_dec4,sp}
pat ngf $1==8
    with FD_REG STACK
    gen fneg %1
	fmove_d %1,{pre_dec4,sp}
pat fif $1==4
    with FS_REG FS_REG STACK
    gen fmul %1,%2
        fintrz %2,%1
	fsub %1,%2
	fmove_s %2,{pre_dec4,sp}
	fmove_s %1,{pre_dec4,sp}
pat fif $1==8
    with FD_REG FD_REG STACK
    gen fmul %1,%2
        fintrz %2,%1
	fsub %1,%2
	fmove_d %2,{pre_dec4,sp}
	fmove_d %1,{pre_dec4,sp}
pat fef $1==4
    with FS_REG STACK
    uses D_REG, FS_REG
    gen	fgetexp %1,%b
	fmove_l %b,%a
	add_l {const,1},%a
	fgetman %1
	fmove_l {const,2},%b
	fdiv %b,%1
	fmove_s %1,{pre_dec4,sp}
				yields %a
pat fef $1==8
    with FD_REG STACK
    uses D_REG, FD_REG
    gen	fgetexp %1,%b
	fmove_l %b,%a
	add_l {const,1},%a
	fgetman %1
	fmove_l {const,2},%b
	fdiv %b,%1
	fmove_d %1,{pre_dec4,sp}
				yields %a
#else
pat adf $1==4	leaving  cal ".adf4" asp 4
pat adf $1==8	leaving  cal ".adf8" asp 8
pat sbf $1==4	leaving  cal ".sbf4" asp 4
pat sbf $1==8	leaving  cal ".sbf8" asp 8
pat mlf $1==4	leaving  cal ".mlf4" asp 4
pat mlf $1==8	leaving  cal ".mlf8" asp 8
pat dvf $1==4	leaving  cal ".dvf4" asp 4
pat dvf $1==8	leaving  cal ".dvf8" asp 8
pat ngf $1==4	leaving  cal ".ngf4"
pat ngf $1==8	leaving  cal ".ngf8"
pat fif $1==4	leaving  cal ".fif4"
pat fif $1==8	leaving  cal ".fif8"
pat fef $1==4	leaving  dup 4 cal ".fef4"
pat fef $1==8
	kills ALL
	gen
	    move_l {post_inc4, sp}, d0
	    move_l {post_inc4, sp}, d1
	    move_l d0, {pre_dec4, sp}
	    move_l d1, {pre_dec4, sp}
	    move_l d0, {pre_dec4, sp}
		leaving cal ".fef8"
#endif

/************************************************
 * Group 6: pointer arithmetic			*
 ************************************************/

pat adp $1==0		/* skip; array instructions might 'leave' this */

pat adp
with A_REG		yields	{t_regAcon, %1, $1}
with exact local_addr	yields	{local_addr, %1.bd+$1}
with exact ext_addr	yields	{ext_addr, %1.bd+$1}
with exact regAcon + t_regAcon
			yields	{t_regAcon, %1.reg, %1.bd+$1}
with exact regAregXcon + t_regAregXcon
			yields	{t_regAregXcon,%1.reg, %1.xreg, %1.sc, %1.bd+$1}
#if TBL68020 && FANCY_MODES
with exact indirect4	yields	{off_con, %1.reg, 0, $1}
with exact LOCAL	yields	{off_con, lb, %1.bd, $1}
with exact offsetted4	yields	{off_con, %1.reg, %1.bd, $1}
with exact off_con	yields	{off_con, %1.reg, %1.bd, %1.od+$1}
with exact index_off4	yields	{indoff_con, %1.reg, %1.xreg, %1.sc, %1.bd, $1}
with exact indoff_con	yields	{indoff_con,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact off_regXcon	yields	{off_regXcon,
					%1.reg, %1.xreg, %1.sc, %1.bd, %1.od+$1}
with exact absolute4	yields	{abs_con, %1.bd, $1}
with exact abs_con	yields	{abs_con, %1.bd, %1.od+$1}
with exact abs_regXcon	yields	{abs_regXcon, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact abs_index4	yields	{absind_con, %1.sc, %1.xreg, %1.bd, $1}
with exact absind_con	yields	{absind_con, %1.sc, %1.xreg, %1.bd, %1.od+$1}
with exact ext_regX	yields	{ext_regX, %1.sc, %1.xreg, %1.bd+$1}
#endif

pat ads cmp $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving cmu 4
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving cmu 4
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving cmu 4
#endif

pat ads bne $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving bne $2
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving bne $2
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving bne $2
#endif

pat ads beq $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving beq $2
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving beq $2
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving beq $2
#endif

pat ads loe bne $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving loe $2 bne $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving loe $2 bne $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving loe $2 bne $3
#endif

pat ads loe beq $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving loe $2 beq $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving loe $2 beq $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving loe $2 beq $3
#endif

pat ads loe cmp $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving loe $2 cmu 4
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving loe $2 cmu 4
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving loe $2 cmu 4
#endif

pat ads lae bne $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lae $2 bne $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lae $2 bne $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lae $2 bne $3
#endif

pat ads lae beq $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lae $2 beq $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lae $2 beq $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lae $2 beq $3
#endif

pat ads lae cmp $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lae $2 cmu 4
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lae $2 cmu 4
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lae $2 cmu 4
#endif

pat ads lal bne $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lal $2 bne $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lal $2 bne $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lal $2 bne $3
#endif

pat ads lal beq $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lal $2 beq $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lal $2 beq $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lal $2 beq $3
#endif

pat ads lal cmp $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lal $2 cmu 4
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lal $2 cmu 4
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lal $2 cmu 4
#endif

pat ads lol bne $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lol $2 bne $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lol $2 bne $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lol $2 bne $3
#endif

pat ads lol beq $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lol $2 beq $3
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lol $2 beq $3
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lol $2 beq $3
#endif

pat ads lol cmp $1==4
with DD_REG any4
     gen add_l %2, %1	yields	%1	leaving lol $2 cmu 4
with any4 DD_REG
     gen add_l %1, %2	yields	%2	leaving lol $2 cmu 4
#ifdef TBL68020
with regX AA_REG
     gen move {regAregXcon, %2, %1.xreg, %1.sc, 0},%2
			yields	%2	leaving lol $2 cmu 4
#endif

pat ads $1==4
with D_REG A_REG	yields	{regAregXcon, %2, %1, 1, 0}
with D_REG regAcon + t_regAcon
			yields	{t_regAregXcon, %2.reg, %1, 1, %2.bd}
with D_REG local_addr	yields	{t_regAregXcon, lb, %1, 1, %2.bd}
with any4 AA_REG
    gen add_l %1, %2	yields	%2

#ifdef TBL68020

with D_REG		yields	{regX, 1, %1}
				leaving ads 4
with regX A_REG		yields	{regAregXcon, %2, %1.xreg, %1.sc, 0}
with exact regX regAcon	yields	{regAregXcon, %2.reg, %1.xreg, %1.sc, %2.bd}
with exact regX local_addr
			yields	{regAregXcon, lb, %1.xreg, %1.sc, %2.bd}
#ifdef FANCY_MODES
with exact regX indirect4
			yields	{off_regXcon, %2.reg, %1.xreg,%1.sc,0,0}
with exact regX offsetted4
			yields	{off_regXcon, %2.reg, %1.xreg, %1.sc, %2.bd, 0}
with exact regX LOCAL	yields	{off_regXcon, lb, %1.xreg, %1.sc, %2.bd, 0}
with exact regX off_con	yields	{off_regXcon, %2.reg, %1.xreg,%1.sc,%2.bd,%2.od}
with exact regX ext_addr
			yields	{ext_regX, %1.sc, %1.xreg, %2.bd}
with exact regX absolute4
			yields	{abs_regXcon, %1.sc, %1.xreg, %2.bd, 0}
with exact regX abs_con	yields	{abs_regXcon, %1.sc, %1.xreg, %2.bd, %2.od}
with exact indirect4 ext_addr
			yields	{off_con, %1.reg, 0, %2.bd}
with exact offsetted4 ext_addr
			yields	{off_con, %1.reg, %1.bd, %2.bd}
with exact LOCAL ext_addr
			yields	{off_con, lb, %1.bd, %2.bd}
with exact index_off4 ext_addr
			yields	{indoff_con, %1.reg, %1.xreg, %1.sc,%1.bd,%2.bd}
with exact absolute4 ext_addr
			yields	{abs_con, %1.bd, %2.bd}
with exact abs_index4 ext_addr
			yields	{absind_con, %1.sc, %1.xreg, %1.bd, %2.bd}
with exact indirect4 ext_regX
			yields	{off_regXcon, %1.reg, %2.xreg, %2.sc, 0, %2.bd}
with exact offsetted4 ext_regX
			yields	{off_regXcon, %1.reg, %2.xreg,%2.sc,%1.bd,%2.bd}
with exact LOCAL ext_regX
			yields	{off_regXcon, lb, %2.xreg, %2.sc, %1.bd, %2.bd}
with exact absolute4 ext_regX
			yields	{abs_regXcon, %2.sc, %2.xreg, %1.bd, %2.bd}
#endif
#endif TBL68020

	/* I WOULD ALSO LIKE THIS:
	 * 	pat ads
	 * 	with const			leaving adp %1.num
	 * BUT THAT DOESN'T WORK.
	 */

pat sbs $1==4			leaving sbi 4

#ifdef TBL68020
pat loc slu $2==4		leaving loc $1 sli 4

pat loc sli ads $1==1 && $2==4 && $3==4
with D_REG		yields	{regX, 2, %1}
				leaving ads 4

pat loc sli ads $1==2 && $2==4 && $3==4
with D_REG		yields	{regX, 4, %1}
				leaving ads 4

pat loc sli ads $1==3 && $2==4 && $3==4
with D_REG		yields	{regX, 8, %1}
				leaving ads 4
#endif TBL68020


/************************************************
 * Group 7: increment / decrement / zero	*
 ************************************************/

pat inc					leaving loc 1 adi 4

pat inl inreg($1)==reg_any
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen add_l {const, 1}, {LOCAL, $1}

pat inl
    kills all_indir, LOCAL %bd==$1
    gen add_l {const, 1}, {LOCAL, $1}

pat lol inl $1==$2
    kills all_indir, LOCAL %bd==$1
    uses DD_REG = {LOCAL, $1}
    gen add_l {const, 1}, {LOCAL, $1}
    killreg %a
			yields %a

pat ine
    kills posextern
    gen add_l {const, 1}, {absolute4, $1}

pat dec					leaving loc 1 sbi 4

pat del inreg($1)==reg_any
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen sub_l {const, 1}, {LOCAL, $1}

pat del
    kills all_indir, LOCAL %bd==$1
    gen sub_l {const, 1}, {LOCAL, $1}

pat lol del $1==$2
    kills all_indir, LOCAL %bd==$1
    uses DD_REG = {LOCAL, $1}
    gen sub_l {const, 1}, {LOCAL, $1}
	killreg %a
			yields %a

pat dee
    kills posextern
    gen sub_l {const, 1}, {absolute4, $1}

pat zrl inreg($1)==reg_any
    kills regvar($1, reg_any), use_index %xreg==regvar($1, reg_any)
    gen clr_l {LOCAL, $1}

pat zrl inreg($1)==reg_pointer
    kills regvar($1, reg_pointer), all_regind %reg==regvar($1, reg_pointer)
    gen move {const,0}, {areg, regvar($1, reg_pointer)}

pat zrl
    kills all_indir, LOCAL %bd==$1
    gen clr_l {LOCAL, $1}

pat zrl lol $1==$2 && inreg($1) < 0
    kills all_indir, LOCAL %bd==$1
    gen clr_l {LOCAL, $1}	yields {zero_const, 0}

pat zre
    kills posextern
    gen clr_l {absolute4, $1}

pat zre loe $1==$2
    kills posextern
    gen clr_l {absolute4, $1}	yields {zero_const, 0}

pat zer $1==4		yields	{zero_const, 0}
pat zer $1==8		yields	{zero_const, 0} {zero_const, 0}
pat zer $1==12		yields	{zero_const, 0} {zero_const, 0} {zero_const, 0}

pat zer
with STACK
    uses DD_REG = {const, $1/4 -1}
    gen 1:
	clr_l {pre_dec4, sp}
	dbf %a, {slabel, 1b}



/************************************************
 * Group 8: convert instructions		*
 ************************************************/



pat cii
with STACK
    kills ALL
    gen jsr {absolute4, ".cii"}

pat cuu
with STACK
    kills ALL
    gen jsr {absolute4, ".cuu"}

pat ciu				leaving cuu

pat cui				leaving cuu

#if TBL68881
pat loc loc cif $1==4 && $2==4
with data4 STACK
    uses FS_REG
    gen	fmove_l %1,%a
	fmove_s %a,{pre_dec4,sp}
pat loc loc cif $1==4 && $2==8
with data4 STACK
    uses FD_REG
    gen	fmove_l %1,%a
	fmove_d %a,{pre_dec4,sp}
pat loc loc cuf $1==4 && $2==4
with D_REG STACK
    uses FS_REG
    gen	fmove_l %1,%a
	tst_l %1
	bge {slabel, 1f}
	fsub_l {const,0-2147483648},%a
	fsub_l {const,0-2147483648},%a
	1:
	fmove_s %a,{pre_dec4,sp}
pat loc loc cuf $1==4 && $2==8
with D_REG STACK
    uses FD_REG
    gen	fmove_l %1,%a
	tst_l %1
	bge {slabel, 1f}
	fsub_l {const,0-2147483648},%a
	fsub_l {const,0-2147483648},%a
	1:
	fmove_d %a,{pre_dec4,sp}
pat loc loc cfi $1==4 && $2==4
with FS_REG
    uses D_REG
    gen	fintrz %1,%1
	fmove_l %1,%a		yields %a
pat loc loc cfi $1==8 && $2==4
with FD_REG
    uses D_REG
    gen	fintrz %1,%1
	fmove_l %1,%a		yields %a
pat loc loc cfu $1==4 && $2==4
with FS_REG
    uses D_REG
    gen fabs %1
	fintrz %1,%1
	fmove_l %1,%a		yields %a
pat loc loc cfu $1==8 && $2==4
with FD_REG
    uses D_REG
    gen fabs %1
	fintrz %1,%1
	fmove_l %1,%a		yields %a
pat loc loc cff $1==4 && $2==8
with FS_REG STACK
    gen fmove_d %1,{pre_dec4,sp}
pat loc loc cff $1==8 && $2==4
with FD_REG STACK
    gen fmove_s %1,{pre_dec4,sp}
#else
/*
 * Floating point stuff
 * Conversion
 */
pat loc loc cif	$1==4 && $2==4 leaving loc 4 cal ".cif4" asp 4
pat loc loc cif	$1==4 && $2==8 leaving loc 4 cal ".cif8"
pat loc loc cuf	$1==4 && $2==4 leaving loc 4 cal ".cuf4" asp 4
pat loc loc cuf	$1==4 && $2==8 leaving loc 4 cal ".cuf8"
pat loc loc cfi	leaving loc $1 loc $2 cal ".cfi" asp 8+($1-4)
pat loc loc cfu	leaving loc $1 loc $2 cal ".cfu" asp 8+($1-4)
pat loc loc cff	$1==8 && $2==4 leaving cal ".cff4" asp 4
pat loc loc cff	$1==4 && $2==8
	leaving loc 0 exg 4 cal ".cff8"
#endif

/************************************************
 * Group 9: logical instructions		*
 ************************************************/


proc log4
with datalt4+consts-sconsts DD_REG
    gen xxx* %1, %2	yields	%2
with DD_REG datalt4+consts-sconsts
    gen xxx* %2, %1	yields	%1
with exact any4 STACK
    uses reusing %1,DD_REG=%1
    gen xxx* {post_inc4, sp}, %a	yields %a

proc logdef example and
with STACK
    uses DD_REG = {const, $1/4 -1},
	 AA_REG,
	 DD_REG
    gen 
	lea {regAcon, sp, $1}, %b
	1:
	move_l {post_inc4, sp}, %c
	xxx* %c, {post_inc4, %b}
	dbf %a, {slabel, 1b}

proc logndef
with DD_REG STACK
    uses AA_REG,
	 DD_REG
    gen
	lea {regAregXcon, sp, %1, 1, 0},%a
	asr_l {small_const, 2}, %1
	sub_l {const, 1}, %1
	1:
	move_l {post_inc4, sp}, %b
	xxx* %b, {post_inc4, %a}
	dbf %1, {slabel, 1b}

pat and $1==4				call log4("and.l")
pat and $1>4				call logdef("and.l")
pat and !defined($1)			call logndef("and.l")
pat ior $1==4				call log4("or.l")
pat ior $1>4				call logdef("or.l")
pat ior !defined($1)			call logndef("or.l")

pat xor $1==4
with conreg4-bconst DD_REG
    gen eor_l %1, %2	yields	%2
with DD_REG conreg4-bconst 
    gen eor_l %2, %1	yields	%1

pat xor $1>4				call logdef("eor.l")
pat xor !defined($1)			call logndef("eor.l")

pat com $1==4
with DD_REG
    gen not_l %1	yields	%1

pat com $1==8
with DD_REG DD_REG
    gen not_l %1
	not_l %2	yields	%2 %1

pat com $1>4
with STACK
    uses AA_REG,
	 DD_REG = {const, $1/4 -1}
    gen move_l sp, %a
	1:
	not_l {post_inc4, %a}
	dbf %b, {slabel, 1b}

pat com !defined($1)
with DD_REG STACK
    uses AA_REG
    gen move_l sp, %a
	asr_l {small_const, 2}, %1
	sub_l {const, 1}, %1
	1:
	not_l {post_inc4, %a}
	dbf %1, {slabel, 1b}

pat rol $1==4
with shconreg DD_REG
    gen rol_l %1, %2	yields	%2

pat ror $1==4
with shconreg DD_REG
    gen ror_l %1, %2	yields	%2

	


/************************************************
 * Group 10: sets				*
 ************************************************/


pat inn $1==4
with conreg2 DD_REG
    gen btst %1, %2
	sne {dreg1, %2}
	and_l {const, 1}, %2
			yields	%2

pat inn defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	move {const, $1}, d1
	jsr {absolute4, ".inn"}
			yields	d0

pat inn !defined($1)
with any4 any4 STACK
    kills ALL
    gen move %2, d0
	move %1, d1
	jsr {absolute4, ".inn"}
			yields	d0

pat loc inn $2==4 && small($1)
with DD_REG
    gen asr_l {small_const, $1}, %1
	and_l {const, 1}, %1
			yields	%1

pat set $1==4
with conreg2
    uses DD_REG = {const, 0}
    gen bset %1, %a	yields	%a

pat set $1>4
with any4 STACK
    kills ALL
    gen move %1, d0
	move {const, $1}, d1
	jsr {absolute4, ".set"}

pat set !defined($1)
with any4 any4 STACK
    kills ALL
    gen move %2, d0
	move %1, d1
	jsr {absolute4, ".set"}




/************************************************
 * Group 11: arrays				*
 ************************************************/


pat lar defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".lar"}

pat lar !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".lar"}

pat sar defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".sar"}

pat sar !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".sar"}

pat aar defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".aar"}
			yields	a0

pat aar !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".aar"}
			yields	a0

pat lae lar $2==4 && nicesize(rom($1,3))
				leaving lae $1 aar 4 loi rom($1, 3)
pat lae sar $2==4 && nicesize(rom($1,3))
				leaving lae $1 aar 4 sti rom($1, 3)

pat lae aar $2==4 && rom($1,3)==1
				leaving ads 4 adp 0-rom($1,1)

#ifdef TBL68020
pat lae aar $2==4 && nicesize(rom($1,3))
with D_REG		yields	{regX, rom($1,3), %1}
				leaving ads 4 adp rom($1,3)*(0-rom($1,1))
#else TBL68020
pat lae aar $2==4 && rom($1,3)==2
with DD_REG
    gen asl_l {small_const, 1}, %1
			yields	%1
				leaving ads 4 adp (0 - rom($1,1))<<1

pat lae aar $2==4 && rom($1,3)==4
with DD_REG
    gen asl_l {small_const, 2}, %1
			yields	%1
				leaving ads 4 adp (0 - rom($1,1))<<2

pat lae aar $2==4 && rom($1,3)==8
with DD_REG
    gen asl_l {small_const, 3}, %1
			yields	%1
				leaving ads 4 adp (0 - rom($1,1))<<3
#endif TBL68020

	/* I WOULD ALSO LIKE THESE:
	 * pat lae aar $2==4 && defined(rom($1,3))
	 * with const 		leaving adp rom($1,3)*(%1.num-rom($1,1))
	 * pat lae lar $2==4 && defined(rom($1,3))
	 * with const		leaving adp rom($1,3)*(%1.num-rom($1,1))
	 *				loi rom($1,3)
	 * pat lae sar $2==4 && defined(rom($1,3))
	 * with const		leaving adp rom($1,3)*(%1.num-rom($1,1))
	 *				sti rom($1,3)
	 * BUT THEY DON'T WORK.
	 */



/************************************************
 * Group 12: compare instructions		*
 ************************************************/


/* pat cmi $1==4			leaving sbi 4
   WRONG !!
*/

pat cmi defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".cmi"}
			yields	d0

pat cmi !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".cmi"}
			yields	d0

/* pat cmu $1==4			leaving sbi 4
   WRONG !!
*/

pat cmu defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".cmu"}
			yields	d0

pat cmu !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".cmu"}
			yields	d0

pat cms $1==4			leaving sbi 4

pat cms defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".cms"}
			yields	d0

pat cms !defined($1)
with any4 STACK
    kills ALL
    gen move %1, d0
	jsr {absolute4, ".cms"}
			yields	d0

pat cmp				leaving cmu 4

#ifndef XXXXX
proc txx
with test_set4
    uses reusing %1,DD_REG
    gen test %1
	bxx[1] {slabel,1f}
	clr_l %a
	bra {slabel,2f}
	1:
	move_l {const,1},%a
	2:
			yields	%a

with test_set1 + test_set2
    uses reusing %1,DD_REG
    gen test %1
	bxx[2] {slabel,1f}
	clr_l %a
	bra {slabel,2f}
	1:
	move_l {const,1},%a
	2:
			yields	%a

pat tlt					call txx("blt", "bcs")
pat tle					call txx("ble", "bls")
pat teq					call txx("beq", "beq")
pat tne					call txx("bne", "bne")
pat tge					call txx("bge", "bcc")
pat tgt					call txx("bgt", "bhi")
#else
proc txx
with test_set4
    uses reusing %1,DD_REG
    gen test %1
	sxx[1] %a
	neg_b %a
			yields {extend1, %a}

with test_set1 + test_set2
    uses reusing %1,DD_REG
    gen test %1
	sxx[2] %a
	neg_b %a
			yields {extend1, %a}

pat tlt					call txx("slt", "scs")
pat tle					call txx("sle", "sls")
pat teq					call txx("seq", "seq")
pat tne					call txx("sne", "sne")
pat tge					call txx("sge", "scc")
pat tgt					call txx("sgt", "shi")
#endif

/*
 * Floating point
 * Comparision
 */
#if TBL68881
pat cmf $1==4
with FS_REG FS_REG
    uses D_REG={const,0}
    gen	fcmp %1,%2
	fbeq {slabel,2f}
	fblt {slabel,1f}
	add_l {const,1},%a
	bra {slabel,2f}
	1:
	sub_l {const,1},%a
	2:			yields %a
pat cmf $1==8
with FD_REG FD_REG
    uses D_REG={const,0}
    gen	fcmp %1,%2
	fbeq {slabel,2f}
	fblt {slabel,1f}
	add_l {const,1},%a
	bra {slabel,2f}
	1:
	sub_l {const,1},%a
	2:			yields %a
#else
pat cmf $1==4	leaving cal ".cmf4" asp 8 lfr 4
pat cmf $1==8	leaving cal ".cmf8" asp 16 lfr 4
#endif
/*
 * Floating Point
 * Zero Constants
 */
pat zrf		leaving zer $1

/************************************************
 * Group 13: branch instructions		*
 ************************************************/

pat bra
with STACK
    gen bra {llabel, $1}

proc brxx example beq
with exact extend1 extend1
    kills ALL
    gen cmp_b %1,%2
	bxx[1] {llabel, $1}
with exact extend2 extend2
    kills ALL
    gen cmp_w %1,%2
	bxx[1] {llabel, $1}
with exact sconsts any4
    kills ALL
    uses DD_REG=%1
    gen cmp_l %2, %a
	bxx[2] {llabel, $1}
with exact any4 sconsts
    kills ALL
    uses DD_REG=%2
    gen cmp_l %1, %a
	bxx[1] {llabel, $1}
with any4-sconsts genreg STACK
    gen cmp_l %1, %2
	bxx[1] {llabel, $1}
with genreg any4-sconsts STACK
    gen cmp_l %2, %1
	bxx[2] {llabel, $1}
with exact immediate4-sconsts imm_cmp4
    kills ALL
    gen cmp_l %1, %2
	bxx[1] {llabel, $1}
with exact imm_cmp4 immediate4-sconsts
    kills ALL
    gen cmp_l %2, %1
	bxx[2] {llabel, $1}
with exact immediate4-sconsts STACK
    gen cmp_l %1, {post_inc4, sp}
	bxx[1] {llabel, $1}
with exact any4 STACK
    uses reusing %1,DD_REG=%1
    gen cmp_l {post_inc4, sp}, %a
	bxx[2] {llabel, $1}
with exact STACK
    uses DD_REG
    gen	move_l {post_inc4, sp},%a
	cmp_l {post_inc4, sp},%a
	bxx[2] {llabel, $1}

pat blt					call brxx("blt","bgt")
pat ble					call brxx("ble","bge")
pat beq					call brxx("beq","beq")
pat bne					call brxx("bne","bne")
pat bge					call brxx("bge","ble")
pat bgt					call brxx("bgt","blt")

proc zxx example zeq
with test_set4 STACK
    gen test %1
	bxx[1] {llabel, $1}
with test_set1 + test_set2 STACK
    gen test %1
	bxx[2] {llabel, $1}
with exact STACK
    gen test {post_inc4, sp}
	bxx[1] {llabel, $1}

pat zlt					call zxx("blt", "bcs")
pat zle					call zxx("ble", "bls")
pat zeq					call zxx("beq", "beq")
pat zne					call zxx("bne", "bne")
pat zge					call zxx("bge", "bcc")
pat zgt					call zxx("bgt", "bhi")

/************************************************
 * Group 14: procedure calls instructions	*
 ************************************************/


pat cai
with exact ext_addr
    kills ALL
    gen jsr {absolute4, %1.bd}
with A_REG STACK
    kills ALL
    gen jsr {indirect4, %1}
with STACK
    kills ALL
    uses AA_REG = {post_inc4, sp}
    gen jsr {indirect4, %a}
with address STACK
    kills ALL
    gen jsr %1

pat cal
with STACK
    kills ALL
    gen jsr {absolute4, $1}

pat lfr $1==4		yields	d0
pat lfr $1==8		yields	d1 d0

pat ret $1==0
    gen return

pat asp ret $1==0
    gen return

pat ret $1==4
with any4
    gen move %1, d0
	return
with exact STACK
    gen move_l {post_inc4, sp}, d0
	return

pat ret $1==8
with any4 any4
    gen move %1, d0
	move %2, d1
	return
with exact any4 STACK
    gen move %1, d0
	move_l {post_inc4, sp}, d1
	return
with exact STACK
    gen move_l {post_inc4, sp}, d0
	move_l {post_inc4, sp}, d1
	return


/************************************************
 * Group 15: miscellaneous instructions		*
 ************************************************/

pat asp $1==4
with any-pre_post
with STACK
    gen add_l {const, $1}, sp
pat asp $1==8
with any-pre_post any-pre_post
with STACK
    gen add_l {const, $1}, sp
pat asp
with STACK
    gen lea {regAcon, sp, $1}, sp

pat ass $1==4
with any4 STACK
    gen add_l %1, sp

pat blm $1==4
with A_REG A_REG
    kills allexceptcon
    gen move_l {indirect4, %2}, {indirect4, %1}

pat blm $1==8
with A_REG A_REG
    kills allexceptcon
    gen	move_l {indirect4, %2}, {indirect4, %1}
	move_l {offsetted4, %2, 4}, {offsetted4, %1, 4}

pat blm $1>8
with AA_REG AA_REG
    kills ALL
    uses DD_REG={const, $1/4 -1}
    gen 1:
	move_l {post_inc4, %2}, {post_inc4, %1}
	dbf %a, {slabel, 1b}

pat bls $1==4
with DD_REG AA_REG AA_REG
    kills ALL
    gen asr_l {small_const, 2}, %1
	beq {slabel, 2f}
	sub_l {const, 1}, %1
	1:
	move_l {post_inc4, %3}, {post_inc4, %2}
	dbf %1, {slabel, 1b}
	2:

pat csa $1==4
with any4 any4 STACK
    gen move %1,a0
	move %2,d0
	jmp {absolute4, ".csa"}

pat csb $1==4
with any4 any4 STACK
    gen move %1,a0
	move %2,d0
	jmp {absolute4, ".csb"}

pat dch				leaving loi 4

pat dup $1==4
with dups4				yields	%1 %1

pat dup $1==8
with dups4 dups4			yields	%2 %1 %2 %1

pat dup $1>8
with STACK
    uses DD_REG = {const, $1/4 -1}
    gen 1:
	move_l {offsetted4, sp, $1 -4}, {pre_dec4, sp}
	dbf %a, {slabel, 1b}

pat dus $1==4
with DD_REG STACK
    uses AA_REG
    gen
    	lea {regAregXcon, sp, %1, 1, 0}, %a
	asr_l {small_const, 2}, %1
	beq {slabel, 2f}
	sub_l {const, 1}, %1
	1:
	move_l {pre_dec4, %a}, {pre_dec4, sp}
	dbf %1, {slabel, 1b}
	2:

pat exg $1==4
with any4 any4		yields	%1 %2

pat exg defined($1)
with STACK
    kills ALL
    gen move {const, $1}, d0
	jsr {absolute4, ".exg"}

pat exg !defined($1)
with any4 STACK
    kills ALL
    gen move_l %1, d0
	jsr {absolute4, ".exg"}

pat fil
    gen move_l {ext_addr, $1}, {absolute4, ".filn"}

pat gto
with STACK
    uses AA_REG = {ext_addr, $1}
    gen move_l {offsetted4, %a, 8}, lb
	move_l {offsetted4, %a, 4}, sp
#if TBL68020 && FANCY_MODES
	jmp {OFF_off4, %a, 0, 0}
#else
	move_l {indirect4, %a}, %a
	jmp {indirect4, %a}
#endif

pat lim			yields	{absolute4, ".trpim"}

pat lin
    kills posextern
    gen move_l {const, $1}, {absolute4, ".lino"}
    
pat lni
    kills posextern
    gen add_l {const, 1}, {absolute4, ".lino"}

pat lor $1==0		yields	lb

pat lor $1==1
with STACK
    uses AA_REG = sp	yields	%a

pat lor $1==2		yields	{absolute4, ".reghp"}

pat lpb				leaving adp 8

pat mon
with STACK
    kills ALL
    gen jsr {absolute4, ".mon"}

pat nop
with STACK
    kills ALL
    gen jsr {absolute4, ".nop"}

pat rck
#ifdef TBL68020
with ext_addr D_REG
    gen cmp2_l {absolute4, %1.bd}, %2
	bcc {slabel, 1f}
	pea {absolute4, 1}			/* push constant 1 == ERANGE */
	jsr {absolute4, ".trp"}
	1:			yields	%2
with address-ext_addr D_REG
    gen cmp2_l %1, %2
	bcc {slabel, 1f}
	pea {absolute4, 1}			/* push constant 1 == ERANGE */
	jsr {absolute4, ".trp"}
	1:			yields	%2
with A_REG D_REG
    gen cmp2_l {indirect4, %1}, %2
	bcc {slabel, 1f}
	pea {absolute4, 1}			/* push constant 1 == ERANGE */
	jsr {absolute4, ".trp"}
	1:			yields	%2
#else TBL68020
with STACK
    kills ALL
    gen jsr {absolute4, ".rck"}
#endif TBL68020

pat rtt				leaving ret 0

pat sig
with any4
    kills posextern
    uses AA_REG
    gen move_l {absolute4, ".trppc"}, %a
	move_l %1, {absolute4, ".trppc"}
			yields	%a

pat sim
with any4
    kills posextern
    gen move_l %1, {absolute4, ".trpim"}

pat str $1==0
with any4 STACK
    kills ALL
    gen move_l %1, lb

pat str $1==1
with any4 STACK
    gen move_l %1, sp

pat str $1==2
with STACK
    kills ALL
    gen jsr {absolute4, ".strhp"}

pat trp
with STACK
    kills ALL
    gen jsr {absolute4, ".trp"}
 


/************************************************
 * more rules for long EM-patterns		*
 ************************************************/

pat loe ine $1==$2
    kills posextern
    uses DD_REG = {absolute4, $1}
    gen add_l {const,1}, {absolute4, $1}
    killreg %a
			yields	%a

pat loe dee $1==$2
    kills posextern
    uses DD_REG = {absolute4, $1}
    gen sub_l {const,1}, {absolute4, $1}
    killreg %a
			yields	%a


proc llol1shstl example lol loc sli stl		/* only left */
    kills all_indir, LOCAL %bd==$1
    gen shw* {offsetted2, lb, $1+2}
	roxl {offsetted2, lb, $1}

proc lloe1shste example loe loc sli ste		/* only left */
    kills posextern
    gen shw* {absolute2, $1+2}
	roxl {absolute2, $1}

proc llil1shsil example lil loc sli sil		/* only left */
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen shw* {OFF_off2, lb, $1, 2}
	roxl {OFF_off2, lb, $1, 0}
#else
    uses AA_REG = {LOCAL, $1}
    gen shw* {offsetted2, %a, 2}
	roxl {indirect2, %a}
#endif

proc rlol1shstl example lol loc sri stl		/* only right */
    kills all_indir, LOCAL %bd==$1
    gen shw* {offsetted2, lb, $1}
	roxr {offsetted2, lb, $1+2}

proc rloe1shste example loe loc sri ste		/* only right */
    kills posextern
    gen shw* {absolute2, $1}
	roxr {absolute2, $1+2}

proc rlil1shsil example lil loc sri sil		/* only right */
    kills allexceptcon
#if TBL68020 && FANCY_MODES
    gen shw* {OFF_off2, lb, $1, 0}
	roxr {OFF_off2, lb, $1, 2}
#else
    uses AA_REG = {LOCAL, $1}
    gen shw* {indirect2, %a}
	roxr {offsetted2, %a, 2}
#endif

pat lol loc sli stl $1==$4 && $2==1 && $3==4	call llol1shstl("asl #1,")
pat loe loc sli ste $1==$4 && $2==1 && $3==4	call lloe1shste("asl #1,")
pat lil loc sli sil $1==$4 && $2==1 && $3==4	call llil1shsil("asl #1,")
pat lol loc sri stl $1==$4 && $2==1 && $3==4	call rlol1shstl("asr #1,")
pat loe loc sri ste $1==$4 && $2==1 && $3==4	call rloe1shste("asr #1,")
pat lil loc sri sil $1==$4 && $2==1 && $3==4	call rlil1shsil("asr #1,")
pat lol loc slu stl $1==$4 && $2==1 && $3==4	call llol1shstl("asl #1,")
pat loe loc slu ste $1==$4 && $2==1 && $3==4	call lloe1shste("asl #1,")
pat lil loc slu sil $1==$4 && $2==1 && $3==4	call llil1shsil("asl #1,")
pat lol loc sru stl $1==$4 && $2==1 && $3==4	call rlol1shstl("lsr #1,")
pat loe loc sru ste $1==$4 && $2==1 && $3==4	call rloe1shste("lsr #1,")
pat lil loc sru sil $1==$4 && $2==1 && $3==4	call rlil1shsil("lsr #1,")


proc txxand
with test_set4 DD_REG
    gen test %1
	bxx[1] {slabel, 1f}
	bclr {const,0}, %2
	1:		yields	%2
with test_set1 + test_set2 DD_REG
    gen test %1
	bxx[2] {slabel, 1f}
	bclr {const,0}, %2
	1:		yields	%2

proc txxior
with test_set4 DD_REG
    gen test %1
	bxx[1] {slabel, 1f}
	bset {const, 0}, %2
	1:		yields	%2
with test_set1 + test_set2 DD_REG
    gen test %1
	bxx[2] {slabel, 1f}
	bset {const, 0}, %2
	1:		yields	%2

pat tlt and $2==4			call txxand("blt", "bcs")
pat tle and $2==4			call txxand("ble", "bls")
pat teq and $2==4			call txxand("beq", "beq")
pat tne and $2==4			call txxand("bne", "bne")
pat tge and $2==4			call txxand("bge", "bcc")
pat tgt and $2==4			call txxand("bgt", "bhi")

pat tlt ior $2==4			call txxior("bge", "bcc")
pat tle ior $2==4			call txxior("bgt", "bhi")
pat teq ior $2==4			call txxior("bne", "bne")
pat tne ior $2==4			call txxior("beq", "beq")
pat tge ior $2==4			call txxior("blt", "bcs")
pat tgt ior $2==4			call txxior("ble", "bls")

proc cmxtxxand
with exact extend1 extend1 DD_REG
    gen cmp_b %2, %1
	bxx[2] {llabel,1f}
	bclr {const,0}, %3
	1:		yields	%3
with exact extend2 extend2 DD_REG
    gen cmp_w %2, %1
	bxx[2] {llabel,1f}
	bclr {const,0}, %3
	1:		yields	%3
with exact sconsts any4 DD_REG
    uses DD_REG=%1
    gen cmp_l %2, %a
	bxx[2] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3
with exact any4 sconsts DD_REG
    uses DD_REG=%2
    gen cmp_l %1, %a
	bxx[1] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3
with any4-sconsts genreg DD_REG
    gen cmp_l %1, %2
	bxx[1] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3
with genreg any4-sconsts DD_REG
    gen cmp_l %2, %1
	bxx[2] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3
with exact immediate4-sconsts imm_cmp4 DD_REG
    gen cmp_l %1, %2
	bxx[1] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3
with exact imm_cmp4 immediate4-sconsts DD_REG
    gen cmp_l %2, %1
	bxx[2] {slabel, 1f}
	bclr {const,0}, %3
	1:		yields	%3

proc cmxtxxior
with exact extend1 extend1 DD_REG
    gen cmp_b %2, %1
	bxx[2] {llabel,1f}
	bset {const, 0},  %3
	1:		yields	%3
with exact extend2 extend2 DD_REG
    gen cmp_w %2, %1
	bxx[2] {llabel,1f}
	bset {const, 0},  %3
	1:		yields	%3
with exact sconsts any4 DD_REG
    uses DD_REG=%1
    gen cmp_l %2, %a
	bxx[2] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3
with exact any4 sconsts DD_REG
    uses DD_REG=%2
    gen cmp_l %1, %a
	bxx[1] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3
with any4-sconsts genreg DD_REG
    gen cmp_l %1, %2
	bxx[1] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3
with genreg any4-sconsts DD_REG
    gen cmp_l %2, %1
	bxx[2] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3
with exact immediate4-sconsts imm_cmp4 DD_REG
    gen cmp_l %1, %2
	bxx[1] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3
with exact imm_cmp4 immediate4-sconsts DD_REG
    gen cmp_l %2, %1
	bxx[2] {slabel, 1f}
	bset {const, 0},  %3
	1:		yields	%3

proc cmxtxx
with exact sconsts any4
    uses DD_REG=%1
    gen cmp_l %2, %a
	sxx[2] %a
	neg_b %a
			yields {extend1, %a}
with exact any4 sconsts
    uses DD_REG=%2
    gen cmp_l %1, %a
	sxx[1] %a
	neg_b %a
			yields	{extend1, %a}
with any4-sconsts genreg
    uses reusing %1,reusing %2,DD_REG
    gen cmp_l %1, %2
	sxx[1] %a
	neg_b %a
			yields	{extend1, %a}
with genreg any4-sconsts
    uses reusing %1,reusing %2,DD_REG
    gen cmp_l %2, %1
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}
with exact extend1 extend1
    uses reusing %1,reusing %2,DD_REG
    gen cmp_b %2, %1
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}
with exact extend2 extend2
    uses reusing %1,reusing %2,DD_REG
    gen cmp_w %2, %1
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}
with exact immediate4-sconsts imm_cmp4
    uses reusing %2,DD_REG
    gen cmp_l %1, %2
	sxx[1] %a
	neg_b %a
			yields	{extend1, %a}
with exact imm_cmp4 immediate4-sconsts 
    uses reusing %1,DD_REG
    gen cmp_l %2, %1
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}
with exact immediate4-sconsts STACK
    uses DD_REG
    gen cmp_l %1, {post_inc4, sp}
	sxx[1] %a
	neg_b %a
			yields	{extend1, %a}
with exact any4 STACK
    uses reusing %1,DD_REG=%1
    gen cmp_l {post_inc4, sp}, %a
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}
with exact STACK
    uses DD_REG
    gen	move_l {post_inc4, sp},%a
	cmp_l {post_inc4, sp},%a
	sxx[2] %a
	neg_b %a
			yields	{extend1, %a}

pat cmi tlt and $1==4 && $3==4		call cmxtxxand("blt","bgt")
pat cmi tle and $1==4 && $3==4		call cmxtxxand("ble","bge")
pat cmi teq and $1==4 && $3==4		call cmxtxxand("beq","beq")
pat cmi tne and $1==4 && $3==4		call cmxtxxand("bne","bne")
pat cmi tge and $1==4 && $3==4		call cmxtxxand("bge","ble")
pat cmi tgt and $1==4 && $3==4		call cmxtxxand("bgt","blt")

pat cmu tlt and $1==4 && $3==4		call cmxtxxand("bcs","bhi")
pat cmu tle and $1==4 && $3==4		call cmxtxxand("bls","bcc")
pat cmu teq and $1==4 && $3==4		call cmxtxxand("beq","beq")
pat cmu tne and $1==4 && $3==4		call cmxtxxand("bne","bne")
pat cmu tge and $1==4 && $3==4		call cmxtxxand("bcc","bls")
pat cmu tgt and $1==4 && $3==4		call cmxtxxand("bhi","bcs")

pat cmi tlt ior $1==4 && $3==4		call cmxtxxior("bge","ble")
pat cmi tle ior $1==4 && $3==4		call cmxtxxior("bgt","blt")
pat cmi teq ior $1==4 && $3==4		call cmxtxxior("bne","bne")
pat cmi tne ior $1==4 && $3==4		call cmxtxxior("beq","beq")
pat cmi tge ior $1==4 && $3==4		call cmxtxxior("blt","bgt")
pat cmi tgt ior $1==4 && $3==4		call cmxtxxior("ble","bge")

pat cmu tlt ior $1==4 && $3==4		call cmxtxxior("bcc","bls")
pat cmu tle ior $1==4 && $3==4		call cmxtxxior("bhi","bcs")
pat cmu teq ior $1==4 && $3==4		call cmxtxxior("bne","bne")
pat cmu tne ior $1==4 && $3==4		call cmxtxxior("beq","beq")
pat cmu tge ior $1==4 && $3==4		call cmxtxxior("bcs","bhi")
pat cmu tgt ior $1==4 && $3==4		call cmxtxxior("bls","bcc")

pat cmi tlt $1==4			call cmxtxx("slt","sgt")
pat cmi tle $1==4			call cmxtxx("sle","sge")
pat cmi teq $1==4			call cmxtxx("seq","seq")
pat cmi tne $1==4			call cmxtxx("sne","sne")
pat cmi tge $1==4			call cmxtxx("sge","sle")
pat cmi tgt $1==4			call cmxtxx("sgt","slt")

pat cmu tlt $1==4			call cmxtxx("scs","shi")
pat cmu tle $1==4			call cmxtxx("sls","scc")
pat cmu teq $1==4			call cmxtxx("seq","seq")
pat cmu tne $1==4			call cmxtxx("sne","sne")
pat cmu tge $1==4			call cmxtxx("scc","sls")
pat cmu tgt $1==4			call cmxtxx("shi","scs")

proc cmuzxx example cmu zlt
with exact sconsts any4
    kills ALL
    uses DD_REG=%1
    gen cmp_l %2, %a
	bxx[2] {llabel, $2}
with exact any4 sconsts
    kills ALL
    uses DD_REG=%2
    gen cmp_l %1, %a
	bxx[1] {llabel, $2}
with any4-sconsts genreg STACK
    gen cmp_l %1, %2
	bxx[1] {llabel, $2}
with genreg any4-sconsts STACK
    gen cmp_l %2, %1
	bxx[2] {llabel, $2}
with exact immediate4-sconsts imm_cmp4
    kills ALL
    gen cmp_l %1, %2
	bxx[1] {llabel, $2}
with exact imm_cmp4 immediate4-sconsts
    kills ALL
    gen cmp_l %2, %1
	bxx[2] {llabel, $2}
with exact immediate4-sconsts STACK
    gen cmp_l %1, {post_inc4, sp}
	bxx[1] {llabel, $2}
with exact any4 STACK
    uses reusing %1, DD_REG=%1
    gen cmp_l {post_inc4, sp}, %a
	bxx[2] {llabel, $2}
with exact STACK
    uses DD_REG
    gen	move_l {post_inc4, sp},%a
	cmp_l {post_inc4, sp},%a
	bxx[2] {llabel, $2}
with data2-sconsts dreg2 STACK
    gen cmp_w %1, %2
        bxx[1] {llabel, $2}
with dreg2 data2-conreg2-sconsts STACK
    gen cmp_w %2, %1
        bxx[2] {llabel, $2}
with data1 dreg1 STACK
    gen cmp_b %1, %2
        bxx[1] {llabel, $2}
with dreg1 data1-conreg1 STACK
    gen cmp_b %2, %1
        bxx[2] {llabel, $2}

pat cmu zlt $1==4			call cmuzxx("bcs","bhi")
pat cmu zle $1==4			call cmuzxx("bls","bcc")
pat cmu zeq $1==4			call cmuzxx("beq","beq")
pat cmu zne $1==4			call cmuzxx("bne","bne")
pat cmu zge $1==4			call cmuzxx("bcc","bls")
pat cmu zgt $1==4			call cmuzxx("bhi","bcs")


#if TBL68881
proc cmf4zxx example cmf zlt
with FS_REG FS_REG
    gen	fcmp %1,%2
	bxx* {llabel, $2}

pat cmf zlt $1==4			call cmf4zxx("fblt")
pat cmf zle $1==4			call cmf4zxx("fble")
pat cmf zne $1==4			call cmf4zxx("fbne")
pat cmf zeq $1==4			call cmf4zxx("fbeq")
pat cmf zge $1==4			call cmf4zxx("fbge")
pat cmf zgt $1==4			call cmf4zxx("fbgt")

proc cmf8zxx example cmf zlt
with FD_REG FD_REG
    gen	fcmp %1,%2
	bxx* {llabel, $2}

pat cmf zlt $1==8			call cmf8zxx("fblt")
pat cmf zle $1==8			call cmf8zxx("fble")
pat cmf zne $1==8			call cmf8zxx("fbne")
pat cmf zeq $1==8			call cmf8zxx("fbeq")
pat cmf zge $1==8			call cmf8zxx("fbge")
pat cmf zgt $1==8			call cmf8zxx("fbgt")
#endif

proc bxx1_in example loc loc cii loc bne
with imm_cmp1 STACK
    gen cmp_b {const, lowb($4)}, %1
	bxx* {llabel, $5}

proc bxx2_in example loc loc cii loc bne
with imm_cmp2 STACK
    gen cmp_w {const, loww($4)}, %1
	bxx* {llabel, $5}

proc bxx1_small example loc bne
with imm_cmp1-D_REG STACK
    gen cmp_b {const, $1}, %1
	bxx[1] {llabel, $2}
with imm_cmp2-D_REG STACK
    gen	cmp_w {const, $1}, %1
	bxx[1] {llabel, $2}
with data4 STACK
uses DD_REG = {const, $1}
    gen cmp_l %1,%a
	bxx[2] {llabel, $2}

proc bxx2_small example loc bne
with imm_cmp2-D_REG STACK
    gen cmp_w {const, $1}, %1
	bxx[1] {llabel, $2}
with imm_cmp4 STACK
    gen cmp_l {const, $1}, %1
	bxx[2] {llabel, $2}

proc zxx1_in example loc loc cii zne
with test_set1 STACK
    gen test %1
	bxx* {llabel, $4}
with D_REG STACK
    gen test {dreg1, %1}
	bxx* {llabel, $4}

proc zxx2_in example loc loc cii zne
with test_set2 STACK
    gen test %1
	bxx* {llabel, $4}
with D_REG STACK
    gen test {dreg2, %1}
	bxx* {llabel, $4}

pat loc loc cii zlt $1==1 && $2==4	call zxx1_in("blt")
pat loc loc cii zle $1==1 && $2==4	call zxx1_in("ble")
pat loc loc cii zne $1==1 && $2==4	call zxx1_in("bne")
pat loc loc cii zeq $1==1 && $2==4	call zxx1_in("beq")
pat loc loc cii zge $1==1 && $2==4	call zxx1_in("bge")
pat loc loc cii zgt $1==1 && $2==4	call zxx1_in("bgt")

pat loc loc cii zlt $1==2 && $2==4	call zxx2_in("blt")
pat loc loc cii zle $1==2 && $2==4	call zxx2_in("ble")
pat loc loc cii zne $1==2 && $2==4	call zxx2_in("bne")
pat loc loc cii zeq $1==2 && $2==4	call zxx2_in("beq")
pat loc loc cii zge $1==2 && $2==4	call zxx2_in("bge")
pat loc loc cii zgt $1==2 && $2==4	call zxx2_in("bgt")

pat loc loc cii loc blt $1==1 && $2==4 && in_1($4)	call bxx1_in("blt")
pat loc loc cii loc ble $1==1 && $2==4 && in_1($4)	call bxx1_in("ble")
pat loc loc cii loc beq $1==1 && $2==4 && in_1($4)	call bxx1_in("beq")
pat loc loc cii loc bne $1==1 && $2==4 && in_1($4)	call bxx1_in("bne")
pat loc loc cii loc bge $1==1 && $2==4 && in_1($4)	call bxx1_in("bge")
pat loc loc cii loc bgt $1==1 && $2==4 && in_1($4)	call bxx1_in("bgt")

pat loc loc cii loc blt $1==2 && $2==4 && in_2($4)	call bxx2_in("blt")
pat loc loc cii loc ble $1==2 && $2==4 && in_2($4)	call bxx2_in("ble")
pat loc loc cii loc beq $1==2 && $2==4 && in_2($4)	call bxx2_in("beq")
pat loc loc cii loc bne $1==2 && $2==4 && in_2($4)	call bxx2_in("bne")
pat loc loc cii loc bge $1==2 && $2==4 && in_2($4)	call bxx2_in("bge")
pat loc loc cii loc bgt $1==2 && $2==4 && in_2($4)	call bxx2_in("bgt")

/* the second instruction for bxx1_small is the other way around! */
pat loc blt $1>=0 && $1<128		call bxx1_small("bcs", "bgt")
pat loc ble $1>=0 && $1<128		call bxx1_small("bls", "bge")
pat loc beq $1>=0 && $1<128		call bxx1_small("beq", "beq")
pat loc bne $1>=0 && $1<128		call bxx1_small("bne", "bne")
pat loc bge $1>=0 && $1<128		call bxx1_small("bcc", "ble")
pat loc bgt $1>=0 && $1<128		call bxx1_small("bhi", "blt")

pat loc blt $1>=128 && $1<32768		call bxx2_small("bcs", "blt")
pat loc ble $1>=128 && $1<32768		call bxx2_small("bls", "ble")
pat loc beq $1>=128 && $1<32768		call bxx2_small("beq", "beq")
pat loc bne $1>=128 && $1<32768		call bxx2_small("bne", "bne")
pat loc bge $1>=128 && $1<32768		call bxx2_small("bcc", "bge")
pat loc bgt $1>=128 && $1<32768		call bxx2_small("bhi", "bgt")

pat loc loc cii lal sti $1 <= 4 && $1>=$5 && $2==4
				leaving lal $4 sti $5
pat loc loc cii lol sti $1 <= 4 && $1>=$5 && $2==4
				leaving lol $4 sti $5
pat loc loc cii lil sti $1 <= 4 && $1>=$5 && $2==4
				leaving lil $4 sti $5
pat loc loc cii lol lof sti $1 <= 4 && $1>=$6 && $2==4
				leaving lol $4 lof $5 sti $6
pat loc loc cii lae sti $1 <= 4 && $1>=$5 && $2==4
				leaving lae $4 sti $5
pat loc loc cii loe sti $1 <= 4 && $1>=$5 && $2==4
				leaving loe $4 sti $5

pat loc loc cii stl $1==1 && $2==4 && inreg($4)==reg_any
with memory1+DD_REG
    kills regvar($4, reg_any), use_index %xreg==regvar($4, reg_any)
    gen	move_b %1, {dreg1, regvar($4,reg_any)}
#ifdef TBL68020
	extb_l	{LOCAL,$4}
#else TBL68020
	ext_w	{LOCAL,$4}
	ext_l	{LOCAL,$4}
#endif TBL68020

pat loc loc cii $1==2 && $2==4
with DD_REG		yields	{extend2, %1}
with exact memory2
uses reusing %1,DD_REG
    gen move %1, %a	yields	{extend2, %a}

pat loc loc cii $1==1 && $2==4
with DD_REG		yields	{extend1, %1}
with exact memory1
uses reusing %1,DD_REG
    gen move %1,%a	yields	{extend1, %a}

pat loc loc ciu $1==$2	/* skip this */
pat loc loc cui $1==$2	/* skip this */


/* The following rules should be handled by the peephole optimizer, I think */

pat loc dvu $1==2 && $2==4	leaving loc 1 sru 4
pat loc dvu $1==4 && $2==4	leaving loc 2 sru 4
pat loc dvu $1==8 && $2==4	leaving loc 3 sru 4
pat loc dvu $1==16 && $2==4	leaving loc 4 sru 4
pat loc dvu $1==32 && $2==4	leaving loc 5 sru 4
pat loc dvu $1==64 && $2==4	leaving loc 6 sru 4
pat loc dvu $1==128 && $2==4	leaving loc 7 sru 4
pat loc dvu $1==256 && $2==4	leaving loc 8 sru 4

pat loc dvi $1==2 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 1 sri 4

pat loc dvi $1==4 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 2 sri 4

pat loc dvi $1==8 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 3 sri 4

pat loc dvi $1==16 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 4 sri 4

pat loc dvi $1==32 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 5 sri 4

pat loc dvi $1==64 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 6 sri 4

pat loc dvi $1==128 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 7 sri 4

pat loc dvi $1==256 && $2==4
    with DD_REG
    gen	test %1
	bge {slabel,1f}
	add_l {const,$1-1},%1
	1: 			yields %1		leaving loc 8 sri 4
