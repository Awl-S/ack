"$Id$"
#define	SL	6
#define	SSL	"6"
    /* savsize is 6 because size of LB is 2 and size of z8000-PC is 4 */
#define NC	nocoercions:

/*********************************************************
** Back end tables for z8000				**
** Author: Jan Voors					**
**							**
** wordsize = 2 bytes, pointersize = 2 bytes.		**
**							**
** Register R13 is used as LB, RR14 is the normal	**
** z8000-stackpointer. Some global variables are used:	**
** - reghp     : the heap pointer			**
** - trpim     : trap ignore mask			**
** - trppc     : address of user defined trap handler	**
**							**
** Floating point arithmetic and constants are not	**
** implemented.						**
**							**
*********************************************************/

/*
 * (c) copyright 1983 by the Vrije Universiteit, Amsterdam, The Netherlands.
 *
 *          This product is part of the Amsterdam Compiler Kit.
 *
 * Permission to use, sell, duplicate or disclose this software must be
 * obtained in writing. Requests for such permissions may be sent to
 *
 *      Dr. Andrew S. Tanenbaum
 *      Wiskundig Seminarium
 *      Vrije Universiteit
 *      Postbox 7161
 *      1007 MC Amsterdam
 *      The Netherlands
 *
 */

EM_WSIZE = 2
EM_PSIZE = 2
EM_BSIZE = SL

TIMEFACTOR = 3/4

REGISTERS:
R0 = ("R0", 2), REG, B2REG.
R1 = ("R1", 2), REG, B2REG, XREG.
R2 = ("R2", 2), REG, B2REG, XREG.
R3 = ("R3", 2), REG, B2REG, XREG.
R4 = ("R4", 2), REG, B2REG, XREG.
R5 = ("R5", 2), REG, B2REG, XREG.
R6 = ("R6", 2), REG, B2REG, XREG.
R7 = ("R7", 2), REG, B2REG, XREG.
R8 = ("R8", 2), REG, XREG.
R9 = ("R9", 2), REG, XREG.
R10 = ("R10", 2), REG, XREG.
R11 = ("R11", 2), REG, XREG.
R12 = ("R12", 2), REG, XREG.
LB = ("R13", 2), localbase.

RR0 = ("RR0", 4, R0, R1), LWREG, LWB2REG.
RR2 = ("RR2", 4, R2, R3), LWREG, LWB2REG, LWXREG.
RR4 = ("RR4", 4, R4, R5), LWREG, LWB2REG, LWXREG.
RR6 = ("RR6", 4, R6, R7), LWREG, LWB2REG, LWXREG.
RR8 = ("RR8", 4, R8, R9), LWREG, LWXREG.
RR10 = ("RR10", 4, R10, R11), LWREG, LWXREG.

RQ0 = ("RQ0", 8, RR0, RR2), DLWREG.
RQ4 = ("RQ4", 8, RR4, RR6), DLWREG.
RQ8 = ("RQ8", 8, RR8, RR10), DLWREG.

/**/
TOKENS:
/* z8000-addressing-modes 'ra', 'ba' and 'bx' never used so far,
** so there are no tokens for them (yet).
*/
ir1 = { REGISTER lwxreg; }	2	cost=(0,2)	"*%[lwxreg]"
ir2 = { REGISTER lwxreg; }	2	cost=(0,2)	"*%[lwxreg]"
ir4 = { REGISTER lwxreg; }	4	cost=(0,5)	"*%[lwxreg]"
ir4_hi = { REGISTER lwreg; }	2

da1 = { STRING ind; }		2	cost=(4,4)	"%[ind]"
da2 = { STRING ind; }		2	cost=(4,4)	"%[ind]"
da4 = { STRING ind; }		4	cost=(4,7)	"%[ind]"

im2 = { INT num; }		2	cost=(2,2)	"$%[num]"
im4 = { INT num; }		4	cost=(4,5)	"$%[num]"
double = { STRING ind; }	4	cost=(4,5)	"$%[ind]"

x1 = { REGISTER xreg; INT ind; }   2    cost=(4,5)     "%[ind](%[xreg])"
x2 = { REGISTER xreg; INT ind; }   2    cost=(4,5)     "%[ind](%[xreg])"
x4 = { REGISTER xreg; INT ind; }   4    cost=(4,8)     "%[ind](%[xreg])"

ADDR_LOCAL	= { INT ind; }	   2
ADDR_EXTERNAL	= { STRING ind; }  2    cost=(2,3)     "$%[ind]"
regconst2	= { REGISTER xreg; INT ind; }	2

TOKENEXPRESSIONS:
REGS = REG + LWREG + DLWREG
SCR_REG    = REG * SCRATCH
SCR_XREG   = XREG * SCRATCH
SCR_LWREG  = LWREG * SCRATCH
SCR_DLWREG = DLWREG * SCRATCH
src1 = ir1 + da1 + x1
src2 = REG + ir2 + im2 + da2 + x2 + localbase + ADDR_EXTERNAL
src4 = LWREG + ir4 + im4 + da4 + x4 + double
indexed = x1 + x2 + x4
ind_access = ir1 + ir2 + ir4
da = da1 + da2 + da4
const2 = im2 + ADDR_EXTERNAL
const4 = im4 + double
allexceptcon = ALL - REGS - im2 - im4 - double - ADDR_LOCAL
							- ADDR_EXTERNAL

src2a = ir2 + da2 + x2
src4a = ir4 + da4 + x4
src2b = REG + im2 + localbase + ADDR_EXTERNAL
src4b = LWREG
src2c = REG + ir2 + da2 + x2

CODE:
/**/
/***************************************
********	GROUP 1		********
***************************************/

loc	| | | {im2, $1}		| |
ldc	| | allocate( LWREG )
	    move( {im2, highw(1)}, %[a.1] )
	    move( {im2, loww(1)}, %[a.2] )	| %[a]	| |
lol	| | | {x2, LB, $1}	| |
ldl	| | | {x4, LB, $1}	| |
loe	| | | {da2, $1}		| |
lde	| | | {da4, $1}		| |
lil	| | allocate( LWXREG )
	    move( {x2, LB, $1}, %[a.2] )
	    move( {im2, 0}, %[a.1] )		| {ir2,%[a]}	| |
lof	| XREG	| | {x2, %[1], $1}	| |
...	| NC regconst2	| | {x2, %[1.xreg], $1+%[1.ind]}	| |
...	| NC ADDR_EXTERNAL | | {da2, tostring($1)+"+"+%[1.ind]}	| |
...	| NC ADDR_LOCAL	| | {x2, LB, %[1.ind]+$1}	| |
ldf	| XREG	| | {x4, %[1], $1}	| |
...	| NC regconst2	| | {x4, %[1.xreg], $1+%[1.ind]}	| |
...	| NC ADDR_EXTERNAL | | {da4, tostring($1)+"+"+%[1.ind]}	| |
...	| NC ADDR_LOCAL	| | {x4, LB, %[1.ind]+$1}	| |
lal	| | | { ADDR_LOCAL, $1 }		| |
lae	| | | { ADDR_EXTERNAL, $1 }	| |
lxl $1==0	| | | LB		| |
lxl $1==1	| | | {x2, LB, SL}	| |
lxl $1==2	| | allocate( XREG = {x2, LB, SL} ) | {x2, %[a], SL}| |
lxl $1>2	| | allocate( XREG = {x2, LB, SL}, REG = {im2, $1-1} )
		    "1:\tld %[a], 6(%[a])"
		    "djnz %[b], 1b"
		    erase(%[a])  erase(%[b])  samecc	| %[a]	| |
lxa $1==0	| | | {ADDR_LOCAL, SL}	| |
lxa $1==1	| | allocate( XREG = {x2, LB, SL} )	|
					    {regconst2, %[a], SL} | |
lxa $1==2	| | allocate( XREG = {x2, LB, SL} )
		    move( {x2, %[a], SL }, %[a] )	|
					    {regconst2, %[a], SL} | |
lxa $1>2	| | allocate( XREG = {x2, LB, SL}, REG = {im2, $1-1} )
		    "1:\tld %[a], 6(%[a])"
		    "djnz %[b], 1b"
		    erase(%[a])  erase(%[b])  samecc	|
					    {regconst2, %[a], SL} | |
loi $1==1	| NC  regconst2	| | {x1, %[1.xreg], %[1.ind]}	| |
...		| NC  ADDR_LOCAL| | {x1, LB, %[1.ind]}	| |
...		| NC  ADDR_EXTERNAL	| | {da1, %[1.ind]}	| |
...		| src2	| allocate( %[1], LWXREG )
			  move( %[1], %[a.2] )
			  move( {im2, 0}, %[a.1] )
						| {ir1, %[a]}	| |
loi $1==2	| NC  regconst2	| | {x2, %[1.xreg], %[1.ind]}	| |
...		| NC  ADDR_LOCAL| | {x2, LB, %[1.ind]}	| |
...		| NC  ADDR_EXTERNAL	| | {da2, %[1.ind]}	| |
...		| src2	| allocate( %[1], LWXREG )
			  move( %[1], %[a.2] )
			  move( {im2, 0}, %[a.1] )
						| {ir2, %[a]}	| |
loi $1==4	| NC  regconst2	| | {x4, %[1.xreg], %[1.ind]}	| |
...		| NC  ADDR_LOCAL| | {x4, LB, %[1.ind]}	| |
...		| NC  ADDR_EXTERNAL	| | {da4, %[1.ind]}	| |
...		| src2	| allocate( %[1], LWXREG )
			  move( %[1], %[a.2] )
			  move( {im2, 0}, %[a.1] )
						| {ir4, %[a]}	| |
loi $1>4	| src2  STACK	| allocate( REG = {im2, $1/2} )
				  allocate( %[1], LWXREG )
				  move( %[1], %[b.2] )
				  move( {im2, 0}, %[b.1] )
				  "add %[b.2], $$$1-2"
				  "dec R15, $$2"
				  "lddr *RR14, *%[b], %[a]"
				  "inc R15, $$2"
				  erase(%[a])  erase(%[b])  nocc  | | |
lal loi $2==6	| STACK	| "push *RR14, $1+4(R13)"
			  "pushl *RR14, $1(R13)"	| | |
lal loi $2==8	| STACK	| "pushl *RR14, $1+4(R13)"
			  "pushl *RR14, $1(R13)"	| | |
lae loi $2==6	| STACK	| "push *RR14, $1+4"
			  "pushl *RR14, $1"	| | |
lae loi $2==8	| STACK	| "pushl *RR14, $1+4"
			  "pushl *RR14, $1"	| | |
los $1==2	| STACK	| "calr los2"		| | |
los !defined($1)| src2c STACK	| "cp %[1], $$2"
				  "jr NE, unknown"
				  "calr los2"		| | |
lpi	| | | {ADDR_EXTERNAL, $1}	| |
/**/
/***************************************
********	GROUP 2		********
***************************************/

stl	| src2b	| remove( x2, %[xreg]==LB && %[ind]==$1 )
		  remove( x4, %[xreg]==LB &&
				( %[ind]==$1-2 || %[ind]==$1 ))
		  remove( x1, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+1 ))
		  remove( indexed, %[xreg]!=LB )
		  remove( ind_access )
		  move( %[1], {x2, LB, $1} )	| | |
ste	| src2b	| remove( da )
		  remove( indexed, %[xreg]!=LB )
		  remove( ind_access )
		  move( %[1], {da2, $1} )		| | |
sil	| src2b	| remove( allexceptcon )
		  allocate( LWXREG )
		  move( {x2, LB, $1}, %[a.2] )
		  move( {im2, 0}, %[a.1] )
		  move( %[1], {ir2, %[a]} )		| | |
stf	| regconst2  src2b	|
		    remove( allexceptcon )
		    move( %[2], {x2, %[1.xreg], $1+%[1.ind]} ) | | |
...	| ADDR_EXTERNAL  src2b	|
		    remove( allexceptcon )
		    move( %[2], {da2, tostring($1)+"+"+%[1.ind]} ) | | |
sti $1==1	| regconst2  const2	| remove( allexceptcon )
			move( %[2], {x1, %[1.xreg], %[1.ind]} )	| | |
...		| regconst2  B2REG	| remove( allexceptcon )
			move( %[2], {x1, %[1.xreg], %[1.ind]} )	| | |
...		| NC ADDR_LOCAL  const2	| remove( allexceptcon )
			move( %[2], {x1, LB, %[1.ind]} )  | | |
...		| ADDR_LOCAL  B2REG	| remove( allexceptcon )
			move( %[2], {x1, LB, %[1.ind]} )  | | |
...		| NC ADDR_EXTERNAL  const2	| remove( allexceptcon )
			move( %[2], {da1, %[1.ind]} )	| | |
...		| ADDR_EXTERNAL  B2REG	| remove( allexceptcon )
			move( %[2], {da1, %[1.ind]} )	| | |
...		| src2  const2	| remove( allexceptcon )
				  allocate( %[1], LWXREG )
				  move( %[1], %[a.2] )
				  move( {im2, 0}, %[a.1] )
				  move( %[2], {ir1, %[a]} )	| | |
...		| src2  B2REG	| remove( allexceptcon )
				  allocate( %[1], LWXREG )
				  move( %[1], %[a.2] )
				  move( {im2, 0}, %[a.1] )
				  move( %[2], {ir1, %[a]} )	| | |
sti $1==2	| regconst2  src2b	| remove( allexceptcon )
			move( %[2], {x2, %[1.xreg], %[1.ind]} )	| | |
...		| ADDR_LOCAL  src2b	| remove( allexceptcon )
			move( %[2], {x2, LB, %[1.ind]} )  | | |
...		| ADDR_EXTERNAL  src2b	| remove( allexceptcon )
			move( %[2], {da2, %[1.ind]} )	| | |
...		| src2  src2b	| remove( allexceptcon )
				  allocate( %[1], LWXREG )
				  move( %[1], %[a.2] )
				  move( {im2, 0}, %[a.1] )
				  move( %[2], {ir2, %[a]} )	| | |
sti $1==4	| regconst2  src4b	| remove( allexceptcon )
			move( %[2], {x4, %[1.xreg], %[1.ind]} )	| | |
...		| ADDR_LOCAL  src4b	| remove( allexceptcon )
			move( %[2], {x4, LB, %[1.ind]} )  | | |
...		| ADDR_EXTERNAL  src4b	| remove( allexceptcon )
			move( %[2], {da4, %[1.ind]} )	| | |
...		| src2  src4b	| remove( allexceptcon )
				  allocate( %[1], LWXREG )
				  move( %[1], %[a.2] )
				  move( {im2, 0}, %[a.1] )
				  move( %[2], {ir4, %[a]} )	| | |
sti $1>4	| src2  STACK	|
			allocate( REG = {im2, $1/2} )
			allocate( %[1], LWXREG )
			move( %[1], %[b.2] )
			move( {im2, 0}, %[b.1] )
			"ldir *%[b], *RR14, %[a]"
			erase(%[a])  erase(%[b])  nocc	| | |
lal sti $2>4 && $2<=8	| NC src2b	| | %[1]	|
				stl $1 lal $1+2 sti $2-2	|
...			| | | {ADDR_LOCAL, $1}	| sti $2	|
sts $1==2	| STACK	| "calr sts2"		| | |
sts !defined($1)| src2c STACK	| "cp %[1], $$2"
				  "jr NE, unknown"
				  "calr sts2"		| | |
sdl	| src4b	| remove( x2, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+2 ))
		  remove( x4, %[xreg]==LB &&
				( %[ind]>=$1-2 && %[ind]<=$1+2 ))
		  remove( x1, %[xreg]==LB &&
				( %[ind]>=$1 && %[ind]<=$1+3 ))
		  remove( indexed, %[xreg]!=LB )
		  remove( ind_access )
		  move( %[1], {x4, LB, $1} )	| | |
sde	| src4b	| remove( da )
		  remove( indexed, %[xreg]!=LB )
		  remove( ind_access )
		  move( %[1], {da4, $1} )		| | |
sdf	| regconst2  src4b	|
		    remove( allexceptcon )
		    move( %[2], {x4, %[1.xreg], $1+%[1.ind]} ) | | |
...	| ADDR_EXTERNAL  src4b	|
		    remove( allexceptcon )
		    move( %[2], {da4, tostring($1)+"+"+%[1.ind]} ) | | |
/**/
/***************************************
********	GROUP 3		********
***************************************/

adi $1==2	| NC SCR_XREG  im2	| |
				{regconst2, %[1], %[2.num]}	| |
...		| NC SCR_XREG  ADDR_LOCAL	|
			"add %[1], R13"
			erase(%[1])	|
				{regconst2, %[1], %[2.ind]}	| |
...		| NC REG  ADDR_LOCAL	|
			allocate( XREG )
			"ld %[a], R13"
			"add %[a], %[1]"
			erase(%[a])	|
				{regconst2, %[a], %[2.ind]}	| |
...		| NC SCR_XREG  regconst2	|
			"add %[1], %[2.xreg]"
			erase(%[1])	|
				{regconst2, %[1], %[2.ind]}	| |
...		| NC im2  ADDR_LOCAL	| |
			{ADDR_LOCAL, %[1.num]+%[2.ind]}	| |
...		| NC src2  im2+ADDR_LOCAL	|
			allocate( %[1], XREG = %[1] )	|
				%[2] %[a]	| adi 2	|
...		| NC src2  regconst2	|
			"add %[2.xreg], %[1]"
			erase(%[2.xreg])	| %[2]	| |
...		| NC regconst2  im2	| |
			{regconst2, %[1.xreg], %[2.num]+%[1.ind]}    | |
...		| NC regconst2  ADDR_LOCAL	|
			"add %[1.xreg], R13"
			erase(%[1.xreg])	|
				{regconst2, %[1.xreg],
					       %[2.ind]+%[1.ind]}    | |
...		| NC regconst2  regconst2	|
			"add %[1.xreg],%[2.xreg]"
			erase(%[1.xreg])	|
				{regconst2, %[1.xreg],
					       %[2.ind]+%[1.ind]}    | |
...		| NC regconst2  src2-im2	|
			"add %[1.xreg], %[2]"
			erase(%[1.xreg])	| %[1]	| |
...		| NC ADDR_LOCAL  regconst2	|
			"add %[2.xreg], R13"
			erase(%[2.xreg])	|
				{regconst2, %[2.xreg],
					       %[1.ind]+%[2.ind]}    | |
...		| NC ADDR_LOCAL  src2	| | %[1] %[2]	| adi 2	|
...		| NC SCR_REG  src2-im2	| "add %[1], %[2]"
					  erase(%[1])
					  setcc(%[1])	| %[1]	| |
...		| src2  SCR_REG		| "add %[2], %[1]"
					  erase(%[2])
					  setcc(%[2])	| %[2]	| |
adi $1==4	| src4  SCR_LWREG	|
				  "addl %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,8)+%[1]
...		| SCR_LWREG  src4	|
				  "addl %[1], %[2]"
				  erase(%[1])
				  setcc(%[1])	| %[1]	| | (2,8)+%[2]
sbi $1==2	| src2  SCR_REG	| "sub %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,4)+%[1]
...		| SCR_REG  src2	| "sub %[1], %[2]"
				  erase(%[1])
					| %[1]	| ngi 2	| (2,4)+%[2]
sbi $1==4	| src4  SCR_LWREG	|
				  "subl %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,8)+%[1]
...		| SCR_LWREG  src4	|
				  "subl %[1], %[2]"
				  erase(%[1])
					| %[1]	| ngi 4	| (2,8)+%[2]
mli $1==2	| src2  src2	| allocate( %[2], LWREG )
				  move( %[2], %[a.2] )
				  "mult %[a], %[1]"
				  erase(%[a])
				  setcc(%[a.2])		| %[a.2]  | |
mli $1==4	| src4  src4	| allocate( %[2], DLWREG )
				  move( %[2], %[a.2] )
				  "multl %[a], %[1]"
				  erase(%[a])
				  setcc(%[a.2])		| %[a.2]  | |
dvi $1==2	| src2  src2	| allocate( %[2], LWREG )
				  move( %[2], %[a.2] )
				  "exts %[a]"
				  "div %[a], %[1]"
				  erase(%[a])
				  nocc			| %[a.2]  | |
dvi $1==4	| src4  src4	| allocate( %[2], DLWREG )
				  move( %[2], %[a.2] )
				  "extsl %[a]"
				  "divl %[a], %[1]"
				  erase(%[a])
				  nocc			| %[a.2]  | |
rmi $1==2	| src2  src2	| allocate( %[2], LWREG )
				  move( %[2], %[a.2] )
				  "exts %[a]"
				  "div %[a], %[1]"
				  erase(%[a])
				  nocc			| %[a.1]  | |
rmi $1==4	| src4  src4	| allocate( %[2], DLWREG )
				  move( %[2], %[a.2] )
				  "extsl %[a]"
				  "divl %[a], %[1]"
				  erase(%[a])
				  nocc			| %[a.1]  | |
ngi $1==2	| SCR_REG	| "neg %[1]"
				  erase(%[1])
				  setcc(%[1])	| %[1]	| | (2,7)
ngi $1==4	| src4		| allocate( LWREG = {im4, 0} )
				  "subl %[a], %[1]"
				  erase(%[a])
				  setcc(%[a])	| %[a]	| | (2,8)+%[1]
sli $1==2	| im2 SCR_REG	| "sla %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,0)
...		| REG SCR_REG	| "sda %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
sli $1==4	| im2 SCR_LWREG	| "slal %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,0)
...		| REG SCR_LWREG	| "sdal %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
sri $1==2	| im2 SCR_REG	| allocate( REG = {im2, 0-%[1.num]} )
				  "sda %[2], %[a]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
...		| REG SCR_REG	| "neg %[1]"
				  "sda %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (6,9)
sri $1==4	| im2 SCR_LWREG	| allocate( REG = {im2, 0-%[1.num]} )
				  "sdal %[2], %[a]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
...		| REG SCR_LWREG	| "neg %[1]"
				  "sdal %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (6,9)
lol loc adi stl $1==$4 && $3==2 && $2>=0-16 && $2<=16	| | | |
				loc $2 lol $1 adi $3 stl $4	|
loc lol adi stl $2==$4 && $3==2 && $1>0 && $1<=16	| |
				remove( x2, %[xreg]==LB && %[ind]==$2 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$2-2 || %[ind]==$2 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$2 || %[ind]==$2+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"inc $2(R13), $$$1"
				setcc({x2, LB, $2})	| | |
loc lol adi stl $2==$4 && $3==2 && $1<0 && $1>=0-16	| |
				remove( x2, %[xreg]==LB && %[ind]==$2 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$2-2 || %[ind]==$2 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$2 || %[ind]==$2+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"dec $2(R13), $$0-$1"
				setcc({x2, LB, $2})	| | |
loe loc adi ste $1==$4 && $3==2 && $2>=0-16 && $2<=16	| | | |
				loc $2 loe $1 adi $3 ste $4	|
loc loe adi ste $2==$4 && $3==2 && $1>0 && $1<=16	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"inc $2, $$$1"
				setcc({da2, $2})	| | |
loc loe adi ste $2==$4 && $3==2 && $1<0 && $1>=0-16	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"dec $2, $$0-$1"
				setcc({da2, $2})	| | |
lil loc adi sil $1==$4 && $3==2 && $2>=0-16 && $2<=16	| | | |
				loc $2 lil $1 adi $3 sil $4	|
loc lil adi sil $2==$4 && $3==2 && $1>0 && $1<=16	| |
				remove( allexceptcon )
				allocate( LWXREG )
				move( {x2, LB, $2}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"inc *%[a], $$$1"
				setcc({ir2, %[a]})	| | |
loc lil adi sil $2==$4 && $3==2 && $1<0 && $1>=0-16	| |
				remove( allexceptcon )
				allocate( LWXREG )
				move( {x2, LB, $2}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"dec *%[a], $$0-$1"
				setcc({ir2, %[a]})	| | |
lol loc sbi stl $1==$4 && $3==2 && $2>0 && $2<=16	| |
				remove( x2, %[xreg]==LB && %[ind]==$1 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$1-2 || %[ind]==$1 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$1 || %[ind]==$1+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"dec $1(R13), $$$2"
				setcc({x2, LB, $1})	| | |
lol loc sbi stl $1==$4 && $3==2 && $2<0 && $2>=0-16	| |
				remove( x2, %[xreg]==LB && %[ind]==$1 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$1-2 || %[ind]==$1 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$1 || %[ind]==$1+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"inc $1(R13), $$0-$2"
				setcc({x2, LB, $1})	| | |
loe loc sbi ste $1==$4 && $3==2 && $2>0 && $2<=16	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"dec $1, $$$2"
				setcc({da2, $1})	| | |
loe loc sbi ste $1==$4 && $3==2 && $2<0 && $2>=0-16	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"inc $1, $$0-$2"
				setcc({da2, $1})	| | |
lil loc sbi sil $1==$4 && $3==2 && $2>0 && $2<=16	| |
				remove( allexceptcon )
				allocate( LWXREG )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"dec *%[a], $$$2"
				setcc({ir2, %[a]})	| | |
lil loc sbi sil $1==$4 && $3==2 && $2<0 && $2>=0-16	| |
				remove( allexceptcon )
				allocate( LWXREG )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"inc *%[a], $$0-$2"
				setcc({ir2, %[a]})	| | |
lol ngi stl $1==$3 && $2==2	| |
				remove( x2, %[xreg]==LB && %[ind]==$1 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$1-2 || %[ind]==$1 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$1 || %[ind]==$1+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				remove( allexceptcon )
				"neg $1(R13)"
				setcc({x2, LB, $1})	| | |
loe ngi ste $1==$3 && $2==2	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"neg $1"
				setcc({da2, $1})	| | |
lil ngi sil $1==$3 && $2==2	| |
				remove( allexceptcon )
				allocate( LWXREG )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"neg *%[a]"
				setcc({ir2, %[a]})	| | |
loc sli $1>=0 && $1<=16 && $2==2	| SCR_REG	|
					"sla %[1], $$$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
loc sli $1>=0 && $1<=32 && $2==4	| SCR_LWREG	|
					"slal %[1], $$$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
loc sri $1>=0 && $1<=16 && $2==2	| SCR_REG	|
					"sra %[1], $$-$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
loc sri $1>=0 && $1<=32 && $2==4	| SCR_LWREG	|
					"sral %[1], $$-$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
loc sru $1>=0 && $1<=16 && $2==2	| SCR_REG	|
					"srl %[1], $$-$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
loc sru $1>=0 && $1<=32 && $2==4	| SCR_LWREG	|
					"srll %[1], $$-$1"
					erase(%[1])
					setcc(%[1])	| %[1]	| |
/**/
/***************************************
********	GROUP 4		********
***************************************/
/*	adu = adi
**	sbu = sbi
**	mlu = mli
**	slu = sli
*/

adu	| | | | adi $1	|
sbu	| | | | sbi $1	|
mlu	| | | | mli $1	|
slu	| | | | sli $1	|
dvu $1==2	| STACK	| "calr dvu2"	| R1	| |
dvu $1==4	| STACK	| "calr dvu4"	| R3 R2	| |
rmu $1==2	| STACK	| "calr rmu2"	| R0	| |
rmu $1==4	| STACK	| "calr rmu4"	| R1 R0	| |
sru $1==2	| im2 SCR_REG	| allocate( REG = {im2, 0-%[1.num]} )
				  "sdl %[2], %[a]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
...		| REG SCR_REG	| "neg %[1]"
				  "sdl %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (6,9)
sru $1==4	| im2 SCR_LWREG	| allocate( REG = {im2, 0-%[1.num]} )
				  "sdll %[2], %[a]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (4,2)
...		| REG SCR_LWREG	| "neg %[1]"
				  "sdll %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (6,9)
/**/
/***************************************
********	GROUP 6		********
***************************************/

adp	| SCR_XREG	| | {regconst2, %[1], $1}	| |
...	| NC regconst2	| | {regconst2, %[1.xreg], $1+%[1.ind]}	| |
...	| NC ADDR_LOCAL	| | {ADDR_LOCAL, %[1.ind]+$1 }	| |
...	| NC ADDR_EXTERNAL | | {ADDR_EXTERNAL,
				   tostring($1)+"+"+%[1.ind]}	| |
lil adp sil $1==$3 && $2>0 && $2<=16	| | allocate( LWXREG )
					    remove( allexceptcon )
					    move( {x2, LB, $1}, %[a.2] )
					    move( {im2, 0}, %[a.1] )
					    "inc *%[a], $$$2"
					    setcc({ir2, %[a]})	| | |
lil adp sil $1==$3 && $2<0 && $2>=0-16	| | allocate( LWXREG )
					    remove( allexceptcon )
					    move( {x2, LB, $1}, %[a.2] )
					    move( {im2, 0}, %[a.1] )
					    "dec *%[a], $$0-$2"
					    setcc({ir2, %[a]})	| | |
lil adp dup sil adp $1==$4 && $3==2 && $2==1 && $5==0-1	| |
				allocate( LWXREG, XREG )
				remove( allexceptcon )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"ld %[b], *%[a]"
				"inc *%[a]"  | {regconst2, %[b], 0} | |
				   /* because the next EM-instruction
				   ** will be `loi'.
				   */
lil adp dup sil $1==$4 && $3==2 && $2==1	| |
				allocate( LWXREG )
				remove( allexceptcon )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"inc *%[a]"
				setcc({ir2, %[a]})	| {ir2,%[a]} | |
lol dup adp stl $1==$4 && $2==2 && $3>0 && $3<=16	| |
			allocate( REG = {x2, LB, $1} )
			remove( x2, %[xreg]==LB && %[ind]==$1 )
			remove( x4, %[xreg]==LB &&
				( %[ind]==$1-2 || %[ind]==$1 ))
			remove( x1, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+1 ))
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"inc $1(R13), $$$3"
			setcc({x2, LB, $1})		| %[a]	| |
lol dup adp stl $1==$4 && $2==2 && $3<0 && $3>=0-16	| |
			allocate( REG = {x2, LB, $1} )
			remove( x2, %[xreg]==LB && %[ind]==$1 )
			remove( x4, %[xreg]==LB &&
				( %[ind]==$1-2 || %[ind]==$1 ))
			remove( x1, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+1 ))
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"dec $1(R13), $$0-$3"
			setcc({x2, LB, $1})		| %[a]	| |
loe dup adp ste $1==$4 && $2==2 && $3>0 && $3<=16	| |
			allocate( REG = {da2, $1} )
			remove( da )
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"inc $1, $$$3"
			setcc({da2, $1})		| %[a]	| |
loe dup adp ste $1==$4 && $2==2 && $3<0 && $3>=0-16	| |
			allocate( REG = {da2, $1} )
			remove( da )
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"dec $1, $$0-$3"
			setcc({da2, $1})		| %[a]	| |
lol adp stl $1==$3 && $2>0 && $2<=16	| |
			remove( x2, %[xreg]==LB && %[ind]==$1 )
			remove( x4, %[xreg]==LB &&
				( %[ind]==$1-2 || %[ind]==$1 ))
			remove( x1, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+1 ))
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"inc $1(R13), $$$2"
			setcc({x2, LB, $1})		| | |
lol adp stl $1==$3 && $2<0 && $2>=0-16	| |
			remove( x2, %[xreg]==LB && %[ind]==$1 )
			remove( x4, %[xreg]==LB &&
				( %[ind]==$1-2 || %[ind]==$1 ))
			remove( x1, %[xreg]==LB &&
				( %[ind]==$1 || %[ind]==$1+1 ))
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"dec $1(R13), $$0-$2"
			setcc({x2, LB, $1})		| | |
loe adp ste $1==$3 && $2>0 && $2<=16	| |
			remove( da )
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"inc $1, $$$2"
			setcc({da2, $1})		| | |
loe adp ste $1==$3 && $2<0 && $2>=0-16	| |
			remove( da )
			remove( indexed, %[xreg]!=LB )
			remove( ind_access )
			"dec $1, $$0-$2"
			setcc({da2, $1})		| | |
ads $1==2	| | | | adi $1	|
ads $1==4	| | | | adi $1	|
sbs $1==2	| | | | sbi $1	|
sbs $1==4	| | | | sbi $1	|
/**/
/***************************************
********	GROUP 7		********
***************************************/

inc	| SCR_REG	| "inc %[1]"
			  erase(%[1])  setcc(%[1])	| %[1]	| |
lil inc sil $1==$3	| | allocate( LWXREG )
			    remove( allexceptcon )
			    move( {x2, LB, $1}, %[a.2] )
			    move( {im2, 0}, %[a.1] )
			    "inc *%[a]"
			    setcc({ir2, %[a]})		| | |
dec	| SCR_REG	| "dec %[1]"
			  erase(%[1])  setcc(%[1])	| %[1]	| |
lil dec sil $1==$3	| | allocate( LWXREG )
			    remove( allexceptcon )
			    move( {x2, LB, $1}, %[a.2] )
			    move( {im2, 0}, %[a.1] )
			    "dec *%[a]"
			    setcc({ir2, %[a]})		| | |
lil dec dup sil $1==$4 && $3==2	| | allocate( LWXREG )
				    remove( allexceptcon )
				    move( {x2, LB, $1}, %[a.2] )
				    move( {im2, 0}, %[a.1] )
				    "dec *%[a]"
				    setcc({ir2, %[a]})	| {ir2,%[a]} | |
inl	| | remove( x2, %[xreg]==LB && %[ind]==$1 )
	    remove( x4, %[xreg]==LB && ( %[ind]==$1-2 || %[ind]==$1 ) )
	    remove( x1, %[xreg]==LB && ( %[ind]==$1 || %[ind]==$1+1 ))
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "inc $1(R13)"
	    setcc({x2, LB, $1})		| | |
del	| | remove( x2, %[xreg]==LB && %[ind]==$1 )
	    remove( x4, %[xreg]==LB && ( %[ind]==$1-2 || %[ind]==$1 ) )
	    remove( x1, %[xreg]==LB && ( %[ind]==$1 || %[ind]==$1+1 ))
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "dec $1(R13)"
	    setcc({x2, LB, $1})		| | |
zrl	| | remove( x2, %[xreg]==LB && %[ind]==$1 )
	    remove( x4, %[xreg]==LB && ( %[ind]==$1-2 || %[ind]==$1 ) )
	    remove( x1, %[xreg]==LB && ( %[ind]==$1 || %[ind]==$1+1 ))
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "clr $1(R13)"
	    samecc		| | |
ine	| | remove( da )
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "inc $1"
	    setcc({da2, $1})	| | |
dee	| | remove( da )
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "dec $1"
	    setcc({da2, $1})	| | |
zre	| | remove( da )
	    remove( indexed, %[xreg]!=LB )
	    remove( ind_access )
	    "clr $1"
	    samecc		| | |
zer $1==2	| | | {im2, 0}	| |
zer $1==4	| | | {im4, 0}	| |
zer $1==6	| | | {im4, 0} {im2, 0}	| |
zer $1==8	| | | {im4, 0} {im4, 0}	| |
zer $1>8	| | remove( ALL )
		    allocate( REG = {im2, $1/2} )   /*nr of words*/
		    "1:\tpush *RR14, $$0"
		    "djnz %[a], 1b"
		    erase(%[a])  samecc		| | |
zer !defined($1)| SCR_REG	| remove( ALL )
				  "sra %[1]"
				  "1:\tpush *RR14, $$0"
				  "djnz %[1], 1b"
				  erase(%[1])   nocc	| | |
/**/
/***************************************
********	GROUP 8		********
***************************************/

cii	| STACK	| "calr cii"	| | |
loc loc cii $1==1 && $2==2	| NC src1	|
			allocate( %[1], B2REG = %[1] )	| %[a]	| |
...	| src2	| allocate( %[1], REG = %[1] )
		  "extsb %[a]"
		  erase(%[a])  samecc	| %[a]	| |
loc loc cii $1==1 && $2==4	| NC src1	|
			allocate( %[1], LWB2REG )
			move( %[1], %[a.2] )
			"exts %[a]"
			samecc		| %[a]	| |
...	| src2	| allocate( %[1], LWREG )
		  move( %[1], %[a.2] )
		  "exts %[a]"
		  samecc		| %[a]	| |
loc loc cii $1==2 && $2==4	| src2	| allocate( %[1], LWREG )
					  move( %[1], %[a.2] )
		  			  "exts %[a]"
		  			  samecc	| %[a]	| |
loc loc loc cii $1>=0 && $2==2 && $3==4	| | | | loc $1 loc 0	|
loc loc loc cii $1< 0 && $2==2 && $3==4	| | | | loc $1 loc 0-1	|
loc loc cii $1==4 && $2==2	| src2  src2	| | %[2]	| |
loc loc cuu $1==2 && $2==4	| | | {im2, 0}	| |
loc loc cuu $1==4 && $2==2	| src2	| | | |
cuu	| STACK	| "calr cuu"	| | |
ciu	| | | | cuu	|
cui	| | | | cuu	|
/**/
/***************************************
********	GROUP 9		********
***************************************/

and $1==2	| SCR_REG  src2	| "and %[1], %[2]"
				  erase(%[1])
				  setcc(%[1])	| %[1]	| | (2,4)+%[2]
...		| src2  SCR_REG	| "and %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,4)+%[1]
and $1>2	| | remove( ALL )
		    allocate( LWXREG, REG, REG = {im2, $1/2} )
		    "ldl %[a], RR14"
		    "addl %[a], $$$1"
		    "1:\tpop %[b], *RR14"
		    "and %[b], *%[a]"
		    "ld *%[a], %[b]"
		    "inc %[a.2], $$2"
		    "djnz %[c], 1b"
		    erase(%[c])  nocc	| | |
and !defined($1)| SCR_REG	| remove( ALL )
				  allocate( LWXREG, REG )
				  "ldl %[a], RR14"
				  "addl %[a], $$$1"
				  "sra %[1]"
				  "1:\tpop %[b], *RR14"
				  "and %[b], *%[a]"
				  "ld *%[a], %[b]"
				  "inc %[a.2], $$2"
				  "djnz %[1], 1b"
				  erase(%[1])  nocc	| | |
ior $1==2	| SCR_REG  src2	| "or %[1], %[2]"
				  erase(%[1])
				  setcc(%[1])	| %[1]	| | (2,4)+%[2]
...		| src2  SCR_REG	| "or %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,4)+%[1]
ior $1>2	| | remove( ALL )
		    allocate( LWXREG, REG, REG = {im2, $1/2} )
		    "ldl %[a], RR14"
		    "addl %[a], $$$1"
		    "1:\tpop %[b], *RR14"
		    "or %[b], *%[a]"
		    "ld *%[a], %[b]"
		    "inc %[a.2], $$2"
		    "djnz %[c], 1b"
		    erase(%[c])  nocc	| | |
ior !defined($1)| SCR_REG	| remove( ALL )
				  allocate( LWXREG, REG )
				  "ldl %[a], RR14"
				  "addl %[a], $$$1"
				  "sra %[1]"
				  "1:\tpop %[b], *RR14"
				  "or %[b], *%[a]"
				  "ld *%[a], %[b]"
				  "inc %[a.2], $$2"
				  "djnz %[1], 1b"
				  erase(%[1])  nocc	| | |
xor $1==2	| SCR_REG  src2	| "xor %[1], %[2]"
				  erase(%[1])
				  setcc(%[1])	| %[1]	| | (2,4)+%[2]
...		| src2  SCR_REG	| "xor %[2], %[1]"
				  erase(%[2])
				  setcc(%[2])	| %[2]	| | (2,4)+%[1]
xor $1>2	| | remove( ALL )
		    allocate( LWXREG, REG, REG = {im2, $1/2} )
		    "ldl %[a], RR14"
		    "addl %[a], $$$1"
		    "1:\tpop %[b], *RR14"
		    "xor %[b], *%[a]"
		    "ld *%[a], %[b]"
		    "inc %[a.2], $$2"
		    "djnz %[c], 1b"
		    erase(%[c])  nocc	| | |
xor !defined($1)| SCR_REG	| remove( ALL )
				  allocate( LWXREG, REG )
				  "ldl %[a], RR14"
				  "addl %[a], $$$1"
				  "sra %[1]"
				  "1:\tpop %[b], *RR14"
				  "xor %[b], *%[a]"
				  "ld *%[a], %[b]"
				  "inc %[a.2], $$2"
				  "djnz %[1], 1b"
				  erase(%[1])  nocc	| | |
com $1==2	| SCR_REG	| "com %[1]"
				  erase(%[1])
				  setcc(%[1])		| %[1]	| |
com defined($1)	| STACK	| allocate( LWXREG, REG = {im2, $1/2} )
			  "ldl %[a], RR14"
			  "1:\tcom *%[a]"
			  "inc %[a.2], $$2"
			  "djnz %[b], 1b"
			  erase(%[b])  nocc	| | |
com !defined($1)| SCR_REG STACK	| allocate( LWXREG )
				  "ldl %[a], RR14"
				  "1:\tcom *%[a]"
				  "inc %[a.2], $$2"
				  "djnz %[1], 1b"
				  erase(%[1])  nocc	| | |
lil and sil $1==$3 && $2==2	| SCR_REG	|
					allocate( LWXREG )
					remove( allexceptcon )
					move( {x2, LB, $1}, %[a.2] )
					move( {im2, 0}, %[a.1] )
					"and %[1], *%[a]"
					"ld *%[a], %[1]"	| | |
lil ior sil $1==$3 && $2==2	| SCR_REG	|
					allocate( LWXREG )
					remove( allexceptcon )
					move( {x2, LB, $1}, %[a.2] )
					move( {im2, 0}, %[a.1] )
					"or %[1], *%[a]"
					"ld *%[a], %[1]"	| | |
lil xor sil $1==$3 && $2==2	| SCR_REG	|
					allocate( LWXREG )
					remove( allexceptcon )
					move( {x2, LB, $1}, %[a.2] )
					move( {im2, 0}, %[a.1] )
					"xor %[1], *%[a]"
					"ld *%[a], %[1]"	| | |
lol com stl $1==$3 && $2==2	| |
				remove( x2, %[xreg]==LB && %[ind]==$1 )
				remove( x4, %[xreg]==LB &&
					( %[ind]==$1-2 || %[ind]==$1 ))
				remove( x1, %[xreg]==LB &&
					( %[ind]==$1 || %[ind]==$1+1 ))
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				remove( allexceptcon )
				"com $1(R13)"
				setcc({x2, LB, $1})	| | |
loe com ste $1==$3 && $2==2	| |
				remove( da )
				remove( indexed, %[xreg]!=LB )
				remove( ind_access )
				"com $1"
				setcc({da2, $1})	| | |
lil com sil $1==$3 && $2==2	| |
				allocate( LWXREG )
				remove( allexceptcon )
				move( {x2, LB, $1}, %[a.2] )
				move( {im2, 0}, %[a.1] )
				"com *%[a]"
				setcc({ir2, %[a]})	| | |
rol $1==2	| SCR_REG  SCR_REG	| "1:\trl %[2]"
					  "djnz %[1], 1b"
					  erase(%[2])
					  setcc(%[2])	| %[2]	| |
ror $1==2	| SCR_REG  SCR_REG	| "1:\trr %[2]"
					  "djnz %[1], 1b"
					  erase(%[2])
					  setcc(%[2])	| %[2]	| |
/**/
/***************************************
********	GROUP 10	********
***************************************/

inn $1==2	| REG  SCR_REG	| allocate( REG = {im2, 0} )
				  "cp %[1], $$15"
				  "jr UGT, 1f"
				  "bit %[2], %[1]"
				  "tcc NE, %[a]\n1:"
				  erase(%[a])  nocc	| %[a]	| |
inn defined($1)	| src2  STACK	| move( %[1], R1 )
				  move( {im2, $1}, R2 )
				  "calr inn"
				  erase(R1)
				  erase(R2)	| R0	| |
inn !defined($1)| src2  src2  STACK	| move( %[1], R2 )
					  move( %[2], R1 )
					  "calr inn"
					  erase(R1)
					  erase(R2)	| R0	| |
loc inn $2==2 && $1==0	| SCR_REG	|
			"and %[1], $$1"
			erase(%[1])  setcc(%[1])	| %[1]	| |
loc inn $2==2 && $1==1	| SCR_REG	|
			"srl %[1]"
			"and %[1], $$1"
			erase(%[1])  setcc(%[1])	| %[1]	| |
loc inn $2==2 && $1>1 && $1<=16	| SCR_REG	|
			"srl %[1], $$%(0-$1%)"
			"and %[1], $$1"
			erase(%[1])  setcc(%[1])	| %[1]	| |
loc inn zeq $2==2	| | | {im2, 1<<$1}	| and 2 zeq $3	|
inn zeq $1==2	| REG	| allocate( REG = {im2, 1} )
			  "sdl %[a], %[1]"
			  erase(%[a])
			  setcc(%[a])	| %[a]	| and 2 zeq $2	|
loc inn zne $2==2	| | | {im2, 1<<$1}	| and 2 zne $3	|
inn zne $1==2	| REG	| allocate( REG = {im2, 1} )
			  "sdl %[a], %[1]"
			  erase(%[a])
			  setcc(%[a])	| %[a]	| and 2 zne $2	|
set $1==2	| REG	| allocate( REG = {im2, 0} )
			  "cp %[1], $$15"
			  "jr ULE, 1f"
			  "push *RR14, $$ESET"
			  "calr trp"
			  "jr 2f"
			  "1:\tset %[a], %[1]\n2:"
			  erase(%[a])  nocc	| %[a]	| |
set defined($1)	| src2  STACK	| move( %[1], R1 )
				  move( {im2, $1}, R0 )
				  "calr xset"
				  erase(R0)
				  erase(R1)		| | |
set !defined($1)| src2  src2  STACK	| move( %[1], R0 )
					  move( %[2], R1 )
					  "calr xset"
					  erase(R0)
					  erase(R1)		| | |
/**/
/***************************************
********	GROUP 11	********
***************************************/

aar $1==2	| src2  src2  STACK	| move( %[1], R1 )
					  move( %[2], R3 )
					  "calr aar"
					  erase(R1)
					  erase(R3)		| | |
aar !defined($1)| src2c  src2  src2  STACK	| move( %[2], R1 )
						  move( %[3], R3 )
						  "cp %[1], $$2"
						  "jr NE, unknown"
						  "calr aar"
						  erase(R1)
						  erase(R3)	| | |
sar $1==2	| src2  src2  STACK	| move( %[1], R1 )
					  move( %[2], R3 )
					  "calr sar"
					  erase(R1)
					  erase(R3)		| | |
sar !defined($1)| src2c  src2  src2  STACK	| move( %[2], R1 )
						  move( %[3], R3 )
						  "cp %[1], $$2"
						  "jr NE, unknown"
						  "calr sar"
						  erase(R1)
						  erase(R3)	| | |
lar $1==2	| src2  src2  STACK	| move( %[1], R1 )
					  move( %[2], R3 )
					  "calr lar"
					  erase(R1)
					  erase(R3)		| | |
lar !defined($1)| src2c  src2  src2  STACK	| move( %[2], R1 )
						  move( %[3], R3 )
						  "cp %[1], $$2"
						  "jr NE, unknown"
						  "calr lar"
						  erase(R1)
						  erase(R3)	| | |
lae aar $2==2 && rom(1,3)==1 && rom(1,1)==0	| | | | adi 2	|
lae aar $2==2 && rom(1,3)==1 && rom(1,1)!=0	| | | |
					adi 2 adp 0-rom(1,1)	|
lae aar $2==2 && rom(1,3)==2 && rom(1,1)==0	| SCR_REG	|
		"sla %[1]"
		erase(%[1])	| %[1]	| adi 2	|
lae aar $2==2 && rom(1,3)==2 && rom(1,1)!=0	| SCR_XREG	|
		"sla %[1]"
		erase(%[1])
		| {regconst2, %[1], (0-2)*rom(1,1)}	| adi 2	|
lae aar $2==2 && rom(1,3)==4 && rom(1,1)==0	| SCR_REG	|
		"sla %[1], $$2"
		erase(%[1])	| %[1]	| adi 2	|
lae aar $2==2 && rom(1,3)==4 && rom(1,1)!=0	| SCR_XREG	|
		"sla %[1], $$2"
		erase(%[1])
		| {regconst2, %[1], (0-4)*rom(1,1)}	| adi 2	|
lae aar $2==2 && rom(1,3)==8 && rom(1,1)==0	| SCR_REG	|
		"sla %[1], $$3"
		erase(%[1])	| %[1]	| adi 2	|
lae aar $2==2 && rom(1,3)==8 && rom(1,1)!=0	| SCR_XREG	|
		"sla %[1], $$3"
		erase(%[1])
		| {regconst2, %[1], (0-8)*rom(1,1)}	| adi 2	|
lae aar $2==2 && rom(1,1)==0		| src2	|
		allocate( %[1], LWREG )
		move( %[1], %[a.2] )
		"mult %[a], $$%(rom(1,3)%)"
		erase(%[a])		| %[a.2]	| adi 2	|
lae aar $2==2 && defined(rom(1,1))	| src2	|
		allocate( %[1], LWREG )
		move( %[1], %[a.2] )
		"mult %[a], $$%(rom(1,3)%)"
		erase(%[a])
		| {regconst2, %[a.2], (0-rom(1,3))*rom(1,1)}   | adi 2 |
lae sar defined(rom(1,3))	| | | | lae $1 aar $2 sti rom(1,3)     |
lae lar defined(rom(1,3))	| | | | lae $1 aar $2 loi rom(1,3)     |
/**/
/***************************************
********	GROUP 12	********
***************************************/

cmi $1==2 | src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "jr EQ, 2f"
			  "jr LT, 1f"
			  "inc %[a]"
			  "jr 2f"
			  "1:\tdec %[a]\n2:"
			  erase(%[a])  nocc	| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "jr EQ, 2f"
			  "jr LT, 1f"
			  "inc %[a]"
			  "jr 2f"
			  "1:\tdec %[a]\n2:"
			  erase(%[a])  nocc	| %[a]	| |
cmi $1==4	| STACK	| "calr cmi4"	| R0	| |
cmi !defined($1)| src2  STACK	| move( %[1], R0 )
				  "calr cmi"
				  erase(R0)	| R0	| |
cmu $1==2	| | | | cmp	|
cmu $1==4	| STACK	| "calr cmu4"	| R0	| |
cmu !defined($1)| src2  STACK	| move( %[1], R0 )
				  "calr cmu"
				  erase(R0)	| R0	| |
cms $1==2	| | | | sbi $1	|
cms defined($1)	| STACK	| move( {im2, $1}, R0 )
			  "calr cms"
			  erase(R0)	| R0	| |
cms !defined($1)| src2  STACK	| move( %[1], R0 )
				  "calr cms"
				  erase(R0)	| R0	| |
cmp	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "jr EQ, 2f"
			  "jr ULT, 1f"
			  "inc %[a]"
			  "jr 2f"
			  "1:\tdec %[a]\n2:"
			  erase(%[a])  nocc	| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "jr EQ, 2f"
			  "jr ULT, 1f"
			  "inc %[a]"
			  "jr 2f"
			  "1:\tdec %[a]\n2:"
			  erase(%[a])  nocc	| %[a]	| |
tlt	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc LT, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
tle	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc LE, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
teq	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc EQ, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
tne	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc NE, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
tge	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc GE, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
tgt	| src2c	| allocate( REG = {im2, 0} )
		  test(%[1])
		  "tcc GT, %[a]"
		  erase(%[a])  samecc	| %[a]	| |
cmp tlt	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc ULT, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc ULT, %[a]"
			  erase(%[a])		| %[a]	| |
cmp tle	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc ULE, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc ULE, %[a]"
			  erase(%[a])		| %[a]	| |
cmp teq	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc EQ, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc EQ, %[a]"
			  erase(%[a])		| %[a]	| |
cmp tne	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc NE, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc NE, %[a]"
			  erase(%[a])		| %[a]	| |
cmp tge	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc UGE, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc UGE, %[a]"
			  erase(%[a])		| %[a]	| |
cmp tgt	| src2  REG	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc UGT, %[a]"
			  erase(%[a])		| %[a]	| |
...	| NC im2  src2a	| allocate( REG = {im2, 0} )
			  "cp %[2], %[1]"
			  "tcc UGT, %[a]"
			  erase(%[a])		| %[a]	| |
tlt and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr LT, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
tlt ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc LT, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
tle and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr LE, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
tle ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc LE, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
teq and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr EQ, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
teq ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc EQ, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
tne and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr NE, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
tne ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc NE, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
tgt and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr GT, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
tgt ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc GT, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
tge and $2==2	| src2c  SCR_REG	| test(%[1])
					  "jr GE, 1f"
					  "ldk %[2], $$0\n1:"
					  erase(%[2])	| %[2]	| |
tge ior $2==2	| src2c  SCR_REG	| test(%[1])
					  "tcc GE, %[2]"
					  samecc
					  erase(%[2])	| %[2]	| |
cmi tlt and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr LT, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr LT, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi tlt ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc LT, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc LT, %[3]"
					  erase(%[3])	| %[3]	| |
cmi tlt $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc LT, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc LT, %[a]"
				  erase(%[a])		| %[a]	| |
cmi tle and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr LE, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr LE, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi tle ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc LE, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc LE, %[3]"
					  erase(%[3])	| %[3]	| |
cmi tle $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc LE, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc LE, %[a]"
				  erase(%[a])		| %[a]	| |
cmi teq and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr EQ, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr EQ, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi teq ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc EQ, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc EQ, %[3]"
					  erase(%[3])	| %[3]	| |
cmi teq $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc EQ, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc EQ, %[a]"
				  erase(%[a])		| %[a]	| |
cmi tne and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr NE, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr NE, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi tne ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc NE, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc NE, %[3]"
					  erase(%[3])	| %[3]	| |
cmi tne $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc NE, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc NE, %[a]"
				  erase(%[a])		| %[a]	| |
cmi tge and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr GE, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr GE, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi tge ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc GE, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc GE, %[3]"
					  erase(%[3])	| %[3]	| |
cmi tge $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc GE, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc GE, %[a]"
				  erase(%[a])		| %[a]	| |
cmi tgt and $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"jr GT, 1f"
					"ldk %[3], $$0\n1:"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "jr GT, 1f"
					  "ldk %[3], $$0\n1:"
					  erase(%[3])	| %[3]	| |
cmi tgt ior $1==2 && $3==2	| src2  REG  SCR_REG	|
					"cp %[2], %[1]"
					"tcc GT, %[3]"
					erase(%[3])	| %[3]	| |
...	| NC im2  src2a  SCR_REG	| "cp %[2], %[1]"
					  "tcc GT, %[3]"
					  erase(%[3])	| %[3]	| |
cmi tgt $1==2	| src2  REG	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc GT, %[a]"
				  erase(%[a])		| %[a]	| |
...	| NC  im2  src2a	| allocate( REG = {im2, 0} )
				  "cp %[2], %[1]"
				  "tcc GT, %[a]"
				  erase(%[a])		| %[a]	| |
/**/
/***************************************
********	GROUP 13	********
***************************************/

bra	| STACK	| "jr $1"  samecc	| | |
blt	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr LT, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr LT, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr GT, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr GT, $1"		| | |
ble	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr LE, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr LE, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr GE, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr GE, $1"		| | |
beq	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr EQ, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr EQ, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr EQ, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr EQ, $1"		| | |
bne	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr NE, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr NE, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr NE, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr NE, $1"		| | |
bge	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr GE, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr GE, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr LE, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr LE, $1"		| | |
bgt	| src2  REG	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr GT, $1"		| | | (4,10)+%[1]
...	| NC im2  src2a	| remove( ALL )
			  "cp %[2], %[1]"
			  "jr GT, $1"		| | |
...	| REG  src2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr LT, $1"		| | | (4,10)+%[2]
...	| NC src2a  im2	| remove( ALL )
			  "cp %[1], %[2]"
			  "jr LT, $1"		| | |
zlt	| src2c	| remove( ALL )
		  test(%[1])
		  "jr LT, $1"
		  samecc		| | |
zle	| src2c	| remove( ALL )
		  test(%[1])
		  "jr LE, $1"
		  samecc		| | |
zeq	| src2c	| remove( ALL )
		  test(%[1])
		  "jr EQ, $1"
		  samecc		| | |
zne	| src2c	| remove( ALL )
		  test(%[1])
		  "jr NE, $1"
		  samecc		| | |
zge	| src2c	| remove( ALL )
		  test(%[1])
		  "jr GE, $1"
		  samecc		| | |
zgt	| src2c	| remove( ALL )
		  test(%[1])
		  "jr GT, $1"
		  samecc		| | |
cmp zlt		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr ULT, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr ULT, $2"		| | |
cmp zle		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr ULE, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr ULE, $2"		| | |
cmp zeq		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr EQ, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr EQ, $2"		| | |
cmp zne		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr NE, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr NE, $2"		| | |
cmp zgt		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr UGT, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr UGT, $2"		| | |
cmp zge		| src2  REG  STACK	| "cp %[2], %[1]"
					  "jr UGE, $2"		| | |
...		| NC im2  src2a  STACK	| "cp %[2], %[1]"
					  "jr UGE, $2"		| | |
and zeq $1==2	| src2  SCR_REG  STACK	| "and %[2], %[1]"
					  "jr EQ, $2"
					  erase(%[2])	| | | (4,10)+%[1]
...		| SCR_REG  src2  STACK	| "and %[1], %[2]"
					  "jr EQ, $2"
					  erase(%[1])	| | | (4,10)+%[2]
and zne $1==2	| src2  SCR_REG  STACK	| "and %[2], %[1]"
					  "jr NE, $2"
					  erase(%[2])	| | | (4,10)+%[1]
...		| SCR_REG  src2  STACK	| "and %[1], %[2]"
					  "jr NE, $2"
					  erase(%[1])	| | | (4,10)+%[2]
/**/
/***************************************
********	GROUP 14	********
***************************************/

cal	| STACK	| "calr $1"	| | |
cai	| NC src2a-x2  STACK	| "call %[1]"		| | |
...	| NC x2  STACK	| allocate( %[1], XREG = %[1] )
			  "call 0(%[a])"		| | |
...	| XREG  STACK	| "call 0(%[1])"		| | |
lfr $1==0	| | | | |
lfr $1==2	| | | R0	| |
lfr $1==4	| | | RR0	| |
lfr $1==6	| | | R2 R1 R0	| |
lfr $1==8	| | | RR2  RR0	| |
ret $1==0	| STACK	| "ldk R14, $$0\nld R15, R13"
			  "pop R13, *RR14"
			  "ret"			| | |
ret $1==2	| src2  STACK	| move( %[1], R0 )
				  "ldk R14, $$0\nld R15, R13"
				  "pop R13, *RR14"
				  "ret"			| | |
ret $1==4	| src4  STACK	| move( %[1], RR0 )
				  "ldk R14, $$0\nld R15, R13"
				  "pop R13, *RR14"
				  "ret"			| | |
ret $1==6	| src2 src2 src2 STACK	| move( %[1], R0 )
					  move( %[2], R1 )
					  move( %[3], R2 )
					  "ldk R14, $$0\nld R15, R13"
					  "pop R13, *RR14"
					  "ret"			| | |
ret $1==8	| src4  src4  STACK	| move( %[1], RR0 )
					  move( %[2], RR2 )
					  "ldk R14, $$0\nld R15, R13"
					  "pop R13, *RR14"
					  "ret"			| | |
lfr ret $1==$2		| | | | ret 0	|
asp lfr ret $2==$3	| | | | ret 0	|
asp ret $2==0		| | | | ret 0	|
/**/
/***************************************
********	GROUP 15	********
***************************************/

asp		| STACK	| "add R15, $$$1"		| | |
ass $1==2	| src2  STACK	 | "add R15, %[1]"	| | |
blm		| STACK	| move( {im2, $1}, R0 )
			  "calr blm"
			  erase(R0)	| | |
bls $1==2	| src2 STACK	| move( %[1], R0 )
				  "calr blm"
				  erase(R0)	| | |
csa $1==2	| STACK	| "pop R1, *RR14"
			  "pop R2, *RR14"
			  "jr csa"		| | |
lae csa $2==2	| src2  STACK	| move( %[1], R2 )
				  move( {ADDR_EXTERNAL, $1}, R1 )
				  "jr csa" 			| | |
csb $1==2	| STACK	| "pop R1, *RR14"
			  "pop R2, *RR14"
			  "jr csb"		| | |
lae csb $2==2	| src2  STACK	| move( %[1], R2 )
				  move( {ADDR_EXTERNAL, $1}, R1 )
				  "jr csb"			| | |
dup $1==2	| src2	| | %[1]  %[1]	| |
dup $1==4	| src2  src2	| | %[2]  %[1]  %[2]  %[1]	| |
dup		| STACK	| move( {im2, $1}, R0 )
			  "calr dup"
			  erase(R0)	| | |
dus $1==2	| src2  STACK	| move( %[1], R0 )
				  "calr dup"
				  erase(R0)		| | |
exg $1==2	| src2  src2	| | %[1]  %[2]	| |
exg $1==2	| STACK	| move( {im2, $1}, R0 )
			  "calr exg"
			  erase(R0)		| | |
lor $1==0	| | | LB	| |
lor $1==1	| STACK	| allocate( REG )
			  "ld %[a], R15"
			  samecc		| %[a]	| |
lor $1==2	| | | {da2, "reghp"}	| |
rck $1==2	| src2  STACK	| move( %[1], R1 )
				  "calr rck"		| | |
rck !defined($1)| src2  src2  STACK	| "cp %[1], $$2"
					  "jr NE, unknown"
					  move( %[2], R1 )
					  "calr rck"		| | |
str $1==0	| src2	| "ld R13, %[1]"  samecc	| | |
str $1==1	| src2  STACK	| "ldk R14, $$0\nld R15, %[1]"
				  samecc			| | |
str $1==2	| STACK	| "calr strhp"	| | |
dch	| | | | loi 2	|
fil	| | "ld hol0+4, $$$1"  samecc	| | |
gto	| STACK	| "push *RR14, $$$1"
		  "jr gto"		| | |
lim	| | | {da2, "trpim"}	| |
lin	| | "ld hol0, $$$1"  samecc	| | |
lni	| | "inc hol0"	| | |
lpb	| | | | adp SL	|
mon	| STACK	| "calr mon"	| | |
nop	| STACK	|
#ifdef DEBUG
	"calr noop"
#endif
					| | |
rtt	| | | | ret 0	|
sig	| REG	| allocate(REG)
		  move( {da2, "trppc"}, %[a] )
		  "ld trppc, %[1]"
		  samecc			| %[a]	| |
sim	| STACK	| "pop trpim, *RR14"
		  samecc		| | |
trp	| STACK	| "calr trp"		| | |

/* For several floating point instructions we generate an illegal
** instruction trap
*/
adf	| | | | loc 18 trp	|
sbf	| | | | loc 18 trp	|
mlf	| | | | loc 18 trp	|
dvf	| | | | loc 18 trp	|
ngf	| | | | loc 18 trp	|
fef	| | | | loc 18 trp	|
fif	| | | | loc 18 trp	|
zrf	| | | | loc 18 trp	|
cfi	| | | | loc 18 trp	|
cif	| | | | loc 18 trp	|
cfu	| | | | loc 18 trp	|
cuf	| | | | loc 18 trp	|
cff	| | | | loc 18 trp	|
cmf	| | | | loc 18 trp	|
/**/
/* COERCIONS	*/
/*********************************
** From source2 to register	**
*********************************/
| regconst2	| allocate( %[1], XREG = %[1.xreg] )
		  "add %[a], $$%[1.ind]"
		  setcc(%[a])			| %[a]	| | (4,7)
| ADDR_LOCAL	| allocate( REG )
		  "ld %[a], R13"
		  "add %[a], $$%[1.ind]"
		  setcc(%[a])			| %[a]	| | (6,10)
| REG	| allocate( %[1], XREG = %[1] )	| {regconst2, %[a], 0}  | |
| src2	| allocate( %[1], REG = %[1] )	| %[a]	| |
| src2	| allocate( %[1], XREG = %[1] )	| {regconst2, %[a], 0}  | |


/*********************************
** From source2 to source2	**
*********************************/
| ADDR_EXTERNAL	| | {da2, %[1.ind]}	| |


/*********************************
** From source1 to source2	**
*********************************/
| src1	| allocate( %[1], B2REG = %[1] )	| %[a]	| |


/*********************************
** From source4 to register	**
*********************************/
| src4	| allocate( %[1], LWREG = %[1] )	| %[a]	| |


/*********************************
** From source4 to source2	**
*********************************/
| LWREG	| | %[1.2]  %[1.1]	| |
| x4	| | {x2, %[1.xreg], 2+%[1.ind]}  {x2, %[1.xreg], %[1.ind]} | |
| da4	| | {da2, "2+"+%[1.ind]}  {da2, %[1.ind]}	| |
| ir4	| | {ir4_hi, %[1.lwxreg]}  {ir2, %[1.lwxreg]}	| |
| ir4_hi  | allocate( LWREG = %[1.lwreg] )	| {x2, %[a.2], 2}  | |


/*********************************
** From STACK			**
*********************************/
| STACK	| allocate( REG )
	  "pop %[a], *RR14"
	  samecc		| %[a]	| | (2,8)
| STACK	| allocate( XREG )
	  "pop %[a], *RR14"
	  samecc		| {regconst2, %[a], 0}	| | (2,8)
| STACK	| allocate( LWREG )
	  "popl %[a], *RR14"
	  samecc		| %[a]	| | (2,12)


MOVES:
/* move( src, dst ) --> ld dst, src	*/
(im2  (%[num]>=0 && %[num]<=15), REG, "ldk %[2], %[1]" samecc, (2,5))
(im2  %[num]==0, src2a, "clr %[2]" samecc, (2,7)+%[2])
(im2  %[num]==0, src1, "clrb %[2]" samecc, (2,7)+%[2])
(im2, src1, "ldb %[2], $$[%[1.num]-[%[1.num]&0xFFFFFF00]+128]%%256-128"
	    samecc, (4,9)+%[2])
(src1, B2REG, "ldk %[2], $$0\nldb L%[2], %[1]" samecc, (4,8)+%[1])
(src2, REG, "ld %[2], %[1]" samecc, (2,3)+%[1])
(src4, LWREG, "ldl %[2], %[1]" samecc, (2,5)+%[1])
(const2, src1, "ldb %[2], %[1]" samecc, (4,9)+%[2])
(B2REG, src1, "ldb %[2], L%[1]" samecc, (2,6)+%[2])
(src2b, src2a, "ld %[2], %[1]" samecc, (2,6)+%[1]+%[2])
(src4b, src4a, "ldl %[2], %[1]" samecc, (2,6)+%[2])


TESTS:
(src2c, "test %[1]", (2,7)+%[1])


STACKS:
(src1, B2REG,	move( %[1], %[a] )
		"push *RR14, %[a]"
		"clrb *RR14"
		samecc,		(4,17)		)
(src1,,		".sect data\n1:\t.data2 0\n.text"
		"ld 1b, R0"
		"ldk R0, $$0"
		"ldb RL0, %[1]"
		"push *RR14, R0"
		"ld R0, 1b"
		samecc,		(18,37)+%[1]	)
(src2,,		"push *RR14, %[1]"
		samecc,		(2,9)+%[1]	)
(const4, LWREG,	move( %[1], %[a] )
		"pushl *RR14, %[a]"
		samecc,		(2,12)		)
(im4,,		"push *RR14, %[1]"
		"push *RR14, $$0"
		samecc,		(8,24)	)  /* there is no pushl ir,im */
(double,,	".sect .data\n1:\t.data4 %[1]\n.text"
		"pushl *RR14, 1b"
		samecc,		(6,20)		)
(src4,,		"pushl *RR14, %[1]"
		samecc,		(2,12)+%[1]	)
(regconst2,,	"add %[1.xreg], $$%[1.ind]"
		"push *RR14, %[1.xreg]"
		nocc,		(6,16)		)
(ADDR_LOCAL, REG,
		move( LB, %[a] )
		"add %[a], $$%[1.ind]"
		"push *RR14, %[a]"
		setcc(%[a]),	(6,16)		)
(ADDR_LOCAL,,	"add R13, $$%[1.ind]"
		"push *RR14, R13"
		"sub R13, $$%[1.ind]"
		nocc,		(10,23)		)
