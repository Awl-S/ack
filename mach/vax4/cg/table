"$Header$"
#define LOCLABS		/* define if target assembler recognizes local labels */
#define REGVARS		/* define for register variables */
#define DORCK		/* define if you want RCK */
#define FLOAT4		/* define if you want better 4-byte FP arithmetic */
#define FLOAT8		/* define if you want better 8-byte FP arithmetic */
/* #define ASBUG_AVOID	/* define if you want to avoid a bug in the BSD 4.1 VAX
			   assembler, that sometimes generates "*1" for
			   (r1). This is avoided by generating 0(r1), which is
			   optimized by the assembler to (r1).
			*/
#ifdef ASBUG_AVOID
#define REGDEFFORMAT "0(%[reg])"
#else
#define REGDEFFORMAT "(%[reg])"
#endif

#define NC nocoercions :
#define BSIZE 4

EM_PSIZE = 4
EM_WSIZE = 4
EM_BSIZE = BSIZE

/****************************************************************
 * VAX 11 Back end table.					*
 * Author : Ceriel J.H. Jacobs, Duk Bekema			*
 *								*
 * Wordsize = 4 bytes						*
 * Pointersize = 4 bytes					*
 *								*
 * There is hardly any instruction timing information available *
 * for the DEC-VAX machines. Timing of addressing modes was done*
 * by counting the memory references and multiplying them by	*
 * 3.	300 nanosec seems to be a typical memory reference time.*
 * However, the VAX can be much faster, if the "cache hit rate" *
 * is high.							*
 * Assumed hardware : VAX-11/7?0 with Floating Point Acc.	*
 ****************************************************************/

REGISTERS:
AP	= ("ap",4),ArgumentPointer.
LB	= ("fp",4),LocaLBase.
R0	= ("r0",4),REG.
R1	= ("r1",4),REG.
R2	= ("r2",4),REG.
R3	= ("r3",4),REG.
#ifdef REGVARS
R4	= ("r4",4) regvar,RREG.
R5	= ("r5",4) regvar,RREG.
R6	= ("r6",4) regvar,RREG.
R7	= ("r7",4) regvar,RREG.
R8	= ("r8",4) regvar,RREG.
R9	= ("r9",4) regvar,RREG.
RA	= ("r10",4) regvar,RREG.
RB	= ("r11",4) regvar,RREG.
#else /* REGVARS */
R4	= ("r4",4),REG.
R5	= ("r5",4),REG.
R6	= ("r6",4),REG.
R7	= ("r7",4),REG.
R8	= ("r8",4),REG.
R9	= ("r9",4),REG.
RA	= ("r10",4),REG.
RB	= ("r11",4),REG.
#endif /* REGVARS */
QR0	= ("r0",8,R0,R1),QREG.
QR2	= ("r2",8,R2,R3),QREG.
#ifndef REGVARS
QR4	= ("r4",8,R4,R5),QREG.
QR6	= ("r6",8,R6,R7),QREG.
QR8	= ("r8",8,R8,R9),QREG.
QRA	= ("r10",8,RA,RB),QREG.
#endif /* REGVARS */
QR1	= ("r1",8,R1,R2),QREG.
#ifndef REGVARS
QR3	= ("r3",8,R3,R4),QREG.
QR5	= ("r5",8,R5,R6),QREG.
QR7	= ("r7",8,R7,R8),QREG.
QR9	= ("r9",8,R9,RA),QREG.
#endif /* REGVARS */

TOKENS:

/* First some EM machine tokens */
CONST1 =	{INT num;}		4 cost=(4,3)  "$%[num]"
CONST2 =	{INT num;}		4 cost=(4,3)  "$%[num]"
CONST4 =	{INT num;}		4 cost=(4,3)  "$%[num]"
CONST8 =	{STRING ind;}		8 cost=(8,6)  "$%[ind]"
LOCAL1 =	{REGISTER reg; INT num,size;}	4 cost=(2,6)  "%[num](%[reg])"
LOCAL2 =	{REGISTER reg; INT num,size;}	4 cost=(2,6)  "%[num](%[reg])"
LOCAL4 =	{REGISTER reg; INT num,size;}	4 cost=(2,6)  "%[num](%[reg])"
LOCAL8 =	{REGISTER reg; INT num,size;}	8 cost=(2,9)  "%[num](%[reg])"
ADDR_LOCAL =	{REGISTER reg; INT num;}	4 cost=(2,6)  "%[num](%[reg])"
ADDR_EXTERNAL =	{STRING ind;}		4 cost=(4,6)  "%[ind]"
EXTERNAL1 =	{STRING ind;}		4 cost=(4,6)  "%[ind]"
EXTERNAL2 =	{STRING ind;}		4 cost=(4,6)  "%[ind]"
EXTERNAL4 =	{STRING ind;}		4 cost=(4,6)  "%[ind]"
EXTERNAL8 =	{STRING ind;}		8 cost=(4,9)  "%[ind]"
DOUBLE =	{STRING ind;}		4 cost=(4,6)  "$%[ind]"
/* Now tokens for the target machine */
regdef1 =	{REGISTER reg;}		4 cost=(0,3)  REGDEFFORMAT
regdef2 =	{REGISTER reg;} 	4 cost=(0,3)  REGDEFFORMAT
regdef4 =	{REGISTER reg;} 	4 cost=(0,3)  REGDEFFORMAT
regdef8 =	{REGISTER reg;} 	8 cost=(0,6)  REGDEFFORMAT
#ifdef REGVARS
reginc1 =	{REGISTER reg;}		4 cost=(0,3)  "(%[reg])+"
reginc2 =	{REGISTER reg;}		4 cost=(0,3)  "(%[reg])+"
reginc4 =	{REGISTER reg;}		4 cost=(0,3)  "(%[reg])+"
reginc8 =	{REGISTER reg;}		8 cost=(0,6)  "(%[reg])+"
regdec1 =	{REGISTER reg;}		4 cost=(0,3)  "-(%[reg])"
regdec2 =	{REGISTER reg;}		4 cost=(0,3)  "-(%[reg])"
regdec4 =	{REGISTER reg;}		4 cost=(0,3)  "-(%[reg])"
regdec8 =	{REGISTER reg;}		8 cost=(0,6)  "-(%[reg])"
#endif /* REGVARS */
displ1 =	{REGISTER reg; STRING ind;} 4 cost=(2,6)  "%[ind](%[reg])"
displ2 =	{REGISTER reg; STRING ind;} 4 cost=(2,6)  "%[ind](%[reg])"
displ4 =	{REGISTER reg; STRING ind;} 4 cost=(2,6)  "%[ind](%[reg])"
displ8 =	{REGISTER reg; STRING ind;} 8 cost=(2,9)  "%[ind](%[reg])"
displdef1 =	{REGISTER reg; STRING ind;} 4 cost=(2,9)  "*%[ind](%[reg])"
displdef2 =	{REGISTER reg; STRING ind;} 4 cost=(2,9)  "*%[ind](%[reg])"
displdef4 =	{REGISTER reg; STRING ind;} 4 cost=(2,9)  "*%[ind](%[reg])"
displdef8 =	{REGISTER reg; STRING ind;} 8 cost=(2,12) "*%[ind](%[reg])"
reldef1 =	{STRING ind;}		4 cost=(4,9)    "*%[ind]"
reldef2 =	{STRING ind;}		4 cost=(4,9)    "*%[ind]"
reldef4 =	{STRING ind;}		4 cost=(4,9)    "*%[ind]"
reldef8 =	{STRING ind;}		8 cost=(4,12)   "*%[ind]"
extind2 =	{REGISTER ireg; STRING ind; } 4 cost=(5,10) "%[ind] [%[ireg]]"
extind4 =	{REGISTER ireg; STRING ind; } 4 cost=(5,10) "%[ind] [%[ireg]]"
extind8 =	{REGISTER ireg; STRING ind; } 8 cost=(5,13) "%[ind] [%[ireg]]"
displind1 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
displind2 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
displind4 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
displind8 =	{REGISTER ireg,reg; STRING ind;} 8 cost=(3,13) 
						"%[ind](%[reg]) [%[ireg]]"
extdefind1 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
extdefind2 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
extdefind4 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
extdefind8 =	{REGISTER ireg; STRING ind; } 8 cost=(5,16) "*%[ind] [%[ireg]]"
displdefind1 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
displdefind2 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
displdefind4 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
displdefind8 =	{REGISTER ireg,reg; STRING ind;} 8 cost=(3,16)
						"*%[ind](%[reg]) [%[ireg]]"

/* Not really addressable modes */
adispl =	{REGISTER reg; STRING ind; } 4 cost=(4,6)  "%[ind](%[reg])"
aextind2 =	{REGISTER ireg; STRING ind; } 4 cost=(5,10) "%[ind] [%[ireg]]"
aextind4 =	{REGISTER ireg; STRING ind; } 4 cost=(5,10) "%[ind] [%[ireg]]"
aextind8 =	{REGISTER ireg; STRING ind; } 4 cost=(5,10) "%[ind] [%[ireg]]"
adisplind1 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
adisplind2 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
adisplind4 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
adisplind8 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,10) 
						"%[ind](%[reg]) [%[ireg]]"
aextdefind1 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
aextdefind2 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
aextdefind4 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
aextdefind8 =	{REGISTER ireg; STRING ind; } 4 cost=(5,13) "*%[ind] [%[ireg]]"
adispldefind1 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
adispldefind2 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
adispldefind4 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"
adispldefind8 =	{REGISTER ireg,reg; STRING ind;} 4 cost=(3,13)
						"*%[ind](%[reg]) [%[ireg]]"


TOKENEXPRESSIONS:
CONST =		CONST1 + CONST2 + CONST4
ind2 =		extind2 + displind2 + extdefind2 + displdefind2
ind4 =		extind4 + displind4 + extdefind4 + displdefind4
Xsource1 =	regdef1 + displ1 + displdef1 +
		EXTERNAL1 + reldef1 + CONST1 + LOCAL1
		+ displind1 + extdefind1 + displdefind1
source1 =	Xsource1
#ifdef REGVARS
		+ reginc1 + regdec1
#endif /* REGVARS */
Xsource2 =	regdef2 + displ2 + displdef2 +
		EXTERNAL2 + reldef2 + CONST2 + LOCAL2 + ind2
source2 =	Xsource2
#ifdef REGVARS
		+ reginc2 + regdec2
#endif /* REGVARS */
Xsource4 =	REG + regdef4 + displ4 + displdef4 + LocaLBase +
		EXTERNAL4 + reldef4 + CONST + DOUBLE + LOCAL4 + ind4
source4 =	Xsource4
#ifdef REGVARS
		+ RREG + reginc4 + regdec4
#endif /* REGVARS */
dups4 =		CONST + regdef1 + displ1 + LOCAL1 +
		REG +	regdef2 + displ2 + LOCAL2 +
		RREG +	regdef4 + displ4 + LOCAL4 + DOUBLE
Xsource8 =	QREG + regdef8 + displ8 + displdef8 +
		EXTERNAL8 + reldef8 + CONST8 + LOCAL8
		+ extind8 + displind8 + extdefind8 + displdefind8
source8 =	Xsource8
#ifdef REGVARS
		+ reginc8 + regdec8
#endif /* REGVARS */
source1or2 =	source1 + source2 - ind2
source1or2or4 = source1or2 + source4 - (ind2 + ind4)
source2or4 =	source2 + source4 - ind4
nonexist1 =	adispl + ADDR_EXTERNAL + ADDR_LOCAL
aextind =	aextind2 + aextind4 + aextind8
adisplind =	adisplind1 + adisplind2 + adisplind4 + adisplind8
aextdefind =	aextdefind1 + aextdefind2 + aextdefind4 + aextdefind8
adispldefind =	adispldefind1 + adispldefind2 + adispldefind4 + adispldefind8
aind1 =		adisplind1 + aextdefind1 + adispldefind1
aind2 =		aextind2 + adisplind2 + aextdefind2 + adispldefind2
aind4 =		aextind4 + adisplind4 + aextdefind4 + adispldefind4
aind8 =		aextind8 + adisplind8 + aextdefind8 + adispldefind8
aind =		aind1 + aind2 + aind4 + aind8
nonexist =	nonexist1 + aind
#ifdef REGVARS
regch4 =	reginc1 + regdec1 + reginc2 + regdec2 + reginc4 + regdec4
regch8 =	reginc8 + regdec8
regch =		regch4 + regch8
#endif /* REGVARS */
displs =	displ1 + displ2 + displ4 + displ8 +
		regdef1 + regdef2 + regdef4 + regdef8
#ifdef REGVARS
		+ regch
#endif /* REGVARS */
displdefs =	displdef1 + displdef2 + displdef4 + displdef8
EXTERNALS =	EXTERNAL1 + EXTERNAL2 + EXTERNAL4 + EXTERNAL8
LOCALS =	LOCAL1 + LOCAL2 + LOCAL4 + LOCAL8
reldefs =	reldef1 + reldef2 + reldef4 + reldef8
displinds =	displind1 + displind2 + displind4 + displind8
extinds =	extind2 + extind4 + extind8
displdefinds =	displdefind1 + displdefind2 + displdefind4 + displdefind8
extdefinds =	extdefind1 + extdefind2 + extdefind4 + extdefind8
displaced =	displs + displdefs + reldefs
		+ displinds + displdefinds + extdefinds
externals =	EXTERNALS + displaced + extinds
extandloc =	externals + LOCALS
#ifdef REGVARS
reg4 =		REG + RREG + LocaLBase
reg8 =		QREG
#else /* REGVARS */
reg4 =		REG
reg8 =		QREG
#endif /* REGVARS */
sreg4 = 	REG * SCRATCH
sreg8 = 	QREG * SCRATCH
bigsource4 =	source1or2or4 + nonexist + ind2 + ind4
bigsource8 =	source8
all =		bigsource4 + bigsource8
scr =		ALL - (EXTERNALS + LOCALS + ADDR_LOCAL + ADDR_EXTERNAL + CONST
			+ DOUBLE)
#ifdef REGVARS
#define REMEXTANDLOC remove(externals) remove(LOCALS,inreg(%[num])==0)
#define REMREG(x) remove(regch,%[reg]==regvar(x))
#else /* REGVARS */
#define REMEXTANDLOC remove(extandloc)
#endif /* REGVARS */

CODE:

/********************************
 * Group 1 : Load instructions	* 
 ********************************/

loc $1>=0 && $1<256	| |	| {CONST1,$1}				| |
loc $1>=256 && $1<65536	| |	| {CONST2,$1}				| |
loc		| |		| {CONST4,$1}				| |
ldc		| |		| {CONST8,$1}				| |
#ifdef REGVARS
lol inreg($1)==2 | | REMREG($1)	| regvar($1)				| |
#endif /* REGVARS */
lol $1 < 0	| |		| {LOCAL4,LB,$1,4}			| |
lol $1 >= 0	| |		| {LOCAL4,AP,$1,4}			| |
loe		| |		| {EXTERNAL4,$1}			| |
#ifdef REGVARS
lil inreg($1)==2 | |	REMREG($1)	| {regdef4,regvar($1)}		| |
#endif /* REGVARS */
lil $1 < 0	| |		| {displdef4,LB,tostring($1)}		| |
lil $1 >= 0	| |		| {displdef4,AP,tostring($1)}		| |
lof		| |		|			| adp $1 loi 4	|
lal $1 < 0	| |		| {ADDR_LOCAL,LB,$1}			| |
lal $1 >= 0	| |		| {ADDR_LOCAL,AP,$1}			| |
lae		| |		| {ADDR_EXTERNAL,$1}			| |
lxl $1==0	| |		| LB					| |
lxl $1==1	| |		| {LOCAL4,AP,BSIZE,4}			| |
lxl $1 > 1	| |	remove(scr)
			move({CONST4,$1},R0)
			"jsb\t.lxl"
			erase(R0)				| R0	| |
lxa $1==0	| |		| {ADDR_LOCAL,AP,BSIZE}			| |
lxa $1==1	| |		| {LOCAL4,AP,BSIZE,4}			| lpb |
lxa $1 > 1	| |	remove(scr)
			move({CONST4,$1},R0)
			"jsb\t.lxa"
			erase(R0)				| R0	| |
loi $1==1	| NC adispl |	| {displ1,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_LOCAL | | {LOCAL1,%[1.reg],%[1.num],1}	| |
...		| NC LOCAL4 |	| {displdef1,%[1.reg],tostring(%[1.num])} | |
...		| NC regdef4 |	| {displdef1,%[1.reg],"0"}		| |
...		| NC displ4 |	| {displdef1,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_EXTERNAL | | {EXTERNAL1,%[1.ind]}		| |
...		| NC EXTERNAL4 | | {reldef1,%[1.ind]}			| |
...		| NC adisplind1 |
			| {displind1,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| NC aextdefind1 |
				| {extdefind1,%[1.ireg],%[1.ind]}	| |
...		| NC adispldefind1 |
			| {displdefind1,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| reg4 | 	| {regdef1,%[1]}			| |
loi $1==2	| NC adispl |	| {displ2,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_LOCAL | | {LOCAL2,%[1.reg],%[1.num],2}	| |
...		| NC LOCAL4 |	| {displdef2,%[1.reg],tostring(%[1.num])} | |
...		| NC regdef4 |	| {displdef2,%[1.reg],"0"}		| |
...		| NC displ4 |	| {displdef2,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_EXTERNAL | | {EXTERNAL2,%[1.ind]}		| |
...		| NC EXTERNAL4 | | {reldef2,%[1.ind]}			| |
...		| NC aextind2 | | {extind2,%[1.ireg],%[1.ind]}	| |
...		| NC adisplind2 |
			| {displind2,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| NC aextdefind2 |
				| {extdefind2,%[1.ireg],%[1.ind]}	| |
...		| NC adispldefind2 |
			| {displdefind2,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| reg4 |	| {regdef2,%[1]}			| |
loi $1==4	| NC adispl |	| {displ4,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_LOCAL | | {LOCAL4,%[1.reg],%[1.num],4}	| |
...		| NC LOCAL4 |	| {displdef4,%[1.reg],tostring(%[1.num])} | |
...		| NC regdef4 |	| {displdef4,%[1.reg],"0"}		| |
...		| NC displ4 |	| {displdef4,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_EXTERNAL | | {EXTERNAL4,%[1.ind]}		| |
...		| NC EXTERNAL4 | | {reldef4,%[1.ind]}			| |
...		| NC aextind4 | | {extind4,%[1.ireg],%[1.ind]}		| |
...		| NC adisplind4 |
			| {displind4,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| NC aextdefind4 |
				| {extdefind4,%[1.ireg],%[1.ind]}	| |
...		| NC adispldefind4 |
			| {displdefind4,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| reg4 | 	| {regdef4,%[1]}			| |
loi $1==8	| NC adispl |	| {displ8,%[1.reg],%[1.ind]}		| |
...		| NC ADDR_LOCAL | | {LOCAL8,%[1.reg],%[1.num],8}	| |
...		| NC LOCAL4 |	| {displdef8,%[1.reg],tostring(%[1.num])} | |
...		| NC regdef4 |	| {displdef8,%[1.reg],"0"}		| |
...		| NC displ4 |	| {displdef8,%[1.reg],%[1.ind]}	| |
...		| NC ADDR_EXTERNAL | | {EXTERNAL8,%[1.ind]}		| |
...		| NC EXTERNAL4 | | {reldef8,%[1.ind]}			| |
...		| NC aextind8 | | {extind8,%[1.ireg],%[1.ind]}		| |
...		| NC adisplind8 |
			| {displind8,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| NC aextdefind8 |	     
				| {extdefind8,%[1.ireg],%[1.ind]}	| |
...		| NC adispldefind8 |    
			| {displdefind8,%[1.ireg],%[1.reg],%[1.ind]}	| |
...		| reg4 | 	| {regdef8,%[1]}			| |
loi $1>8 && $1<=16
		| NC ADDR_EXTERNAL |    
				| {EXTERNAL8,%[1.ind]+"+"+tostring($1-8)}
				%[1]				| loi $1-8 |
...		| NC ADDR_LOCAL |
				| {LOCAL8,%[1.reg],%[1.num]+$1-8,8} %[1]
								| loi $1-8 |	
...		| reg4 | | {displ8,%[1],tostring($1-8)} %[1]	| loi $1-8 |
loi		| sreg4 |
			remove(ALL)
			allocate(REG={CONST4,$1/4})
			"addl2\t$$$1,%[1]"
#ifdef LOCLABS
			"1:\nmovl\t-(%[1]),-(sp)"
			"sobgtr\t%[a],1b"
#else
			"movl\t-(%[1]),-(sp)"
			"sobgtr\t%[a],.-3"
#endif
			erase(%[a])				|	| |
los $1==4	| STACK |
			move({CONST1,4},R0)
			"jsb\t.los"
			erase(R0)				|	| |
los !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.los"
			erase(R0)				|	| |
ldl $1<0	| |		| {LOCAL8,LB,$1,8}			| |
ldl $1>=0	| |		| {LOCAL8,AP,$1,8}			| |
lde		| |		| {EXTERNAL8,$1}			| |
ldf		| |		|		| adp $1 loi 8	|
lpi		| |		| {ADDR_EXTERNAL,$1}			| |

/********************************
 * Group 2 : Store instructions *
 ********************************/

#ifdef REGVARS
stl inreg($1)==2 | NC bigsource4 |
			remove(regvar($1))
			move(%[1],regvar($1))		|	| |
...		| STACK |
			"movl\t(sp)+,%(regvar($1)%)"	|	| | (3,7)
#endif /* REGVARS */
stl $1 < 0	| NC bigsource4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $1+3 && %[num]+%[size] > $1)
			move(%[1],{LOCAL4,LB,$1,4})		|	| |
...		| STACK |
			"movl\t(sp)+,$1(fp)"		|	| | (5,14)
stl $1 >= 0	| NC bigsource4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $1+3 && %[num]+%[size] > $1)
			move(%[1],{LOCAL4,AP,$1,4})		|	| |
...		| STACK |
			"movl\t(sp)+,$1(ap)"		|	| | (5,14)
ste		| NC bigsource4 |
			remove(externals)
			move(%[1],{EXTERNAL4,$1})		|	| |
...		| STACK |
			"movl\t(sp)+,$1"		|	| | (7,14)
#ifdef REGVARS
sil inreg($1)==2 | NC bigsource4 |
			REMEXTANDLOC
			move(%[1],{regdef4,regvar($1)})	|	| |
...		| STACK |
			"movl\t(sp)+,(%(regvar($1)%))"	|	| | (3,10)
#endif /* REGVARS */
sil $1 < 0	| NC bigsource4 |
			REMEXTANDLOC
			move(%[1],{displdef4,LB,tostring($1)})	|	| |
...		| STACK |
			"movl\t(sp)+,*$1(fp)"		|	| | (5,17)
sil $1 >= 0	| NC bigsource4 |
			REMEXTANDLOC
			move(%[1],{displdef4,AP,tostring($1)})	|	| |
...		| STACK |
			"movl\t(sp)+,*$1(ap)"		|	| | (5,17)
stf		| |				| | adp $1 sti 4 |
/*** C-problem: f(c) char c; {
			write(1,&c,1);
		}
		You don't know where the character is put in the word,
		so the CEM-compiler generates: (shorts analogously)
***/
lol lal sti $1==$2 && $3<4	| | | | |
/************************************************/
sti $1==1	| NC adispl source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displ1,%[1.reg],%[1.ind]})	|	| |
...		| NC ADDR_LOCAL source1or2or4 |
			remove(displaced)
			remove(LOCALS,
				%[num]<=%[1.num] && %[num]+%[size]>%[1.num])
			move(%[2],{LOCAL1,%[1.reg],%[1.num],1})	|	| |
...		| NC displ4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displdef1,%[1.reg],%[1.ind]}) |	| |
...		| NC ADDR_EXTERNAL source1or2or4 |
			remove(externals)
			move(%[2],{EXTERNAL1,%[1.ind]}) 	|	| |
...		| NC EXTERNAL4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{reldef1,%[1.ind]})		|	| |
...		| NC adisplind1 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displind1,%[1.ireg],%[1.reg],%[1.ind]})
								|	| |
...		| NC aextdefind1 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{extdefind1,%[1.ireg],%[1.ind]}) |	| |
...		| NC adispldefind1 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displdefind1,%[1.ireg],%[1.reg],%[1.ind]})
								|	| |
...		| reg4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{regdef1,%[1]})		|	| |
...		| NC nonexist1+aind1 STACK |
			"cvtlb\t(sp)+,%[1]"		|	| | (3,7)+%[1]
sti $1==2	| NC adispl source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displ2,%[1.reg],%[1.ind]}) |	| |
...		| NC ADDR_LOCAL source1or2or4 |
			remove(displaced)
			remove(LOCALS,
				%[num]<=%[1.num] && %[num]+%[size]>%[1.num])
			move(%[2],{LOCAL2,%[1.reg],%[1.num],2})	|	| |
...		| NC displ4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displdef2,%[1.reg],%[1.ind]}) |	| |
...		| NC ADDR_EXTERNAL source1or2or4 |
			remove(externals)
			move(%[2],{EXTERNAL2,%[1.ind]}) 	|	| |
...		| NC EXTERNAL4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{reldef2,%[1.ind]})		|	| |
...		| NC aextind2 source1or2or4 |
			remove(externals)
			move(%[2],{extind2,%[1.ireg],%[1.ind]})	|	| |
...		| NC adisplind2 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displind2,%[1.ireg],%[1.reg],%[1.ind]}) | | |
...		| NC aextdefind2 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{extdefind2,%[1.ireg],%[1.ind]}) |	| |
...		| NC adispldefind2 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{displdefind2,%[1.ireg],%[1.reg],%[1.ind]})
								|	| |
...		| reg4 source1or2or4 |
			REMEXTANDLOC
			move(%[2],{regdef2,%[1]})		|	| |
sti $1==4	| NC adispl bigsource4 |
			REMEXTANDLOC
			move(%[2],{displ4,%[1.reg],%[1.ind]}) |	| |
...		| NC ADDR_LOCAL |		| | stl %[1.num] |
...		| NC ADDR_EXTERNAL |		| | ste %[1.ind] |
...		| NC LOCAL4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{displdef4,%[1.reg],tostring(%[1.num])}) | | |
...		| NC regdef4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{displdef4,%[1.reg],"0"})	|	| |
...		| NC displ4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{displdef4,%[1.reg],%[1.ind]}) |	| |
...		| NC EXTERNAL4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{reldef4,%[1.ind]})		|	| |
...		| NC aextind4 bigsource4 |
			remove(externals)
			move(%[2],{extind4,%[1.ireg],%[1.ind]})	|	| |
...		| NC adisplind4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{displind4,%[1.ireg],%[1.reg],%[1.ind]}) | | |
...		| NC aextdefind4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{extdefind4,%[1.ireg],%[1.ind]}) |	| |
...		| NC adispldefind4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{displdefind4,%[1.ireg],%[1.reg],%[1.ind]})
								|	| |
...		| NC nonexist1+aind4 STACK |
			"movl\t(sp)+,%[1]"		|	| | (3,7)+%[1]
...		| reg4 bigsource4 |
			REMEXTANDLOC
			move(%[2],{regdef4,%[1]})		|	| |
...		| reg4 STACK |
			"movl\t(sp)+,(%[1])"		|	| | (3,10)
sti $1==8	| NC adispl bigsource8 |
			REMEXTANDLOC
			move(%[2],{displ8,%[1.reg],%[1.ind]}) |	| |
...		| NC ADDR_LOCAL |		| | sdl %[1.num] |
...		| NC ADDR_EXTERNAL |		| | sde %[1.ind] |
...		| NC displ4 bigsource8 |
			REMEXTANDLOC
			move(%[2],{displdef8,%[1.reg],%[1.ind]}) |	| |
...		| NC LOCAL4 bigsource8 |
			REMEXTANDLOC
			move(%[2],{displdef8,%[1.reg],tostring(%[1.num])}) | | |
...		| NC regdef4 bigsource8 |
			REMEXTANDLOC
			move(%[2],{displdef8,%[1.reg],"0"})	|	| |
...		| NC EXTERNAL4 bigsource8 |
			REMEXTANDLOC
			move(%[2],{reldef8,%[1.ind]})		|	| |
...		| NC aextind8 bigsource8 |
			remove(externals)
			move(%[2],{extind8,%[1.ireg],%[1.ind]})	|	| |
...		| NC adisplind8 bigsource8 |
			REMEXTANDLOC
			move(%[2],{displind8,%[1.ireg],%[1.reg],%[1.ind]}) | | |
...		| NC aextdefind8 bigsource8 |
			REMEXTANDLOC
			move(%[2],{extdefind8,%[1.ireg],%[1.ind]}) |	| |
...		| NC adispldefind8 bigsource8 |
			REMEXTANDLOC
			move(%[2],{displdefind8,%[1.ireg],%[1.reg],%[1.ind]})
								|	| |
...		| reg4 bigsource8 |
			REMEXTANDLOC
			move(%[2],{regdef8,%[1]})		|	| |
sti		| sreg4 |
			remove(ALL)
			allocate(REG={CONST4,$1/4})
#ifdef LOCLABS
			"1:\nmovl\t(sp)+,(%[1])+"
			"sobgtr\t%[a],1b"
#else
			"movl\t(sp)+,(%[1])+"
			"sobgtr\t%[a],.-3"
#endif
			erase(%[a])				|	| |
sts $1==4	| STACK |
			move({CONST1,4},R0)
			"jsb\t.sts"
			erase(R0)				|	| |
sts !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sts"
			erase(R0)				|	| |
sdl $1 < 0	| NC bigsource8 |
			remove(displaced)
			remove(LOCALS,%[num]<=$1+7 && %[num]+%[size]>$1)
			move(%[1],{LOCAL8,LB,$1,8})		|	| |
...		| NC bigsource4 bigsource4 |
			remove(displaced)
			remove(LOCALS,%[num]<=$1+7 && %[num]+%[size]>$1)
			move(%[1],{LOCAL4,LB,$1,4})
			move(%[2],{LOCAL4,LB,$1+4,4})		|	| |
...		| STACK |
			"movq\t(sp)+,$1(fp)"		|	| | (5,14)
sdl $1 >= 0	| NC bigsource8 |
			remove(displaced)
			remove(LOCALS,%[num]<=$1+7 && %[num]+%[size]>$1)
			move(%[1],{LOCAL8,AP,$1,8})		|	| |
...		| NC bigsource4 bigsource4 |
			remove(displaced)
			remove(LOCALS,%[num]<=$1+7 && %[num]+%[size]>$1)
			move(%[1],{LOCAL4,AP,$1,4})
			move(%[2],{LOCAL4,AP,$1+4,4})		|	| |
...		| STACK |
			"movq\t(sp)+,$1(ap)"		|	| | (5,14)
sde		| NC bigsource8 |
			remove(externals)
			move(%[1],{EXTERNAL8,$1})		|	| |
...		| bigsource4 bigsource4 |
			remove(externals)
			move(%[1],{EXTERNAL4,$1})
			move(%[2],{EXTERNAL4,$1+"+4"})	|	| |
...		| STACK |
			"movq\t(sp)+,$1"		|	| | (7,14)
sdf		| |					| | adp $1 sti 8 |

/********************************
 * Group 3 : Integer Arithmetic *
 ********************************/

adi $1==4	| source4 sreg4 |
			"addl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,4) + %[1]
...		| sreg4 source4 |
			"addl2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,4) + %[2]
...		| source4 source4 |
			allocate(%[1],%[2],REG)
			"addl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
#ifdef REGVARS
adi stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"addl3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
adi stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num]<=$2+3 && %[num]+%[size]>$2)
			"addl3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})		|	| |
adi stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num]<=$2+3 && %[num]+%[size]>$2)
			"addl3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) 	|	| |
#ifdef REGVARS
adi sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"addl3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
adi lol stf $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"addl3\t%[1],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
adi sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"addl3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
adi sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"addl3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
adi ste $1==4	| source4 source4 |
			remove(externals)
			"addl3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})			|	| |
adi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.adi"			     |	     | |
sbi $1==4	| source4 sreg4 |
			"subl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,4) + %[1]
...		| source4 source4 |
			allocate(%[1],%[2],REG)
			"subl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
#ifdef REGVARS
sbi stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"subl3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
sbi stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"subl3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) 	|	| |
sbi stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"subl3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) 	|	| |
#ifdef REGVARS
sbi sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"subl3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
sbi lol stf $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"subl3\t%[1],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
sbi sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"subl3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
sbi sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"subl3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
sbi ste $1==4	| source4 source4 |
			remove(externals)
			"subl3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})			|	| |
sbi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sbi"			     |	     | |
mli $1==4	| source4 sreg4 |
			"mull2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,16) + %[1]
...		| sreg4 source4 |
			"mull2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,16) + %[2]
...		| source4 source4 |
			allocate(%[1],%[2],REG)
			"mull3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]  | | (4,16)+%[1]+%[2]
#ifdef REGVARS
mli stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"mull3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
mli stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mull3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) 	|	| |
mli stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mull3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) 	|	| |
#ifdef REGVARS
mli sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"mull3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
mli lol stf $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"mull3\t%[1],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
mli sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"mull3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
mli sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"mull3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
mli ste $1==4	| source4 source4 |
			remove(externals)
			"mull3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})			|	| |
mli !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.mli"			     |	     | |
dvi $1==4	| source4 sreg4 |
			"divl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		    | %[2]  | | (3,98) + %[1]
...		| source4 source4 |
			allocate(%[1],%[2],REG)
			"divl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,98)+%[1]+%[2]
#ifdef REGVARS
dvi stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"divl3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
dvi stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"divl3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) 	|	| |
dvi stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"divl3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) 	|	| |
#ifdef REGVARS
dvi sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"divl3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
dvi lol stf $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"divl3\t%[1],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
dvi sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"divl3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
dvi sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"divl3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
dvi ste $1==4	| source4 source4 |
			remove(externals)
			"divl3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})			|	| |
dvi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.dvi"			     |	     | |
rmi $1==4	| Xsource4 Xsource4 |
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],%[a]"
			setcc(%[a])				| %[a]	 | |
#ifdef REGVARS
rmi stl $1==4 && inreg($2)==2
		| Xsource4 Xsource4 |
			remove(regvar($2))
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))		|	| |
#endif /* REGVARS */
rmi stl $1==4 && $2<0
		| Xsource4 Xsource4 |
			remove(displaced)
			remove(LOCALS,(%[num]<=$2+3 && %[num]+%[size]>$2))
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})		|	| |
rmi stl $1==4 && $2>=0
		| Xsource4 Xsource4 |
			remove(displaced)
			remove(LOCALS,(%[num]<=$2+3 && %[num]+%[size]>$2))
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})		|	| |
#ifdef REGVARS
rmi sil $1==4 && inreg($2)==2
		| Xsource4 Xsource4 |
			REMEXTANDLOC
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
rmi lol stf $1==4 && inreg($2)==2
		| Xsource4 Xsource4 |
			REMEXTANDLOC
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
rmi sil $1==4 && $2<0
		| Xsource4 Xsource4 |
			REMEXTANDLOC
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
rmi sil $1==4 && $2>=0
		| Xsource4 Xsource4 |
			REMEXTANDLOC
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
rmi ste $1==4	| Xsource4 Xsource4 |
			remove(externals)
			allocate(REG)
			"divl3\t%[1],%[2],%[a]"
			"mull2\t%[1],%[a]"
			"subl3\t%[a],%[2],$2"
			setcc({EXTERNAL4,$2})			|	| |
rmi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.rmi"
			erase(R0)				|	| |
ngi $1==4	| source4 |
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			setcc(%[a])				| %[a]	| |
#ifdef REGVARS
ngi stl $1==4 && inreg($2)==2
		| source4 |
			remove(regvar($2))
			"mnegl\t%[1],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2)) 		|	| |
#endif /* REGVARS */
ngi stl $1==4 && $2<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mnegl\t%[1],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) 	|	| |
ngi stl $1==4 && $2>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mnegl\t%[1],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) 	|	| |
#ifdef REGVARS
ngi sil $1==4 && inreg($2)==2
		| source4 |
			REMEXTANDLOC
			"mnegl\t%[1],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
ngi lol stf $1==4 && inreg($2)==2
		| source4 |
			REMEXTANDLOC
			"mnegl\t%[1],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
ngi sil $1==4 && $2<0
		| source4 |
			REMEXTANDLOC
			"mnegl\t%[1],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
ngi sil $1==4 && $2>=0
		| source4 |
			REMEXTANDLOC
			"mnegl\t%[1],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
ngi ste $1==4	| source4 |
			remove(externals)
			"mnegl\t%[1],$2"
			setcc({EXTERNAL4,$2})			|	| |
ngi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.ngi"				 |	 | |
sli $1==4	| source1or2or4 source4 |
			allocate(%[1],%[2],REG)
			"ashl\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]  | | (4,4)+%[1]+%[2]
#ifdef REGVARS
sli stl $1==4 && inreg($2)==2
		| source1or2or4 source4 |
			remove(regvar($2))
			"ashl\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
sli stl $1==4 && $2<0
		| source1or2or4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"ashl\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
sli stl $1==4 && $2>=0
		| source1or2or4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"ashl\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
sli sil $1==4 && inreg($2)==2
		| source1or2or4 source4 |
			REMEXTANDLOC
			"ashl\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
sli lol stf $1==4 && inreg($2)==2
		| source1or2or4 source4 |
			REMEXTANDLOC
			"ashl\t%[1],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| |
#endif /* REGVARS */
sli sil $1==4 && $2<0
		| source1or2or4 source4 |
			REMEXTANDLOC
			"ashl\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
sli sil $1==4 && $2>=0
		| source1or2or4 source4 |
			REMEXTANDLOC
			"ashl\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
sli ste $1==4	| source1or2or4 source4 |
			remove(externals)
			"ashl\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| | (8,10)+%[1]+%[2]
sli !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sli"
			erase(R0)				|	| |
sri $1==4	| source4 source4 |
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (7,8)+%[1]+%[2]
...		| NC CONST source4 |
			allocate(%[2],REG)
			"ashl\t$$%(0-%[1.num]%),%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
#ifdef REGVARS
sri stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| | (9,14)+%[1]+%[2]
...		| NC CONST source4 |
			remove(regvar($2))
			"ashl\t$$%(0-%[1.num]%),%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| | (6,10)+%[1]+%[2]
#endif /* REGVARS */
sri stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) |	| | (9,11)+%[1]+%[2]
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"ashl\t$$%(0-%[1.num]%),%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) |	| | (6,7)+%[1]+%[2]
sri stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) |	| | (9,11)+%[1]+%[2]
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"ashl\t$$%(0-%[1.num]%),%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) |	| | (6,7)+%[1]+%[2]
#ifdef REGVARS
sri sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)}) |	| | (9,14)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"ashl\t$$%(0-%[1.num]%),%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)}) |	| | (6,10)+%[1]+%[2]
sri lol stf $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1], REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)})	|	| | (9,14)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"ashl\t$$%(0-%[1.num]%),%[2],$3(%(regvar($2)%))"
			setcc({displ4,regvar($2),tostring($3)}) |	| | (6,10)+%[1]+%[2]
#endif /* REGVARS */
sri sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})
						|	| | (9,17)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"ashl\t$$%(0-%[1.num]%),%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})
						|	| | (6,13)+%[1]+%[2]
sri sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})
						|	| | (9,17)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"ashl\t$$%(0-%[1.num]%),%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})
						|	| | (6,13)+%[1]+%[2]
sri ste $1==4	| source4 source4 |
			remove(externals)
			allocate(%[1],REG)
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| | (11,14)+%[1]+%[2]
...		| NC CONST source4 |
			remove(externals)
			"ashl\t$$%(0-%[1.num]%),%[2],$2"
			setcc({EXTERNAL4,$2})	|	| | (8,10)+%[1]+%[2]
sri !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sri"
			erase(R0)				|	| |

/************************************************
 * Group 4 : Unsigned arithmetic		*
 ************************************************/

adu		| |				|	| adi $1 |
sbu		| |				|	| sbi $1 |
mlu		| |				|	| mli $1 |
dvu $1==4	| STACK |
			"jsb\t.dvu4"		| R0	| |
dvu !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.dvu"
			erase(R0)			|	| |
rmu $1==4	| STACK |
			"jsb\t.rmu4"			| R0	| |
rmu !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.rmu"
			erase(R0)			|	| |
slu		| |					| | sli $1 |
loc slu		| |					| | loc $1 sli $2 |
sru $1==4	| source4 source4 |
			allocate(%[1],REG,QREG)
			"mnegl\t%[1],%[a]"
			move(%[2],%[b.1])
			move({CONST4,0},%[b.2])
			"ashq\t%[a],%[b],%[b]"
			erase(%[b])		| %[b.1] | | (10,12)+%[1]
...		| NC CONST source4 |
			allocate(%[2],QREG)
			move(%[2],%[a.1])
			move({CONST4,0},%[a.2])
			"ashq\t$$%(0-%[1.num]%),%[a],%[a]"
			erase(%[a])		| %[a.1] | | (4,4)+%[1]
sru !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sru"
			erase(R0)			|	| |

/****************************************
 * Group 5 : Floating point arithmetic	*
 ****************************************/

adf $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"addf3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,8)+%[1]+%[2]
#ifdef FLOAT4
...		| source4 sreg4 |
			"addf2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,8) + %[1]
...		| sreg4 source4 |
			"addf2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,8) + %[2]
#ifdef REGVARS
adf stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"addf3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))	|	| |
#endif /* REGVARS */
adf stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"addf3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	   | |
adf stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"addf3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	   | |
#ifdef REGVARS
adf sil $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"addf3\t%[1],%[2],(%(regvar($2)%))"
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
adf sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"addf3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
adf sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"addf3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
adf ste $1==4	| source4 source4 |
			remove(externals)
			"addf3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
#endif /* FLOAT4 */
adf $1==8	| source8 source8 |
			allocate(%[1],%[2],QREG)
			"addd3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,14)+%[1]+%[2]
#ifdef FLOAT8
...		| source8 sreg8 |
			"addd2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,14) + %[1]
...		| sreg8 source8 |
			"addd2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,14) + %[2]
adf sdl $1==8 && $2<0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"addd3\t%[1],%[2],$2(fp)"
			setcc({LOCAL8,LB,$2,8})    |	   | |
adf sdl $1==8 && $2>=0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"addd3\t%[1],%[2],$2(ap)"
			setcc({LOCAL8,AP,$2,8})    |	   | |
adf sde $1==8	| source8 source8 |
			remove(externals)
			"addd3\t%[1],%[2],$2"
			setcc({EXTERNAL8,$2})	|	| |
#endif /* FLOAT8 */
adf !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.adf"		 |	 | |
sbf $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"subf3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,8)+%[1]+%[2]
#ifdef FLOAT4
...		| NC source4 sreg4 |
			"subf2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,8) + %[1]
#ifdef REGVARS
sbf stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"subf3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
sbf stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"subf3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})    |	| |
sbf stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"subf3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
sbf sil $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"subf3\t%[1],%[2],(%(regvar($2)%))"
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
sbf sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"subf3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
sbf sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"subf3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
sbf ste $1==4	| source4 source4 |
			remove(externals)
			"subf3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
#endif /* FLOAT4 */
sbf $1==8	| source8 source8 |
			allocate(%[1],%[2],QREG)
			"subd3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,14)+%[1]+%[2]
#ifdef FLOAT8
...		| source8 sreg8 |
			"subd2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,14) + %[1]
sbf sdl $1==8 && $2<0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"subd3\t%[1],%[2],$2(fp)"
			setcc({LOCAL8,LB,$2,8})    |	   | |
sbf sdl $1==8 && $2>=0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"subd3\t%[1],%[2],$2(ap)"
			setcc({LOCAL8,AP,$2,8})    |	   | |
sbf sde $1==8	| source8 source8 |
			remove(externals)
			"subd3\t%[1],%[2],$2"
			setcc({EXTERNAL8,$2})	|	| |
#endif /* FLOAT8 */
sbf !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sbf"		 |	 | |
mlf $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"mulf3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,12)+%[1]+%[2]
#ifdef FLOAT4
...		| source4 sreg4 |
			"mulf2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,12) + %[1]
...		| sreg4 source4 |
			"mulf2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,12) + %[2]
#ifdef REGVARS
mlf stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"mulf3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))	|	| |
#endif /* REGVARS */
mlf stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"mulf3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	   | |
mlf stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"mulf3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
mlf sil $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"mulf3\t%[1],%[2],(%(regvar($2)%))"
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
mlf sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"mulf3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	   | |
mlf sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"mulf3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	   | |
mlf ste $1==4	| source4 source4 |
			remove(externals)
			"mulf3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
#endif /* FLOAT4 */
mlf $1==8	| source8 source8 |
			allocate(%[1],%[2],QREG)
			"muld3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,20)+%[1]+%[2]
#ifdef FLOAT8
...		| source8 sreg8 |
			"muld2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,20) + %[1]
...		| sreg8 source8 |
			"muld2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,20) + %[2]
mlf sdl $1==8 && $2<0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"muld3\t%[1],%[2],$2(fp)"
			setcc({LOCAL8,LB,$2,8})	|	   | |
mlf sdl $1==8 && $2>=0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"muld3\t%[1],%[2],$2(ap)"
			setcc({LOCAL8,AP,$2,8})	|	   | |
mlf sde $1==8	| source8 source8 |
			remove(externals)
			"muld3\t%[1],%[2],$2"
			setcc({EXTERNAL8,$2})	|	| |
#endif /* FLOAT8 */
mlf !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.mlf"		 |	 | |
dvf $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"divf3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,46)+%[1]+%[2]
#ifdef FLOAT4
...		| source4 sreg4 |
			"divf2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,46) + %[1]
#ifdef REGVARS
dvf stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"divf3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
dvf stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"divf3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	   | |
dvf stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"divf3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	   | |
#ifdef REGVARS
dvf sil $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"divf3\t%[1],%[2],(%(regvar($2)%))"
			setcc(regvar($2))		|	   | |
#endif /* REGVARS */
dvf sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"divf3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	   | |
dvf sil $1==4 &&$2>=0
		| source4 source4 |
			REMEXTANDLOC
			"divf3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	   | |
dvf ste $1==4	| source4 source4 |
			remove(externals)
			"divf3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
#endif /* FLOAT4 */
dvf $1==8	| source8 source8 |
			allocate(%[1],%[2],QREG)
			"divd3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,80)+%[1]+%[2]
#ifdef FLOAT8
...		| source8 sreg8 |
			"divd2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,80) + %[1]
dvf sdl $1==8 && $2<0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"divd3\t%[1],%[2],$2(fp)"
			setcc({LOCAL8,LB,$2,8})	|	   | |
dvf sdl $1==8 && $2>=0
		| source8 source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"divd3\t%[1],%[2],$2(ap)"
			setcc({LOCAL8,AP,$2,8})	|	   | |
dvf sde $1==8	| source8 source8 |
			remove(externals)
			"divd3\t%[1],%[2],$2"
			setcc({EXTERNAL8,$2})	|	| |
#endif /* FLOAT8 */
dvf !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.dvf"		 |	 | |
ngf $1==4	| source4 |
			allocate(%[1],REG)
			"mnegf\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef FLOAT4
#ifdef REGVARS
ngf stl $1==4 && inreg($2)==2
		| source4 |
			remove(regvar($2))
			"mnegf\t%[1],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
ngf stl $1==4 && $2<0
		| source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"mnegf\t%[1],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	   | |
ngf stl $1==4 && $2>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+3 && %[num]+%[size] > $2)
			"mnegf\t%[1],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	   | |
#ifdef REGVARS
ngf sil $1==4 && inreg($2)==2
		| source4 |
			remove(regvar($2))
			"mnegf\t%[1],(%(regvar($2)%))"
			setcc(regvar($2))	|	   | |
#endif /* REGVARS */
ngf sil $1==4 && $2<0
		| source4 |
			REMEXTANDLOC
			"mnegf\t%[1],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	   | |
ngf sil $1==4 && $2>=0
		| source4 |
			REMEXTANDLOC
			"mnegf\t%[1],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	   | |
ngf ste $1==4	| source4 |
			remove(externals)
			"mnegf\t%[1],$2"
			setcc({EXTERNAL4,$2})	|	| |
#endif /* FLOAT4 */
ngf $1==8	| source8 |
			allocate(%[1],QREG)
			"mnegd\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef FLOAT8
ngf sdl $1==8 && $2<0
		| source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"mnegd\t%[1],$2(fp)"
			setcc({LOCAL8,LB,$2,8})	|	   | |
ngf sdl $1==8 && $2>=0
		| source8 |
			remove(displaced)
			remove(LOCALS,%[num] <= $2+7 && %[num]+%[size] > $2)
			"mnegd\t%[1],$2(ap)"
			setcc({LOCAL8,AP,$2,8})	|	   | |
ngf sde $1==8	| source8 |
			remove(externals)
			"mnegd\t%[1],$2"
			setcc({EXTERNAL8,$2})	|	| |
#endif /* FLOAT8 */
ngf !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.ngf"		 |	 | |
fif $1==4	| source4 source4 |
			allocate(%[1],%[2],REG,REG)
			"mulf3\t%[1],%[2],%[a]"
			/* the assembler does not do immediate floating point */
			"cvtlf $$1,%[b]"
			"emodf\t%[a],$$0,%[b],-(sp),%[b]"
			/*
			 * Don't trust the integer part.
			 * Overflow could occur.
			 */
			"tstl\t(sp)+"
			"subf2\t%[b],%[a]"	| %[b] %[a]	| |
fif $1==8	| source8 source8 |
			allocate(%[1],%[2],QREG,QREG)
			"muld3\t%[1],%[2],%[a]"
			"cvtld $$1,%[b]"
			"emodd\t%[a],$$0,%[b],-(sp),%[b]"
			"tstl\t(sp)+"
			"subd2\t%[b],%[a]"	| %[b] %[a]	| |
fif !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.fif"
			erase(R0)		|	| |
fef defined($1)	| |
			remove(ALL)
			move({CONST4, $1}, R0)
			"jsb\t.fef"
			erase(R0)		|	| |
fef !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.fef"
			erase(R0)		|	| |

/********************************
 * Group 6 : pointer arithmetic *
 ********************************/

adp $1==0	| | | | |
adp		| NC ADDR_EXTERNAL |
			| {ADDR_EXTERNAL,%[1.ind]+"+"+tostring($1)} | |
...		| NC ADDR_LOCAL |
			| {ADDR_LOCAL,%[1.reg],%[1.num]+$1} | |
...		| NC adisplind1 |
			| {adisplind1,%[1.ireg],%[1.reg],
					%[1.ind]+"+"+tostring($1)} | |
...		| NC adispldefind1 |
			allocate(%[1.ireg],REG)
			"addl3\t$$$1,%[1.ireg],%[a]"
			| {adispldefind1,%[a],%[1.reg],%[1.ind]}	| |
...		| NC aextdefind1 |
			allocate(%[1],REG)
			"addl3\t$$$1,%[1.ireg],%[a]"
			| {aextdefind1,%[a],%[1.ind]}	| |
...		| NC adispl | | {adispl,%[1.reg],%[1.ind]+"+"+tostring($1)} | |
...		| reg4 | 	| {adispl,%[1],tostring($1)}		  | |
adp sil		| | | {CONST4,$1}		| adi 4 sil $2 |
adp stl		| | | {CONST4,$1}		| adi 4 stl $2 |
adp ste		| | | {CONST4,$1}		| adi 4 ste $2 |
adp dup $2==4	| | | {CONST4,$1}		| adi 4 dup 4 |
adp lol stf	| | | {CONST4,$1}		| adi 4 lol $2 stf $3 |
adp lol sti $3==4
		| | | {CONST4,$1}		| adi 4 lol $2 sti 4 |
adp loe sti $3==4
		| | | {CONST4,$1}		| adi 4 loe $2 sti 4 |
adp cms $2==4	| | | {CONST4,$1}		| adi 4 cms 4 |
loe lof adp loe stf $1==$4 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={EXTERNAL4,$1})
			"addl2\t$$$3,$2(%[a])"		|	| |
lol lof adp lol stf $1<0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,LB,$1,4})
			"addl2\t$$$3,$2(%[a])"		|	| |
lol lof adp lol stf $1>=0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,AP,$1,4})
			"addl2\t$$$3,$2(%[a])"		|	| |
ads $1==4	| NC reg4 adispl |
			| {adisplind1,%[1],%[2.reg],%[2.ind]}	| |
...		| NC reg4 ADDR_LOCAL |
			| {adisplind1,%[1],%[2.reg],tostring(%[2.num])}	| |
...		| NC reg4 ADDR_EXTERNAL |
			| {adispl,%[1],%[2.ind]}		| |
...		| NC reg4 aextind2 |
			| {adisplind2,%[2.ireg],%[1],%[2.ind]}	| |
...		| NC reg4 aextind4 |
			| {adisplind4,%[2.ireg],%[1],%[2.ind]}	| |
...		| NC reg4 aextind8 |
			| {adisplind8,%[2.ireg],%[1],%[2.ind]}	| |
...		| NC reg4 displ4 |
			| {adispldefind1,%[1],%[2.reg],%[2.ind]}	| |
...		| NC reg4 LOCAL4 |
			| {adispldefind1,%[1],%[2.reg],tostring(%[2.num])} | |
...		| NC reg4 regdef4 |
			| {adispldefind1,%[1],%[2.reg],"0"}	| |
...		| NC reg4 EXTERNAL4 |
			| {aextdefind1,%[1],%[2.ind]}		| |
...		| NC reg4 reg4 |	| {adisplind1,%[1],%[2],"0"}	| |
...		| |		|		| adi 4 |
ads		| |		|		| loc $1 loc 4 cii ads 4 |
ads !defined($1) | |		|		| loc 4 cii ads 4 |
sbs $1==4	| |		|		| sbu $1 |
sbs $1!=4	| |		|		| sbu 4 loc 4 loc $1 cii |
sbs !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sbs"
			erase(R0)		|	| |
adp dup sil adp $1==(0-$4) && $2==4 
		| reg4 | | %[1] %[1]	| adp $1 sil $3 |
adp dup loe sti adp $1==(0-$5) && $2==4 && $4==4
		| reg4 | | %[1] %[1]	| adp $1 loe $3 sti 4 |
dup adp lol sti $1==4 && $4==4
		| bigsource4-regch4 |
			allocate(REG=%[1])
			| %[a] %[1] {CONST4,$2}
				| adi 4 lol $3 sti 4 |
dup adp loe sti $1==4 && $4==4
		| bigsource4-regch4 |
			allocate(REG=%[1])
			| %[a] %[1] {CONST4,$2}
				| adi 4 loe $3 sti 4 |
#ifdef REGVARS
lol lol adp stl loi $1==$4 && $2==$1 && inreg($1)==2 && $3==1 && $5==1
		| |	remove(regvar($1))
			erase(regvar($1))
			| {reginc1,regvar($1)}		| |
lol lol adp stl loi $1==$4 && $2==$1 && inreg($1)==2 && $3==2 && $5==2
		| |	remove(regvar($1))
			erase(regvar($1))
			| {reginc2,regvar($1)}		| |
lol lol adp stl loi $1==$4 && $2==$1 && inreg($1)==2 && $3==4 && $5==4
		| |	remove(regvar($1))
			erase(regvar($1))
			| {reginc4,regvar($1)}		| |
lol lol adp stl loi $1==$4 && $2==$1 && inreg($1)==2 && $3==8 && $5==8
		| |	remove(regvar($1))
			erase(regvar($1))
			| {reginc8,regvar($1)}		| |
lol adp dup stl loi $1==$4 && $2==(0-1) && inreg($1)==2 && $3==4 && $5==1
		| |	remove(regvar($1))
			erase(regvar($1))
			| {regdec1,regvar($1)}		| |
lol adp dup stl loi $1==$4 && $2==(0-2) && inreg($1)==2 && $3==4 && $5==2
		| |	remove(regvar($1))
			erase(regvar($1))
			| {regdec2,regvar($1)}		| |
lol adp stl lil $1==$4 && $2==(0-4) && inreg($1)==2 && $3==$1
		| |	remove(regvar($1))
			erase(regvar($1))
			| {regdec4,regvar($1)}		| |
lol adp dup stl loi $1==$4 && $2==(0-8) && inreg($1)==2 && $3==4 && $5==8
		| |	remove(regvar($1))
			erase(regvar($1))
			| {regdec8,regvar($1)}		| |
lol lol adp stl sti $1==$4 && $2==$1 && inreg($1)==2 && $3==1 && $5==1
		| NC source1 |
			REMEXTANDLOC
			remove(regvar($1))
			"movb\t%[1],(%(regvar($1)%))+"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| NC source2 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtwb\t%[1],(%(regvar($1)%))+"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtlb\t%[1],(%(regvar($1)%))+"
			erase(regvar($1))		|	| | (3,7)+%[1]
lol lol adp stl sti $1==$4 && $2==$1 && inreg($1)==2 && $3==2 && $5==2
		| NC source2 |
			REMEXTANDLOC
			remove(regvar($1))
			"movw\t%[1],(%(regvar($1)%))+"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtlw\t%[1],(%(regvar($1)%))+"
			erase(regvar($1))		|	| | (3,7)+%[1]
lol lol adp stl sti $1==$4 && $2==$1 && inreg($1)==2 && $3==4 && $5==4
		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			move(%[1],{reginc4,regvar($1)})
			erase(regvar($1))		|	| |
lol lol adp stl sti $1==$4 && $2==$1 && inreg($1)==2 && $3==8 && $5==8
		| source8 |
			REMEXTANDLOC
			remove(regvar($1))
			move(%[1],{reginc8,regvar($1)})
			erase(regvar($1))		|	| |
lol adp dup stl sti $1==$4 && inreg($1)==2 && $2==(0-1) && $3==4 && $5==1
		| NC source1 |
			REMEXTANDLOC
			remove(regvar($1))
			"movb\t%[1],-(%(regvar($1)%))"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| NC source2 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtwb\t%[1],-(%(regvar($1)%))"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtlb\t%[1],-(%(regvar($1)%))"
			erase(regvar($1))		|	| | (3,7)+%[1]
lol adp dup stl sti $1==$4 && inreg($1)==2 && $2==(0-2) && $3==4 && $5==2
		| NC source2 |
			REMEXTANDLOC
			remove(regvar($1))
			"movw\t%[1],-(%(regvar($1)%))"
			erase(regvar($1))		|	| | (3,7)+%[1]
...		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			"cvtlw\t%[1],-(%(regvar($1)%))"
			erase(regvar($1))		|	| | (3,7)+%[1]
lol adp stl sil $1==$4 && inreg($1)==2 && $2==(0-4) && $3==$4
		| source4 |
			REMEXTANDLOC
			remove(regvar($1))
			move(%[1],{regdec4,regvar($1)})
			erase(regvar($1))		|	| |
lol adp dup stl sti $1==$4 && inreg($1)==2 && $2==(0-8) && $3==4 && $5==8
		| source8 |
			REMEXTANDLOC
			remove(regvar($1))
			move(%[1],{regdec8,regvar($1)})
			erase(regvar($1))		|	| |
lol lol adp stl $1==$4 && $2==$4 && inreg($1)==2
		| |	remove(regvar($1))
			allocate(REG=regvar($1))
			"addl2\t$$$3,%(regvar($1)%)"
			erase(regvar($1))		| %[a]	| |
lol adp stl $1==$3 && inreg($1)==2
		| |	remove(regvar($1))
			"addl2\t$$$2,%(regvar($1)%)"
			erase(regvar($1))		|	| |
#endif /* REGVARS */
lol adp stl $1==$3 && $1<0
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"addl2\t$$$2,$1(fp)" 
			setcc({LOCAL4,LB,$1,4})	|	| |
lol adp stl $1==$3 && $1>=0
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"addl2\t$$$2,$1(ap)" 
			setcc({LOCAL4,AP,$1,4})	|	| |
lol lol adp stl $1==$4 && $2==$4 && $2<0
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			allocate(REG={LOCAL4,LB,$1,4})
			"addl2\t$$$3,$1(fp)"
			setcc({LOCAL4,LB,$1,4})	| %[a]	| |
lol lol adp stl $1==$4 && $2==$4
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			allocate(REG={LOCAL4,AP,$1,4})
			"addl2\t$$$3,$1(ap)"
			setcc({LOCAL4,AP,$1,4})	| %[a]	| |
#ifdef REGVARS
lil lil adp sil $1==$2 && $1==$4 && inreg($1)==2
		| |	REMEXTANDLOC
			allocate(REG={regdef4,regvar($1)})
			"addl2\t$$$3,(%(regvar($1)%))"
			setcc(regvar($1))	| %[a]	| |
lol lof dup adp lol stf $1==$5 && $2==$6 && $3==4 && inreg($1)==2
		| |	REMEXTANDLOC
			allocate(REG={displ4,regvar($1),tostring($2)})
			"addl2\t$$$4,$2(%(regvar($1)%))"
						| %[a]	| |
#endif
loe adp ste $1==$3
		| |	remove(externals)
			"addl2\t$$$2,$1"	|		| |
loe loe adp ste $1==$4 && $2==$1
		| |	remove(externals)
			allocate(REG={EXTERNAL4,$1})
			"addl2\t$$$3,$1"	| %[a]		| |

/****************************************
 * Group 7 : Increment/decrement/zero	*
 ****************************************/

lil inc dup sil $3==4 && $1==$4	| | | | lil $1 loc 1 adi 4 sil $1 lil $1 |
lil dec dup sil $3==4 && $1==$4	| | | | lil $1 loc 1 sbi 4 sil $1 lil $1 |
inc		| 	|	| {CONST1,1}	| adi 4 |
loe lof inc loe stf $1==$4 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={EXTERNAL4,$1})
			"incl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
lol lof inc lol stf $1<0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,LB,$1,4})
			"incl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
lol lof inc lol stf $1>=0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,AP,$1,4})
			"incl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
dec		|	|	| {CONST1,1}	| sbi 4 |
loe lof dec loe stf $1==$4 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={EXTERNAL4,$1})
			"decl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
lol lof dec lol stf $1<0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,LB,$1,4})
			"decl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
lol lof dec lol stf $1>=0 && $1==$4 && inreg($1)!=2 && $2==$5
		| |	REMEXTANDLOC
			allocate(REG={LOCAL4,AP,$1,4})
			"decl\t$2(%[a])"
			setcc({displ4,%[a],tostring($2)})	|	| |
#ifdef REGVARS
inl inreg($1)==2 | |	remove(regvar($1))
			"incl\t%(regvar($1)%)"
			erase(regvar($1))
			setcc(regvar($1))	|	| |
#endif /* REGVARS */
inl $1<0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"incl\t$1(fp)"
			setcc({LOCAL4,LB,$1,4})	|	| |
inl $1>=0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"incl\t$1(ap)"
			setcc({LOCAL4,AP,$1,4})	|	| |
#ifdef REGVARS
lol inl $1==$2 && inreg($1)==2
		| |	remove(regvar($1))
			allocate(REG=regvar($1))
			"incl\t%(regvar($1)%)"
			erase(regvar($1))
			setcc(regvar($1))	| %[a]	| |
#endif /* REGVARS */
ine		| |	remove(externals)
			"incl\t$1"
			setcc({EXTERNAL4,$1})	|	| |
#ifdef REGVARS
del inreg($1)==2 | |	remove(regvar($1))
			"decl\t%(regvar($1)%)"
			erase(regvar($1))
			setcc(regvar($1))	|	| |
#endif /* REGVARS */
del $1<0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"decl\t$1(fp)"
			setcc({LOCAL4,LB,$1,4})	|	| |
del $1>=0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"decl\t$1(ap)"
			setcc({LOCAL4,AP,$1,4})	|	| |
#ifdef REGVARS
lol del $1==$2 && inreg($1)==2
		| |	remove(regvar($1))
			allocate(REG=regvar($1))
			"decl\t%(regvar($1)%)"
			erase(regvar($1))
			setcc(regvar($1))	| %[a]	| |
#endif /* REGVARS */
dee		| |	remove(externals)
			"decl\t$1"
			setcc({EXTERNAL4,$1})	|	| |
#ifdef REGVARS
zrl inreg($1)==2 | |	remove(regvar($1))
			"clrl\t%(regvar($1)%)"
			erase(regvar($1))
			setcc(regvar($1))	|	| |
#endif /* REGVARS */
zrl $1<0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"clrl\t$1(fp)"
			setcc({LOCAL4,LB,$1,4})	|	| |
zrl $1>=0	| |	remove(displaced)
			remove(LOCALS,%[num]<=$1+3 && %[num]+%[size]>$1)
			"clrl\t$1(ap)"
			setcc({LOCAL4,AP,$1,4})	|	| |
zrl zrl $1==$2+4 && $1<0
#ifdef REGVARS
	&& inreg($1)<2 && inreg($2)<2
#endif /* REGVARS */
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$2+7 && %[num]+%[size]>$2)
			"clrq\t$2(fp)"
			setcc({LOCAL8,LB,$2,8})	|	| |
zrl zrl $1==$2+4 && $1>=0
#ifdef REGVARS
	&& inreg($1)<2 && inreg($2)<2
#endif /* REGVARS */
		| |	remove(displaced)
			remove(LOCALS,%[num]<=$2+7 && %[num]+%[size]>$2)
			"clrq\t$2(ap)"
			setcc({LOCAL8,AP,$2,8})	|	| |
zrl zrl $1==$2-4 | |				|	| zrl $2 zrl $1 |
zre		| |	remove(externals)
			"clrl\t$1"
			setcc({EXTERNAL4,$1})	|	| |
zrf $1==4	| |	allocate(REG)
			"clrl\t%[a]"		| %[a]	| |
zrf $1==8	| |	allocate(QREG)
			"clrq\t%[a]"		| %[a]	| |
zer $1==4	| |		| {CONST4,0}		| |
zer $1==8	| |	allocate(QREG)
			"clrq\t%[a]"		| %[a]	| |
zer $1>8&&$1<=32	| STACK |
			"clrq\t-(sp)"		|	| zer $1-8 |
zer defined($1)	| STACK |
			move({CONST4,$1/4},R0)
#ifdef LOCLABS
			"1:\tclrl\t-(sp)"
			"sobgtr\tr0,1b"
#else /* LOCLABS */
			"clrl\t-(sp)"
			"sobgtr\tr0,.-2"
#endif /* LOCLABS */
			erase(R0)		|	| |
zer !defined($1) | source1or2or4 |
			remove(ALL)
			move(%[1],R0)
#ifdef LOCLABS
			"1:\tclrl\t-(sp)"
			"sobgtr\tr0,1b"
#else /* LOCLABS */
			"clrl\t-(sp)"
			"sobgtr\tr0,.-2"
#endif /* LOCLABS */
			erase(R0)		|	| |

/********************************
 * Group 8 : Convertions	*
 ********************************/

cii		| STACK |
			"jsb\t.cii"		|	| |
cfi		| STACK |
			"jsb\t.cfi"		|	| |
cfu		| STACK |
			"jsb\t.cfu"		|	| |
cuf		| STACK |
			"jsb\t.cuf"		|	| |
cif		| STACK |
			"jsb\t.cif"		|	| |
cff		| STACK |
			"jsb\t.cff"		|	| |
cuu		| STACK |
			"jsb\t.cuu"		|	| |
ciu		| |				|	| cuu |
cui		| STACK |
			"jsb\t.cui"		|	| |
#ifdef REGVARS
loc loc cii stl $1==1 && $2==4 && inreg($4)==2
		| source1or2or4 |
			remove(regvar($4))
			"cvtbl\t%[1],%(regvar($4)%)"
			erase(regvar($1))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cii stl $1==1 && $2==4 && $4<0
		| source1or2or4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtbl\t%[1],$4(fp)"
			setcc({LOCAL4,LB,$4,4})	|	| |
loc loc cii stl $1==1 && $2==4 && $4>=0
		| source1or2or4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtbl\t%[1],$4(ap)"
			setcc({LOCAL4,AP,$4,4})	|	| |
loc loc cii ste $1==1 && $2==4	| source1or2or4 |
			remove(externals)
			"cvtbl\t%[1],$4"
			setcc({EXTERNAL4,$4})	|	| |
loc loc cii $1==1 && $2==4	| source1or2or4 |
			allocate(%[1],REG)
			"cvtbl\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef REGVARS
loc loc cii stl $1==2 && $2==4 && inreg($4)==2
		| source2or4 |
			remove(regvar($4))
			"cvtwl\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cii stl $1==2 && $2==4 && $4<0
		| source2or4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtwl\t%[1],$4(fp)"
			setcc({LOCAL4,LB,$4,4})	|	| |
loc loc cii stl $1==2 && $2==4 && $4>=0
		| source2or4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtwl\t%[1],$4(ap)"
			setcc({LOCAL4,AP,$4,4})	|	| |
loc loc cii ste $1==2 && $2==4	| source2or4 |
			remove(externals)
			"cvtwl\t%[1],$4"
			setcc({EXTERNAL4,$4})	|	| |
loc loc cii $1==2 && $2==4	| source2or4 |
			allocate(%[1],REG)
			"cvtwl\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
loc loc cui $1==$2	|	|	|	|	|
loc loc ciu $1==$2	|	|	|	|	|
#ifdef FLOAT4
#ifdef REGVARS
loc loc cfi stl $1==4 && $2==4 && inreg($4)==2
		| source4 |
			remove(regvar($4))
			"cvtfl\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cfi stl $1==4 && $2==4 && $4<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtfl\t%[1],$4(fp)"
			setcc({LOCAL4,AP,$4,4}) |	| |
loc loc cfi stl $1==4 && $2==4 && $4>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtfl\t%[1],$4(ap)"
			setcc({LOCAL4,AP,$4,4}) |	| |
loc loc cfi ste $1==4 && $2==4	| source4 |
			remove(externals)
			"cvtfl\t%[1],$4"
			setcc({EXTERNAL4,$4})	|	| |
#endif /* FLOAT4 */
loc loc cfi $1==4 && $2==4	| source4 |
			allocate(%[1],REG)
			"cvtfl\t%[1],%[a]"
			setcc(%[a])		| %[a]	| | (3,4) + %[1]
#ifdef FLOAT8
#ifdef REGVARS
loc loc cfi stl $1==8 && $2==4 && inreg($4)==2
		| source8 |
			remove(regvar($4))
			"cvtdl\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cfi stl $1==8 && $2==4 && $4<0
		| source8 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtdl\t%[1],$4(fp)"
			setcc({LOCAL4,LB,$4,4})	|	| |
loc loc cfi stl $1==8 && $2==4 && $4>=0
		| source8 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtdl\t%[1],$4(ap)"
			setcc({LOCAL4,AP,$4,4})	|	| |
loc loc cfi ste $1==8 && $2==4	| source8 |
			remove(externals)
			"cvtdl\t%[1],$4"
			setcc({EXTERNAL4,$4})	|	| |
#endif /* FLOAT8 */
loc loc cfi $1==8 && $2==4	| source8 |
			allocate(%[1],REG)
			"cvtdl\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef FLOAT4
#ifdef REGVARS
loc loc cif stl $1==4 && $2==4 && inreg($4)==2
		| source4 |
			remove(regvar($4))
			"cvtlf\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cif stl $1==4 && $2==4 && $4<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtlf\t%[1],$4(fp)"	|	| |
loc loc cif stl $1==4 && $2==4 && $4>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtlf\t%[1],$4(ap)"	|	| |
loc loc cif ste $1==4 && $2==4	| source4 |
			remove(externals)
			"cvtlf\t%[1],$4"	|	| |
#endif /* FLOAT4 */
loc loc cif $1==4 && $2==4	| source4 |
			allocate(%[1],REG)
			"cvtlf\t%[1],%[a]"	| %[a]	| |
#ifdef FLOAT8
/* No double registervariables
#ifdef REGVARS
loc loc cif sdl $1==4 && $2==8 && inreg($4)==2
		| source4 |
			remove(regvar($4))
			"cvtld\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
*/
loc loc cif sdl $1==4 && $2==8 && $4<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtld\t%[1],$4(fp)"	|	| |
loc loc cif sdl $1==4 && $2==8 && $4>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtld\t%[1],$4(ap)"	|	| |
loc loc cif sde $1==4 && $2==8	| source4 |
			remove(externals)
			"cvtld\t%[1],$4"	|	| |
#endif /* FLOAT8 */
loc loc cif $1==4 && $2==8	| source4 |
			allocate(%[1],QREG)
			"cvtld\t%[1],%[a]"	| %[a]	| |
loc loc cfu $1==4	| source4 |
			allocate(%[1],REG=%[1])
			"bicl2\t$$32768,%[a]"	| %[a]	| loc $1 loc $2 cfi |
loc loc cfu $1==8	| source8 |
			allocate(%[1],QREG=%[1])
			"bicl2\t$$32768,%[a]"	| %[a]	| loc $1 loc $2 cfi |
#ifdef FLOAT8
/* No double registervariables
#ifdef REGVARS
loc loc cff sdl $1==4 && $2==8 && inreg($4)==2
		| source4 |
			remove(regvar($4))
			"cvtfd\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
*/
loc loc cff sdl $1==4 && $2==8 && $4<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+7 && %[num]+%[size] > $4))
			"cvtfd\t%[1],$4(fp)"	|	| |
loc loc cff sdl $1==4 && $2==8 && $4>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+7 && %[num]+%[size] > $4))
			"cvtfd\t%[1],$4(ap)"	|	| |
loc loc cff sde $1==4 && $2==8	| source4 |
			remove(externals)
			"cvtfd\t%[1],$4"	|	| |
#endif /* FLOAT8 */
loc loc cff $1==4 && $2==8	| source4 |
			allocate(%[1],QREG)
			"cvtfd\t%[1],%[a]"	| %[a]	| |
#ifdef FLOAT4
#ifdef REGVARS
loc loc cff stl $1==8 && $2==4 && inreg($4)==2
		| source8 |
			remove(regvar($4))
			"cvtdf\t%[1],%(regvar($4)%)"
			erase(regvar($4))
			setcc(regvar($4))	|	| |
#endif /* REGVARS */
loc loc cff stl $1==8 && $2==4 && $4<0
		| source8 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtdf\t%[1],$4(fp)"	|	| |
loc loc cff stl $1==8 && $2==4 && $4>=0
		| source8 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $4+3 && %[num]+%[size] > $4))
			"cvtdf\t%[1],$4(ap)"	|	| |
loc loc cff ste $1==8 && $2==4	| source8 |
			remove(externals)
			"cvtdf\t%[1],$4"	|	| |
#endif /* FLOAT4 */
loc loc cff $1==8 && $2==4	| source8 |
			allocate(%[1],REG)
			"cvtdf\t%[1],%[a]"	| %[a]	| |

/****************************************
 * Group 9 : Logical instructions	*
 ****************************************/

and $1==4	| source4 source4 |
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (7,6)+%[1]+%[2]
...		| NC CONST source4 |
			allocate(%[2],REG)
			"bicl3\t$$~%[1.num],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,3)+%[1]+%[2]
...		| NC source4 CONST |
			allocate(%[1],REG)
			"bicl3\t$$~%[2.num],%[1],%[a]"
			setcc(%[a])		| %[a]	| | (4,3)+%[1]+%[2]
and zeq $1==4	| source4 source4 |
			remove(ALL)
			"bitl\t%[1],%[2]"
			"jeql\t$2"	|	| |
and zne $1==4	| source4 source4 |
			remove(ALL)
			"bitl\t%[1],%[2]"
			"jneq\t$2"	|	| |
and tne $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"bitl\t%[1],%[2]"
#ifdef LOCLABS
			"jeql\t1f"
			"incl\t%[a]\n1:"
#else
			"jeql\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])		| %[a]	| |
#ifdef REGVARS
and stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| | (8,8)+%[1]+%[2]
...		| NC CONST source4 |
			remove(regvar($2))
			"bicl3\t$$~%[1.num],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| | (4,4)+%[1]+%[2]
...		| NC source4 CONST |
			remove(regvar($2))
			"bicl3\t$$~%[2.num],%[1],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| | (4,4)+%[1]+%[2]
#endif /* REGVARS */
and stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| | (9,12)+%[1]+%[2]
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bicl3\t$$~%[1.num],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| | (6,9)+%[1]+%[2]
...		| NC source4 CONST |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bicl3\t$$~%[2.num],%[1],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| | (6,9)+%[1]+%[2]
and stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| | (9,12)+%[1]+%[2]
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bicl3\t$$~%[1.num],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| | (6,9)+%[1]+%[2]
...		| NC source4 CONST |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bicl3\t$$~%[2.num],%[1],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| | (6,9)+%[1]+%[2]
#ifdef REGVARS
and sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})
						|	| | (9,15)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"bicl3\t$$~%[1.num],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})
						|	| | (6,12)+%[1]+%[2]
...		| NC source4 CONST |
			REMEXTANDLOC
			"bicl3\t$$~%[2.num],%[1],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})
						|	| | (6,12)+%[1]+%[2]
#endif /* REGVARS */
and sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})
						|	| | (9,15)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"bicl3\t$$~%[1.num],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})
						|	| | (6,12)+%[1]+%[2]
...		| NC source4 CONST |
			REMEXTANDLOC
			"bicl3\t$$~%[2.num],%[1],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})
						|	| | (6,12)+%[1]+%[2]
and sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})
						|	| | (9,15)+%[1]+%[2]
...		| NC CONST source4 |
			REMEXTANDLOC
			"bicl3\t$$~%[1.num],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})
						|	| | (6,12)+%[1]+%[2]
...		| NC source4 CONST |
			REMEXTANDLOC
			"bicl3\t$$~%[2.num],%[1],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})
						|	| | (6,12)+%[1]+%[2]
and ste $1==4	| source4 source4 |
			remove(externals)
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			"bicl3\t%[a],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| | (11,12)+%[1]+%[2]
...		| NC CONST source4 |
			remove(externals)
			"bicl3\t$$~%[1.num],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| | (8,9)+%[1]+%[2]
...		| NC source4 CONST |
			remove(externals)
			"bicl3\t$$~%[2.num],%[1],$2"
			setcc({EXTERNAL4,$2})	|	| | (8,9)+%[1]+%[2]
and $1==8	| sreg8 sreg8 |
			"mcoml\t%[1.1],%[1.1]"
			"mcoml\t%[1.2],%[1.2]"
			"bicl2\t%[1.1],%[2.1]"
			"bicl2\t%[1.2],%[2.2]"
			erase(%[1]) erase(%[2])	| %[2]	| |
and defined($1) | |	remove(ALL)
			move({CONST4,$1},R0)
			"jsb\t.and"
			erase(R0)		|	| |
and !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.and"
			erase(R0)		|	| |
ior $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"bisl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
...		| NC sreg4 source4 |
			"bisl2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,4) + %[2]
...		| NC source4 sreg4 |
			"bisl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,4) + %[1]
#ifdef REGVARS
ior stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"bisl3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
ior stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bisl3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
ior stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"bisl3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
ior sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"bisl3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
#endif /* REGVARS */
ior sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"bisl3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)}) |	| |
ior sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"bisl3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,LB,tostring($2)}) |	| |
ior ste $1==4	| source4 source4 |
			remove(externals)
			"bisl3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
ior $1==8	| sreg8 sreg8 |
			"bisl2\t%[1.1],%[2.1]"
			"bisl2\t%[1.2],%[2.2]"
			erase(%[2])		| %[2]	| |
ior defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.ior"
			erase(R0)		|	| |
ior !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.ior"
			erase(R0)		|	| |
xor $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"xorl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
...		| NC sreg4 source4 |
			"xorl2\t%[2],%[1]"
			erase(%[1])
			setcc(%[1])		| %[1]	| | (3,4) + %[2]
...		| NC source4 sreg4 |
			"xorl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,4) + %[1]
#ifdef REGVARS
xor stl $1==4 && inreg($2)==2
	| source4 source4 |
			remove(regvar($2))
			"xorl3\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
xor stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"xorl3\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
xor stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"xorl3\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
xor sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"xorl3\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
#endif /* REGVARS */
xor sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"xorl3\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)}) |	| |
xor sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"xorl3\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)}) |	| |
xor ste $1==4	| source4 source4 |
			remove(externals)
			"xorl3\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
xor defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.xor"
			erase(R0)		|	| |
xor !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.xor"
			erase(R0)		|	| |
com $1==4	| source4 |
			allocate(%[1],REG)
			"mcoml\t%[1],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef REGVARS
com stl $1==4 && inreg($2)==2
		| source4 |
			remove(regvar($2))
			"mcoml\t%[1],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
com stl $1==4 && $2<0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mcoml\t%[1],$2(fp)"
			setcc({LOCAL4,LB,$2,4}) |	| |
com stl $1==4 && $2>=0
		| source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"mcoml\t%[1],$2(ap)"
			setcc({LOCAL4,AP,$2,4}) |	| |
#ifdef REGVARS
com sil $1==4 && inreg($2)==2
		| source4 |
			REMEXTANDLOC
			"mcoml\t%[1],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
#endif /* REGVARS */
com sil $1==4 && $2<0
		| source4 |
			REMEXTANDLOC
			"mcoml\t%[1],*$2(fp)"
			setcc({displdef4,LB,tostring($2)}) |	| |
com sil $1==4 && $2>=0
		| source4 |
			REMEXTANDLOC
			"mcoml\t%[1],*$2(ap)"
			setcc({displdef4,AP,tostring($2)}) |	| |
com ste $1==4	| source4 |
			remove(externals)
			"mcoml\t%[1],$2"
			setcc({EXTERNAL4,$2})	|	| |
com defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.com"
			erase(R0)		|	| |
com !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.com"
			erase(R0)		|	| |
rol $1==4	| source4 source4 |
			allocate(%[1],REG=%[1])
			"rotl\t%[a],%[2],%[a]"
			erase(%[a])
			setcc(%[a])		| %[a]	| |
#ifdef REGVARS
rol stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			"rotl\t%[1],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
rol stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"rotl\t%[1],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
rol stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"rotl\t%[1],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
rol sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			"rotl\t%[1],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
#endif /* REGVARS */
rol sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			"rotl\t%[1],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
rol sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			"rotl\t%[1],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
rol ste $1==4	| source4 source4 |
			remove(externals)
			"rotl\t%[1],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
rol !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.rol"
			erase(R0)		|	| |
ror $1==4	| source4 source4 |
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],%[a]"
			setcc(%[a])		| %[a]	| |
...		| NC CONST source4 |
			allocate(%[2],REG)
			"rotl\t$$%(32-%[1.num]%),%[2],%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef REGVARS
ror stl $1==4 && inreg($2)==2
		| source4 source4 |
			remove(regvar($2))
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
...		| NC CONST source4 |
			remove(regvar($2))
			"rotl\t$$%(32-%[1.num]%),%[2],%(regvar($2)%)"
			erase(regvar($2))
			setcc(regvar($2))	|	| |
#endif /* REGVARS */
ror stl $1==4 && $2<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"rotl\t$$%(32-%[1.num]%),%[2],$2(fp)"
			setcc({LOCAL4,LB,$2,4})	|	| |
ror stl $1==4 && $2>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
...		| NC CONST source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $2+3 && %[num]+%[size] > $2))
			"rotl\t$$%(32-%[1.num]%),%[2],$2(ap)"
			setcc({LOCAL4,AP,$2,4})	|	| |
#ifdef REGVARS
ror sil $1==4 && inreg($2)==2
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
...		| NC CONST source4 |
			REMEXTANDLOC
			"rotl\t$$%(32-%[1.num]%),%[2],(%(regvar($2)%))"
			setcc({regdef4,regvar($2)})	|	| |
#endif /* REGVARS */
ror sil $1==4 && $2<0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
...		| NC CONST source4 |
			REMEXTANDLOC
			"rotl\t$$%(32-%[1.num]%),%[2],*$2(fp)"
			setcc({displdef4,LB,tostring($2)})	|	| |
ror sil $1==4 && $2>=0
		| source4 source4 |
			REMEXTANDLOC
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
...		| NC CONST source4 |
			REMEXTANDLOC
			"rotl\t$$%(32-%[1.num]%),%[2],*$2(ap)"
			setcc({displdef4,AP,tostring($2)})	|	| |
ror ste $1==4	| source4 source4 |
			remove(externals)
			allocate(%[1],REG)
			"subl3\t%[1],$$32,%[a]"
			"rotl\t%[a],%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
...		| NC CONST source4 |
			remove(externals)
			"rotl\t$$%(32-%[1.num]%),%[2],$2"
			setcc({EXTERNAL4,$2})	|	| |
ror !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.ror"
			erase(R0)		|	| |
com and $1==4 && $2==4
		| source4 source4 |
			allocate(%[1],%[2],REG)
			"bicl3\t%[1],%[2],%[a]"
			setcc(%[a])		| %[a]	| | (4,4)+%[1]+%[2]
...		| NC source4 sreg4 |
			"bicl2\t%[1],%[2]"
			erase(%[2])
			setcc(%[2])		| %[2]	| | (3,4) + %[1]
#ifdef REGVARS
com and stl $1==4 && $2==4 && inreg($3)==2
		| source4 source4 |
			remove(regvar($3))
			"bicl3\t%[1],%[2],%(regvar($3)%)"
			erase(regvar($3))
			setcc(regvar($3))	|	| |
#endif /* REGVARS */
com and stl $1==4 && $2==4 && $3<0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $3+3 && %[num]+%[size] > $3))
			"bicl3\t%[1],%[2],$3(fp)"
			setcc({LOCAL4,AP,$3,4})	|	| |
com and stl $1==4 && $2==4 && $3>=0
		| source4 source4 |
			remove(displaced)
			remove(LOCALS,(%[num] <= $3+3 && %[num]+%[size] > $3))
			"bicl3\t%[1],%[2],$3(ap)"
			setcc({LOCAL4,AP,$3,4})	|	| |
#ifdef REGVARS
com and sil $1==4 && $2==4 && inreg($3)==2
		| source4 source4 |
			REMEXTANDLOC
			"bicl3\t%[1],%[2],(%(regvar($3)%))"
			setcc({regdef4,regvar($3)})	|	| |
#endif /* REGVARS */
com and sil $1==4 && $2==4 && $3<0
		| source4 source4 |
			REMEXTANDLOC
			"bicl3\t%[1],%[2],*$3(fp)"
			setcc({displdef4,LB,tostring($3)})	|	| |
com and sil $1==4 && $2==4 && $3>=0
		| source4 source4 |
			REMEXTANDLOC
			"bicl3\t%[1],%[2],*$3(ap)"
			setcc({displdef4,AP,tostring($3)})	|	| |
com and ste $1==4 &&$2==4
		| source4 source4 |
			remove(externals)
			"bicl3\t%[1],%[2],$3"
			setcc({EXTERNAL4,$3})	|	| |
com and $1==$2	| STACK |
			move({CONST4,$1},R0)
			"jsb\t.cmand"
			erase(R0)		|	| |

/********************************
 * Group 10: Set instructions	*
 ********************************/

loc inn $1==0 && $2==4	| source4 |
			allocate(%[1],REG)
			"bicl3\t$$~1,%[1],%[a]"
			setcc(%[a])		| %[a]	| |
loc inn $2==4	| source4 |
			allocate(%[1],REG)
			"ashl\t$$%(0-$1%),%[1],%[a]"
			"bicl2\t$$~1,%[a]"
			setcc(%[a])		| %[a]	| |
#ifdef LOCLABS
inn $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],$$31"
			"bgtru\t1f"
			"mnegl\t%[1],%[a]"
			"ashl\t%[a],%[2],%[a]"
			"bicl2\t$$~1,%[a]\n1:"
			setcc(%[a])
			erase(%[a])		| %[a]	| |
#endif
loc inn zeq $2==4	| source4 |
			remove(ALL)
			"bitl\t%[1],$$%(1<<$1%)"
			"jeql\t$3"		|	| |
loc inn zne $2==4	| source4 |
			remove(ALL)
			"bitl\t%[1],$$%(1<<$1%)"
			"jneq\t$3"		|	| |
inn zeq $1==4	| source4-(reginc4+regdec4+ind4) source4 |
			remove(ALL)
			allocate(REG)
			"cmpl\t%[1],$$31"
			"jgtru\t$2"
			"ashl\t%[1],$$1,%[a]"
			"bitl\t%[2],%[a]"
			"jeql\t$2"		|	| |
...		| NC source1 source4 |
			remove(ALL)
			allocate(REG)
			"cmpb\t%[1],$$31"
			"jgtru\t$2"
			"ashl\t%[1],$$1,%[a]"
			"bitl\t%[2],%[a]"
			"jeql\t$2"		|	| |
#ifdef LOCLABS
inn zne $1==4	| source4-(reginc4+regdec4+ind4) source4 |
			remove(ALL)
			allocate(REG)
			"cmpl\t%[1],$$31"
			"bgtru\t1f"
			"ashl\t%[1],$$1,%[a]"
			"bitl\t%[2],%[a]"
			"jneq\t$2\n1:"		|	| |
...		| NC source1 source4 |
			remove(ALL)
			allocate(REG)
			"cmpb\t%[1],$$31"
			"bgtru\t1f"
			"ashl\t%[1],$$1,%[a]"
			"bitl\t%[2],%[a]"
			"jneq\t$2\n1:"		|	| |
#endif
loc inn zeq $2==8 && $1<32	/* First half of set. */
		| REG REG |
			remove(ALL)
			"bitl\t%[1],$$%(1<<$1%)"
			"jeql\t$3"		|	| |
loc inn zeq $2==8 && $1>=32	/* Second half. */
		| REG REG |
			remove(ALL)
			"bitl\t%[2],$$%(1<<($1-32)%)"
			"jeql\t$3"		|	| |
loc inn zne $2==8 && $1<32	/* First half of set. */
		| REG REG |
			remove(ALL)
			"bitl\t%[1],$$%(1<<$1%)"
			"jneq\t$3"		|	| |
loc inn zne $2==8 && $1>=32	/* Second half. */
		| REG REG |
			remove(ALL)
			"bitl\t%[2],$$%(1<<($1-32)%)"
			"jneq\t$3"		|	| |
inn defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.inn"
			erase(R0)		| R1	| |
inn !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.inn"
			erase(R0)		| R1	| |
set $1==4	| source4 | |	{CONST4,1} %[1] | sli 4 |
set defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.setx"
			erase(R0)		|	| |
set !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.setx"
			erase(R0)		|	| |

/****************************************
 * Group 11 : Array instructions	*
 ****************************************/

lae aar $2==4 && rom(1,3)==1	| | | | ads 4 adp 0-rom(1,1) |
lae aar $2==4 && rom(1,3)==2	| | | | loc 1 sli 4 ads 4 adp 0-2*rom(1,1) |
lae aar $2==4 && rom(1,3)==4	| | | | loc 2 sli 4 ads 4 adp 0-4*rom(1,1) |
lae aar $2==4 && rom(1,3)==8	| | | | loc 3 sli 4 ads 4 adp 0-8*rom(1,1) |
lae aar $2==4 && defined(rom(1,3)) && rom(1,1)==0
		| source4 adispl |
			allocate(%[1],REG)
			"mull3\t$$%(rom(1,3)%),%[1],%[a]"
			| {adisplind1,%[a],%[2.reg],%[2.ind]}	| | (8,10)+%[1]
...		| NC source4 ADDR_EXTERNAL |
			allocate(%[1],REG)
			"mull3\t$$%(rom(1,3)%),%[1],%[a]"
			| {adispl,%[a],%[2.ind]}	| | (7,16)+%[1]
lae aar $2==4 && defined(rom(1,3))
		| source4 adispl |
			allocate(%[1],REG)
			"mull3\t$$%(rom(1,3)%),%[1],%[a]"
			| {adisplind1,%[a],%[2.reg],
				%[2.ind]+"+"+tostring(0-rom(1,1)*rom(1,3))}
				| | (8,10)+%[1]
...		| NC source4 ADDR_EXTERNAL |
			allocate(%[1],REG)
			"mull3\t$$%(rom(1,3)%),%[1],%[a]"
			| {adispl,%[a],
				%[2.ind]+"+"+tostring(0-rom(1,1)*rom(1,3))}
				| | (7,16)+%[1]
/* Sequence used by the CEM-compiler and the codegenerator. */
loc sli ads $1==2 && $2==4 && $3==4
		| reg4 ADDR_EXTERNAL |
				| {aextind4,%[1],%[2.ind]} | |
...		| reg4 adispl |
				| {adisplind4,%[1],%[2.reg],%[2.ind]} | |
...		| reg4 displ4 |
				| {adispldefind4,%[1],%[2.reg],%[2.ind]} | |
...		| reg4 EXTERNAL4 |
				| {aextdefind4,%[1],%[2.ind]} | |
loc sli ads $1==3 && $2==4 && $3==4
		| reg4 ADDR_EXTERNAL |
				| {aextind8,%[1],%[2.ind]} | |
...		| reg4 adispl |
				| {adisplind8,%[1],%[2.reg],%[2.ind]} | |
...		| reg4 displ4 |
				| {adispldefind8,%[1],%[2.reg],%[2.ind]} | |
...		| reg4 EXTERNAL4 |
				| {aextdefind8,%[1],%[2.ind]} | |
aar $1==4	| STACK |
			"jsb\t.aar4"		 | R0	| |
aar !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.aar"
			erase(R0)		| R0	| |
lae sar defined(rom(1,3))	| | |	| lae $1 aar $2 sti rom(1,3)	|
lae lar defined(rom(1,3))	| | |	| lae $1 aar $2 loi rom(1,3)	|
sar $1==4	| STACK |
			"jsb\t.sar4"		 |	 | |
sar !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.sar"
			erase(R0)		|	| |
lar $1==4	| STACK |
			"jsb\t.lar4"		 |	 | |
lar !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.lar"
			erase(R0)		|	| |

/****************************************
 * Group 12 : Compare instructions	*
 ****************************************/

cmi $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"beql\t2f"
			"bgtr\t1f"
#else
			"beql\t.+10"
			"bgtr\t.+6"
#endif
			"incl\t%[a]"
#ifdef LOCLABS
			"brb\t2f\n1:"
			"decl\t%[a]\n2:"
#else
			"brb\t.+4"
			"decl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmi !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.cmi"
			setcc(R0)
			erase(R0)		| R0	| |
cmf $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"beql\t2f"
			"bgtr\t1f"
#else
			"beql\t.+10"
			"bgtr\t.+6"
#endif
			"incl\t%[a]"
#ifdef LOCLABS
			"brb\t2f\n1:"
			"decl\t%[a]\n2:"
#else
			"brb\t.+4"
			"decl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf $1==8	| source8 source8 |
/* trouble, possible lack of scratch registers */
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"blss\t2f"
			"bgtr\t1f"
#else
			"blss\t.+8"
			"bgtr\t.+11"
#endif
			"clrl\t%[a]"
#ifdef LOCLABS
			"brb\t3f\n2:"
#else
			"brb\t.+10"
#endif
			"movl\t$$1,%[a]"
#ifdef LOCLABS
			"brb\t3f\n1:"
			"mnegl\t$$1,%[a]\n3:"
#else
			"brb\t.+5"
			"mnegl\t$$1,%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.cmf"
			setcc(R0)
			erase(R0)		| R0	| |
cmu $1==4	| |				|	| cmp |
cmu !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.cmu"
			setcc(R0)
			erase(R0)		| R0	| |
cmp		| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"beqlu\t2f"
			"bgtru\t1f"
#else
			"beqlu\t.+10"
			"bgtru\t.+6"
#endif
			"incl\t%[a]"
#ifdef LOCLABS
			"brb\t2f\n1:"
			"decl\t%[a]\n2:"
#else
			"brb\t.+4"
			"decl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cms $1==4	| source4 source4 |
			allocate(%[1],%[2],REG)
			"xorl3\t%[1],%[2],%[a]"
			setcc(%[a])
			erase(%[a])		| %[a]	| |
cms defined($1) | STACK |
			move({CONST1,$1},R0)
			"jsb\t.cms"
			setcc(R0)
			erase(R0)		| R0	| |
cms !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.cms"
			setcc(R0)
			erase(R0)		| R0	| |
tlt		| source4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"bgeq\t1f"
			"incl\t%[a]\n1:"
#else
			"bgeq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2-regch4 | 	| {CONST1,0}	| |
tlt and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"blss\t1f"
			"clrl\t%[2]\n1:"
#else
			"blss\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tlt ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bgeq\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"bgeq\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tle		| source4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"bgtr\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtr\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 |		| %[1]	| teq |
tle and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bleq\t1f"
			"clrl\t%[2]\n1:"
#else
			"bleq\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tle ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bgtr\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"bgtr\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tge		| source4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"blss\t1f"
			"incl\t%[a]\n1:"
#else
			"blss\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2-regch4 |	| {CONST1,1} | |
tge and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bgeq\t1f"
			"clrl\t%[2]\n1:"
#else
			"bgeq\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tge ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"blss\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"blss\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tgt		| source4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"bleq\t1f"
			"incl\t%[a]\n1:"
#else
			"bleq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 |	| %[1]	| tne |
tgt and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bgtr\t1f"
			"clrl\t%[2]\n1:"
#else
			"bgtr\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tgt ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bleq\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"bleq\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
teq		| source1or2or4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"bneq\t1f"
			"incl\t%[a]\n1:"
#else
			"bneq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
teq and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"beql\t1f"
			"clrl\t%[2]\n1:"
#else
			"beql\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
teq ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bneq\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"bneq\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tne		| source1or2or4 |
			allocate(REG={CONST1,0})
			test(%[1])
#ifdef LOCLABS
			"beql\t1f"
			"incl\t%[a]\n1:"
#else
			"beql\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
tne and $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"bneq\t1f"
			"clrl\t%[2]\n1:"
#else
			"bneq\t.+4"
			"clrl\t%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
tne ior $2==4	| source4 sreg4 |
			test(%[1])
#ifdef LOCLABS
			"beql\t1f"
			"bisl2\t$$1,%[2]\n1:"
#else
			"beql\t.+4"
			"bisl2\t$$1,%[2]"
#endif
			setcc(%[2])
			erase(%[2])		| %[2]	| |
cmi tlt $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bleq\t1f"
			"incl\t%[a]\n1:"
#else
			"bleq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 tlt |
cmi tle $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"blss\t1f"
			"incl\t%[a]\n1:"
#else
			"blss\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		|  %[a]  | |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 tle |
cmi teq $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bneq\t1f"
			"incl\t%[a]\n1:"
#else
			"bneq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 teq |
cmi tne $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"beql\t1f"
			"incl\t%[a]\n1:"
#else
			"beql\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 tne |
cmi tge $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bgtr\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtr\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 tge |
cmi tgt $1==4	| source4 source4 |
			allocate(REG={CONST4,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bgeq\t1f"
			"incl\t%[a]\n1:"
#else
			"bgeq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1or2 source1or2 |	| %[2] %[1] | cmu 4 tgt |
cmi tlt and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"blss\t1f"
			"clrl\t%[3]\n1:"
#else
			"blss\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tle and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bleq\t1f"
			"clrl\t%[3]\n1:"
#else
			"bleq\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi teq and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"beql\t1f"
			"clrl\t%[3]\n1:"
#else
			"beql\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tne and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bneq\t1f"
			"clrl\t%[3]\n1:"
#else
			"bneq\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tge and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bgeq\t1f"
			"clrl\t%[3]\n1:"
#else
			"bgeq\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tgt and $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bgtr\t1f"
			"clrl\t%[3]\n1:"
#else
			"bgtr\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tlt ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bgeq\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"bgeq\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tle ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bgtr\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"bgtr\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi teq ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bneq\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"bneq\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tne ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"beql\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"beql\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tge ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"blss\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"blss\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmi tgt ior $1==4 && $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bleq\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"bleq\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
#ifdef FLOAT4
cmf tlt $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"bleq\t1f"
			"incl\t%[a]\n1:"
#else
			"bleq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tle $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"blss\t1f"
			"incl\t%[a]\n1:"
#else
			"blss\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		|  %[a]  | |
cmf teq $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"bneq\t1f"
			"incl\t%[a]\n1:"
#else
			"bneq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tne $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"beql\t1f"
			"incl\t%[a]\n1:"
#else
			"beql\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tge $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"bgtr\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtr\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tgt $1==4	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpf\t%[1],%[2]"
#ifdef LOCLABS
			"bgeq\t1f"
			"incl\t%[a]\n1:"
#else
			"bgeq\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
#endif /* FLOAT4 */
#ifdef FLOAT8
cmf tlt $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"bleq\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"bleq\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tle $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"blss\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"blss\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		|  %[a]  | |
cmf teq $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"bneq\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"bneq\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tne $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"beql\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"beql\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tge $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"bgtr\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"bgtr\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmf tgt $1==8	| source8 source8 |
			allocate(%[1],%[2],REG)
			"cmpd\t%[1],%[2]"
#ifdef LOCLABS
			"bgeq\t1f"
			"movl\t$$1,%[a]"
			"brb\t2f\n1:"
			"clrl\t%[a]\n2:"
#else
			"bgeq\t.+9"
			"movl\t$$1,%[a]"
			"brb\t.+4"
			"clrl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
#endif /* FLOAT8 */
/* Remember that cmu was replaced by cmp. */
cmp tlt 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"blequ\t1f"
			"incl\t%[a]\n1:"
#else
			"blequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"blequ\t1f"
			"incl\t%[a]\n1:"
#else
			"blequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"blequ\t1f"
			"incl\t%[a]\n1:"
#else
			"blequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp tle 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"blssu\t1f"
			"incl\t%[a]\n1:"
#else
			"blssu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"blssu\t1f"
			"incl\t%[a]\n1:"
#else
			"blssu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"blssu\t1f"
			"incl\t%[a]\n1:"
#else
			"blssu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp teq 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bnequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bnequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"bnequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bnequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"bnequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bnequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp tne 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"beqlu\t1f"
			"incl\t%[a]\n1:"
#else
			"beqlu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"beqlu\t1f"
			"incl\t%[a]\n1:"
#else
			"beqlu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"beqlu\t1f"
			"incl\t%[a]\n1:"
#else
			"beqlu\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp tge 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bgtru\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtru\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"bgtru\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtru\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"bgtru\t1f"
			"incl\t%[a]\n1:"
#else
			"bgtru\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp tgt 	| source4 source4 |
			allocate(REG={CONST1,0})
			"cmpl\t%[1],%[2]"
#ifdef LOCLABS
			"bgequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bgequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source1 source1 |
			allocate(REG={CONST1,0})
			"cmpb\t%[1],%[2]"
#ifdef LOCLABS
			"bgequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bgequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
...		| NC source2 source2 |
			allocate(REG={CONST1,0})
			"cmpw\t%[1],%[2]"
#ifdef LOCLABS
			"bgequ\t1f"
			"incl\t%[a]\n1:"
#else
			"bgequ\t.+4"
			"incl\t%[a]"
#endif
			erase(%[a])
			setcc(%[a])		| %[a]	| |
cmp teq and $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"beql\t1f"
			"clrl\t%[3]\n1:"
#else
			"beql\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmp tne and $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bneq\t1f"
			"clrl\t%[3]\n1:"
#else
			"bneq\t.+4"
			"clrl\t%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmp teq ior $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"bneq\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"bneq\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cmp tne ior $3==4
		| source4 source4 sreg4 |
			"cmpl\t%[2],%[1]"
#ifdef LOCLABS
			"beql\t1f"
			"bisl2\t$$1,%[3]\n1:"
#else
			"beql\t.+7"
			"bisl2\t$$1,%[3]"
#endif
			setcc(%[3])
			erase(%[3])		| %[3]	| |
cms teq $1==4	|	|			|	| cmp teq	|
cms tne $1==4	|	|			|	| cmp tne	|

/****************************************
 * Group 13 : Branch instructions	*
 ****************************************/

bra		| STACK |
			"jbr\t$1"		 |	 | |
blt		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jgtr\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jgtru\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jgtru\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jgtr\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jgtr\t$1"		|	| |
ble		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jgeq\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jgequ\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jgequ\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jgeq\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jgeq\t$1"		|	| |
beq		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jeql\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jeqlu\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jeqlu\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jeql\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jeql\t$1"		|	| |
bne		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jneq\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jnequ\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jnequ\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jneq\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jneq\t$1"		|	| |
bge		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jleq\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jlequ\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jlequ\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jleq\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jleq\t$1"		|	| |
bgt		| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jlss\t$1"		|	| |
...		| NC source2 source2 STACK |
			"cmpw\t%[1],%[2]"
			"jlssu\t$1"		|	| |
...		| NC source1 source1 STACK |
			"cmpb\t%[1],%[2]"
			"jlssu\t$1"		|	| |
...		| NC source4 STACK |
			"cmpl\t%[1],(sp)+"
			"jlss\t$1"		|	| |
...		| STACK |
			"cmpl\t(sp)+,(sp)+"
			"jlss\t$1"		|	| |
zlt		| source4 STACK |
			test(%[1])
			"jlss\t$1"
			samecc			|	| |
...		| NC source1or2 |	| %[1]	| asp 4	|
zle		| source4 STACK |
			test(%[1])
			"jleq\t$1"
			samecc			|	| |
...		| NC source1or2 |	| %[1]	| zeq $1 |
zeq		| source1or2or4 STACK |
			test(%[1])
			"jeql\t$1"
			samecc			|	| |
zne		| source1or2or4 STACK |
			test(%[1])
			"jneq\t$1"
			samecc			|	| |
zge		| source4 STACK |
			test(%[1])
			"jgeq\t$1"
			samecc			|	| |
...		| NC source1or2 |	| %[1]	| asp 4 bra $1 |
zgt		| source4 STACK |
			test(%[1])
			"jgtr\t$1"
			samecc			|	| |
...		| NC source1or2 |	| %[1]	| zne $1 |
cmf zlt $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jgtr\t$2"		 |	 | |
cmf zle $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jgeq\t$2"		 |	 | |
cmf zne $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jneq\t$2"		 |	 | |
cmf zeq $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jeql\t$2"		 |	 | |
cmf zge $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jleq\t$2"		 |	 | |
cmf zgt $1==4	| source4 source4 STACK |
			"cmpf\t%[1],%[2]"
			"jlss\t$2"		 |	 | |
cmf zlt $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jgtr\t$2"		 |	 | |
cmf zle $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jgeq\t$2"		 |	 | |
cmf zne $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jneq\t$2"		 |	 | |
cmf zeq $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jeql\t$2"		 |	 | |
cmf zge $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jleq\t$2"		 |	 | |
cmf zgt $1==8	| source8 source8 |
			remove(ALL)
			"cmpd\t%[1],%[2]"
			"jlss\t$2"		 |	 | |
cmp zlt 	| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jgtru\t$2"		 |	 | |
...		| NC source1or2 source1or2 | | %[2] %[1] | blt $2 |
cmp zle 	| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jgequ\t$2"		 |	 | |
...		| NC source1or2 source1or2 | | %[2] %[1] | ble $2 |
cmp zne 	| |					| | bne $2 |
cmp zeq 	| |					| | beq $2 |
cmp zge 	| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jlequ\t$2"		 |	 | |
...		| NC source1or2 source1or2 | | %[2] %[1] | bge $2 |
cmp zgt 	| source4 source4 STACK |
			"cmpl\t%[1],%[2]"
			"jlssu\t$2"		 |	 | |
...		| NC source1or2 source1or2 | | %[2] %[1] | bgt $2 |
cms zeq $1==4	| |				|	| cmp zeq $2 |
cms zne $1==4	| |				|	| cmp zne $2 |

/************************************************
 * Group 14 : Procedure call instructions	*
 ************************************************/

cai asp $2%4 == 0 && $2>=0 && $2 < 1024
		| reg4 |
			remove(ALL)
			"calls\t$$%($2/4%),(%[1])"	|	| |
cai		| reg4 |
			remove(ALL)
			"calls\t$$0,(%[1])"		|	| |
cal asp $2%4 == 0 && $2>=0 && $2 < 1024
		| |	remove(ALL)
			"calls\t$$%($2/4%),$1"		|	| |
cal		| |	remove(ALL)
			"calls\t$$0,$1"			|	| |
lfr $1==4	| |					| R0	| |
lfr $1==8	| |					| QR0	| |
asp ret $2==0	| | "ret"				|	| |
ass ret $2==0	| | "ret"				|	| |
asp lfr ret $2==$3 | | "ret"				|	| |
ass lfr ret $2==$3 | | "ret"				|	| |
lfr ret $1==$2	| | "ret"				|	| |
ret $1==0	| | "ret"				|	| |
ret $1==4	| NC bigsource4 |
			move(%[1],R0)
			"ret"				|	| |
...		| STACK |
			"movl\t(sp)+,r0"
			"ret"				|	| |
ret $1==8	| NC bigsource8 |
			move(%[1],QR0)
			"ret"				|	| |
...		| STACK |
			"movq\t(sp)+,r0"
			"ret"				|	| |

/********************************
 * Group 15 : Miscellaneous	*
 ********************************/

#ifdef REGVARS
asp $1==4	| bigsource4 - regch4 |		|	| |
#else /* REGVARS */
asp $1==4	| NC bigsource4 |		|	| |
#endif /* REGVARS */
...		| STACK |
			"tstl\t(sp)+"		|	| | (2,7)
asp $1>0	| STACK |
			"addl2\t$$$1,sp"	|	| |
asp $1==(0-4)	| |				| {CONST4,0} | |
asp $1==(0-8)	| |				| {CONST8,"0"} | |
asp		| STACK |
			"subl2\t$$%(0-$1%),sp"	|	| |
ass $1==4	| source4 |
			remove(ALL)
			"addl2\t%[1],sp"	|	| |
ass !defined($1) | source4 |
			remove(ALL)
			move(%[1],R2)	/* R2 <= leave return area intact. */
			"jsb\t.ass"
			erase(R2)		|	| |
blm $1==4	| nonexist1 nonexist1 |
			remove(ALL)
			"movl\t%[2],%[1]"	|	| |
blm $1==8	| nonexist1 nonexist1 |
			remove(ALL)
			"movq\t%[2],%[1]"	|	| |
blm $1==12	| sreg4 sreg4 |
			remove(ALL)
			"movl\t(%[2])+,(%[1])+"
			"movq\t(%[2]),(%[1])"
			erase(%[1]) erase(%[2])	|	| |
blm $1==16	| sreg4 sreg4 |
			remove(ALL)
			"movq\t(%[2])+,(%[1])+"
			"movq\t(%[2]),(%[1])"
			erase(%[1]) erase(%[2])	|	| |
blm		| sreg4 sreg4 |
			remove(ALL)
			allocate(REG={CONST1,$1/4})
#ifdef LOCLABS
			"1:\nmovl\t(%[2])+,(%[1])+"
			"sobgtr\t%[a],1b"
#else
			"\nmovl\t(%[2])+,(%[1])+"
			"sobgtr\t%[a],.-3"
#endif
			erase(%[1]) erase(%[2]) erase(%[a])
						|	| |
bls $1==4	| |	remove(ALL)
			move({CONST1,4},R0)
			"jsb\t.bls"
			erase(R0)		|	| |
bls !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.bls"
			erase(R0)		|	| |
csa $1==4	| STACK |
			"jmp\t.csa4"		|	| |
csa !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jmp\t.csa"
			erase(R0)		|	| |
csb $1==4	| STACK |
			"jmp\t.csb4"		|	| |
csb !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jmp\t.csb"
			erase(R0)		|	| |
dch		| reg4	|	| {displ4,%[1],"12"}	| |
dup stl $1==4	| 	|			|	| stl $2 lol $2 |
dup $1==4	| dups4 |		| %[1] %[1]	| |
#ifdef REGVARS
dup $1==8	| bigsource8-regch8 |	| %[1] %[1]	| |
#else /* REGVARS */
dup $1==8	| bigsource8 |		| %[1] %[1]	| |
#endif /* REGVARS */
...		| dups4 dups4 |		| %[2] %[1] %[2] %[1] | |
dup		| STACK |
			allocate(REG,REG={CONST1,$1/4})
			"addl3\tsp,$$$1,%[a]"
#ifdef LOCLABS
			"1:\nmovl\t-(%[a]),-(sp)"
			"sobgtr\t%[b],1b"
#else
			"movl\t-(%[a]),-(sp)"
			"sobgtr\t%[b],.-3"
#endif
			erase(%[b])		|	| |
dus $1==4	| source4 |
			remove(ALL)
			allocate(REG,REG)
			"ashl\t$$-2,%[1],%[b]"
			"addl3\tsp,%[1],%[a]"
#ifdef LOCLABS
			"1:\nmovl\t-(%[a]),-(sp)"
			"sobgtr\t%[b],1b"
#else
			"movl\t-(%[a]),-(sp)"
			"sobgtr\t%[b],.-3"
#endif
						|	| |
dus !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.dus"
			erase(R0)		|	| |
exg $1==4	| bigsource4-regch4 bigsource4-regch4 |	| %[1] %[2] | |
exg $1==8	| bigsource8-regch8 bigsource8-regch8 |	| %[1] %[2] | |
exg defined($1) | STACK |
			move({CONST4,$1},R0)
			"jsb\t.exg"
			erase(R0)		|	| |
exg !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.exg"
			erase(R0)		|	| |
fil		| |	"movl\t$$$1,hol0+4"	|	| |
lim		| |	allocate(REG)
			"movl\t.trpim,%[a]"	| %[a]	| |
lin		| |	"movl\t$$$1,hol0"	|	| |
lni		| |	"incl\thol0"		|	| |
gto		| STACK |
			"pushl\t$$$1"
			"jmp\t.gto"		|	| |
lor $1==0	| |				| LB	| |
lor $1==1	| STACK |
			allocate(REG)
			"movl\tsp,%[a]"		| %[a]  | |
lor $1==2	| |	allocate(REG)
			"movl\t.reghp,%[a]"	| %[a] | |
lpb		| bigsource4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.lpb"
			erase(R0)		| R0	| |
mon		| STACK |
			"jsb\t.mon"		|	| |
nop		| STACK |
#ifdef DEBUG
			"jsb\t.nop"
#endif
						|	| |

#ifdef DORCK
rck $1==4	| STACK |
			"jsb\t.rck4"		|	| |
rck !defined($1) | source4 |
			remove(ALL)
			move(%[1],R0)
			"jsb\t.rck"
			erase(R0)		|	| |
#else /* DORCK */
#ifdef REGVARS
rck defined($1)	| bigsource4-regch4 |		|	| |
rck !defined($1) | bigsource4-regch4 bigsource4-regch4 | | | |
#else /* REGVARS */
rck defined($1)	| bigsource4 |		|	| |
rck !defined($1) | bigsource4 bigsource4 |	|	| |
#endif /* REGVARS */
#endif /* DORCK */
rtt		| | "ret"			|	| |
sig		| STACK |
			"jsb\t.sig"		|	| |
sim		| STACK |
			"jsb\t.sim"		|	| |
str $1==0	| STACK |
			"jsb\t.strlb"	 	|	| |
str $1==1	| source4 |
			remove(ALL)
			"movl\t%[1],sp" 	|	| |
str $1==2	| STACK |
			"jsb\t.strhp"		|	| |
trp		| STACK |
			"jsb\t.trp"		|	| |

/********************************
 * Coercions:			*
 *				*
 * A: From source to register,	*
 *    from nonexist to source.	*
 ********************************/

| ADDR_EXTERNAL	| 				| {DOUBLE,%[1.ind]} | |
| source1 |	allocate(%[1],REG=%[1]) 	| %[a]	| |
| source2 |	allocate(%[1],REG=%[1]) 	| %[a]	| |
| bigsource4 |	allocate(%[1],REG=%[1]) 	| %[a]	| |
| bigsource8 |	allocate(%[1],QREG=%[1])	| %[a]	| |
| reg4 |			| {adispl,%[1],"0"}	| |
| ADDR_LOCAL |	| {adispl,%[1.reg],tostring(%[1.num])}	| |
| bigsource4-adispl-reg4-ADDR_LOCAL |
		allocate(%[1],REG=%[1])	| {adispl,%[a],"0"}	| |

/********************************
 * B: From STACK to register	*
 ********************************/

| STACK |	allocate(REG)
		"movl\t(sp)+,%[a]"
		setcc(%[a])			| %[a]	| | (3,7)
| STACK |	allocate(QREG)
		"movq\t(sp)+,%[a]"
		setcc(%[a])			| %[a]	| | (3,10)
| STACK |	allocate(REG)
		"movl\t(sp)+,%[a]"
		setcc(%[a])			| {adispl,%[a],"0"} | | (3,7)

/****************
 * C: General	*
 ****************/

| regdef8 |	| {displ4,%[1.reg],"4"} {regdef4,%[1.reg]}		| |
| displ8 |	| {displ4,%[1.reg],%[1.ind]+"+4"}
		  {displ4,%[1.reg],%[1.ind]}				| |
| LOCAL8 |	| {LOCAL4,%[1.reg],%[1.num]+4,4} {LOCAL4,%[1.reg],%[1.num],4}| |
| EXTERNAL8 |	| {EXTERNAL4,%[1.ind]+"+4"} {EXTERNAL4,%[1.ind]}	| |
| QREG |	| %[1.2] %[1.1] 			| |
| regdef4 |	| {displ4,%[1.reg],"0"} 		| |
| LOCAL4 |	| {displ4,%[1.reg],tostring(%[1.num])}	| |

MOVES:
(CONST %[num]==0,source1,	"clrb\t%[2]",		(2,4)+%[2])
(CONST %[num]==0,source2,	"clrw\t%[2]",		(2,4)+%[2])
(CONST %[num]==0,source4,	"clrl\t%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST %[num]<0 && ufit(0-%[num],6),source2,
				"mnegw\t$$%(0-%[1.num]%),%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST ufit(%[num],8) && !ufit(%[num],6),source2,
				"movzbw\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST sfit(%[num],8) && !ufit(%[num],6),source2,
				"cvtbw\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST %[num]<0 && ufit(0-%[num],6),source4,
				"mnegl\t$$%(0-%[1.num]%),%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST ufit(%[num],8) && !ufit(%[num],6),source4,
				"movzbl\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST sfit(%[num],8) && !ufit(%[num],6),source4,
				"cvtbl\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST ufit(%[num],16) && !ufit(%[num],6),source4,
				"movzwl\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST sfit(%[num],16) && !ufit(%[num],6),source4,
				"cvtwl\t%[1],%[2]"
				setcc(%[2]),		(2,4)+%[2])
(CONST8 %[ind]=="0",source8,	"clrq\t%[2]"
				setcc(%[2]),		(2,4)+%[2])
#ifdef REGVARS
/* Tokens with side effects should not be remembered. */
(reginc1+regdec1,reg4,		"movzbl\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,4)+%[1])
(reginc2+regdec2,reg4,		"movzwl\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,4)+%[1])
(reginc4+regdec4,reg4,		"movl\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,4)+%[1])
(reginc8+regdec8,reg8,		"movq\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,7)+%[1])
#endif /* REGVARS */
(source8,source8,		"movq\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source4,source4,		"movl\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source2,source2,		"movw\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source1,source1,		"movb\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source1, reg4,			"movzbl\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,4)+%[1])
(source2, reg4,			"movzwl\t%[1],%[2]"
				setcc(%[2]) erase(%[2]),(3,4)+%[1])
(reg4, source1,			"cvtlb\t%[1],%[2]"
				setcc(%[2]) erase(%[1]),(3,4)+%[2])
(reg4, source2,			"cvtlw\t%[1],%[2]"
				setcc(%[2]) erase(%[1]),(3,4)+%[2])
(source1,source2,		"movzbw\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source1,source4,		"movzbl\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source2,source4,		"movzwl\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source2,source1,		"cvtwb\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source4,source1,		"cvtlb\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(source4,source2,		"cvtlw\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(aind1,source4,		"movab\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(aind2,source4,		"movaw\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(aind4,source4,		"moval\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(aind8,source4,		"movaq\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
(nonexist1,source4,		"movab\t%[1],%[2]"
				setcc(%[2]),		(3,4)+%[1]+%[2])
TESTS:
(source1,	"tstb\t%[1]"		 ,(2,4) + %[1])
(source2,	"tstw\t%[1]"		 ,(2,4) + %[1])
(source4,	"tstl\t%[1]"		 ,(2,4) + %[1])

STACKS:

(CONST %[num]==0,,
		"clrl\t-(sp)",		(2,7))
(CONST %[num]<0 && ufit(0-%[num],6),,
		"mnegl\t$$%(0-%[1.num]%),-(sp)",
					(2,7) + %[1])
(CONST ufit(%[num],6),,
		"pushl\t%[1]",		(2,7) + %[1])
(CONST8 %[ind]=="0",,
		"clrq\t-(sp)",		(2,10))
(CONST sfit(%[num],8),,
		"cvtbl\t%[1],-(sp)",	(3,7) + %[1])
(source1,,	"movzbl\t%[1],-(sp)",	(3,7) + %[1])
(CONST sfit(%[num],16),,
		"cvtwl\t%[1],-(sp)",	(3,7) + %[1])
(source2,,	"movzwl\t%[1],-(sp)",	(3,7) + %[1])
(source4,,	"pushl\t%[1]"
		setcc(%[1]),		(2,7) + %[1])
(source8,,	"movq\t%[1],-(sp)"
		setcc(%[1]),		(3,10)+ %[1])
(nonexist1,,	"pushal\t%[1]",		(2,7) + %[1])
(aind1,,	"pushab\t%[1]",		(2,7) + %[1])
(aind2,,	"pushaw\t%[1]",		(2,7) + %[1])
(aind4,,	"pushal\t%[1]",		(2,7) + %[1])
(aind8,,	"pushaq\t%[1]",		(2,7) + %[1])
