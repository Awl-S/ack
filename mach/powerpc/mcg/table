REGISTERS

    /* Registers are allocated top down; the order here is odd in order to make
     * sure that non-volatile registers get allocated from r31 (or f31) down.
     *
     * Attributes ending in an exclamation mark must match exactly when copying
     * a register into another register (e.g. for eviction).
     */

    r12                                           bytes4! int! volatile; 
    r11                                           bytes4! int! volatile; 
    r10                                           bytes4! int! volatile; 
    r9                                            bytes4! int! volatile;
    r8                                            bytes4! int! volatile;
    r7                                            bytes4! int! volatile;
    r6                                            bytes4! int! volatile;
    r5                                            bytes4! int! volatile;
    r4                                            bytes4! int! volatile;
    r3                                            bytes4! int! volatile ret;

    r31                                           bytes4! int!; 
    r30                                           bytes4! int!; 
    r29                                           bytes4! int!; 
    r28                                           bytes4! int!; 
    r27                                           bytes4! int!; 
    r26                                           bytes4! int!; 
    r25                                           bytes4! int!; 
    r24                                           bytes4! int!; 
    r23                                           bytes4! int!; 
    r22                                           bytes4! int!; 
    r21                                           bytes4! int!; 
    r20                                           bytes4! int!; 
    r19                                           bytes4! int!; 
    r18                                           bytes4! int!; 
    r17                                           bytes4! int!; 
    r16                                           bytes4! int!;
    r15                                           bytes4! int!;
    r14                                           bytes4! int!;
    r13                                           bytes4! int!;

    r11r12  named("r11", "r12") aliases(r11, r12) bytes8! long! volatile;
    r9r10   named("r9",  "r10") aliases(r9,  r10) bytes8! long! volatile;
    r7r8    named("r7",  "r8")  aliases(r7,  r8)  bytes8! long! volatile;
    r5r6    named("r5",  "r6")  aliases(r6,  r6)  bytes8! long! volatile;
    r3r4    named("r3",  "r4")  aliases(r3,  r4)  bytes8! long! volatile pret;

    r29r30  named("r29", "r30") aliases(r29, r30) bytes8! long!;
    r27r28  named("r27", "r28") aliases(r27, r28) bytes8! long!;
    r25r26  named("r25", "r26") aliases(r25, r26) bytes8! long!;
    r23r24  named("r23", "r24") aliases(r23, r24) bytes8! long!;
    r21r22  named("r21", "r22") aliases(r21, r22) bytes8! long!;
    r19r20  named("r19", "r20") aliases(r19, r20) bytes8! long!;
    r17r18  named("r17", "r18") aliases(r17, r18) bytes8! long!;
    r15r16  named("r15", "r16") aliases(r15, r16) bytes8! long!;
    r13r14  named("r13", "r14") aliases(r13, r14) bytes8! long!;

    f14                                           bytes4! float! volatile;
    f13                                           bytes4! float! volatile;
    f12                                           bytes4! float! volatile;
    f11                                           bytes4! float! volatile;
    f10                                           bytes4! float! volatile;
    f9                                            bytes4! float! volatile;
    f8                                            bytes4! float! volatile;
    f7                                            bytes4! float! volatile;
    f6                                            bytes4! float! volatile;
    f5                                            bytes4! float! volatile;
    f4                                            bytes4! float! volatile;
    f3                                            bytes4! float! volatile fret;
    f2                                            bytes4! float! volatile;
    f1                                            bytes4! float! volatile;
    f0                                            bytes4! float! volatile;

    f31                                           bytes4! float!;
    f30                                           bytes4! float!;
    f29                                           bytes4! float!;
    f28                                           bytes4! float!;
    f27                                           bytes4! float!;
    f26                                           bytes4! float!;
    f25                                           bytes4! float!;
    f24                                           bytes4! float!;
    f23                                           bytes4! float!;
    f22                                           bytes4! float!;
    f21                                           bytes4! float!;
    f20                                           bytes4! float!;
    f19                                           bytes4! float!;
    f18                                           bytes4! float!;
    f17                                           bytes4! float!;
    f16                                           bytes4! float!;
    f15                                           bytes4! float!;

    d14     named("f14")       aliases(f14)       bytes8! double! volatile;
    d13     named("f13")       aliases(f13)       bytes8! double! volatile;
    d12     named("f12")       aliases(f12)       bytes8! double! volatile;
    d11     named("f11")       aliases(f11)       bytes8! double! volatile;
    d10     named("f10")       aliases(f10)       bytes8! double! volatile;
    d9      named("f9")        aliases(f9)        bytes8! double! volatile;
    d8      named("f8")        aliases(f8)        bytes8! double! volatile;
    d7      named("f7")        aliases(f7)        bytes8! double! volatile;
    d6      named("f6")        aliases(f6)        bytes8! double! volatile;
    d5      named("f5")        aliases(f5)        bytes8! double! volatile;
    d4      named("f4")        aliases(f4)        bytes8! double! volatile;
    d3      named("f3")        aliases(f3)        bytes8! double! volatile dret;
    d2      named("f2")        aliases(f2)        bytes8! double! volatile;
    d1      named("f1")        aliases(f1)        bytes8! double! volatile;
    d0      named("f0")        aliases(f0)        bytes8! double! volatile;

    d31     named("f31")       aliases(f31)       bytes8! double!;
    d30     named("f30")       aliases(f30)       bytes8! double!;
    d29     named("f29")       aliases(f29)       bytes8! double!;
    d28     named("f28")       aliases(f28)       bytes8! double!;
    d27     named("f27")       aliases(f27)       bytes8! double!;
    d26     named("f26")       aliases(f26)       bytes8! double!;
    d25     named("f25")       aliases(f25)       bytes8! double!;
    d24     named("f24")       aliases(f24)       bytes8! double!;
    d23     named("f23")       aliases(f23)       bytes8! double!;
    d22     named("f22")       aliases(f22)       bytes8! double!;
    d21     named("f21")       aliases(f21)       bytes8! double!;
    d20     named("f20")       aliases(f20)       bytes8! double!;
    d19     named("f19")       aliases(f19)       bytes8! double!;
    d18     named("f18")       aliases(f18)       bytes8! double!;
    d17     named("f17")       aliases(f17)       bytes8! double!;
    d16     named("f16")       aliases(f16)       bytes8! double!;
    d15     named("f15")       aliases(f15)       bytes8! double!;

	cr0                                           cr!;



DECLARATIONS

	cr;
    ubyteX;   /* bottom 8 bits valid, the rest undefined */
    ubyte0;   /* bottom 8 bits valid, the rest 0 */
    ushortX;  /* bottom 16 bits valid, the rest undefined */
    ushort0;  /* bottom 16 bits valid, the rest 0 */

	address fragment;



PATTERNS

/* Special */

	PAIR(BLOCK.I, BLOCK.I);



/* Miscellaneous special things */

	PUSH.I(in:(int)reg)
		emit "stwu %in, -4(sp)"
		cost 4;

    PUSH.L(in:(long)reg)
        emit "stwu %in.0, -4(sp)"
        emit "stwu %in.1, -4(sp)"
        cost 8;

    PUSH.D(in:(double)reg)
        emit "stfdu %in, -8(sp)"
        cost 4;

	out:(int)reg = POP.I
		emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
		cost 8;

    out:(long)reg = POP.L
        emit "lwz %out.0, 4(sp)"
        emit "lwz %out.1, 0(sp)"
        emit "addi sp, sp, 8"
        cost 12;

	out:(float)reg = POP.F
		emit "lfs %out, 0(sp)"
		emit "addi sp, sp, 4"
		cost 8;
		
	out:(long)reg = POP.D
		emit "lfd %out, 0(sp)"
		emit "addi sp, sp, 8"
		cost 8;
		
	SETRET.I(in:(ret)reg)
		emit "! setret4"
		cost 1;

    SETRET.L(in:(pret)reg)
        emit "! setret8"
        cost 1;

	STACKADJUST.I(delta:CONST.I)
        when signed_constant(%delta, 16)
		emit "addi sp, sp, $delta"
		cost 4;

	STACKADJUST.I(in:(int)reg)
		emit "add sp, sp, %in"
		cost 4;

	STACKADJUST.I(NEG.I(in:(int)reg))
		emit "subf sp, %in, sp"
		cost 4;

    out:(int)reg = GETFP.I
        emit "mr %out, fp"
        cost 4;

    out:(int)reg = FPTOARGS.I(GETFP.I)
        emit "addi %out, fp, 8"
        cost 4;

    out:(int)reg = FPTOARGS.I(in:(int)reg)
        emit "addi %out, %in, 8"
        cost 4;

    out:(int)reg = GETSP.I
        emit "mr %out, sp"
        cost 4;

    SETSP.I(in:(int)reg)
        emit "mr sp, %in"
        cost 4;
    
    out:(int)reg = COPYF.I(in:(float)reg)
        emit "stfsu %in, -4(sp)"
        emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
        cost 12;

    out:(double)reg = COPYL.D(in:(long)reg)
        emit "stwu %in.0, -4(sp)"
        emit "stwu %in.1, -4(sp)"
        emit "lfd %out, 0(sp)"
        emit "addi sp, sp, 8"
        cost 16;

    out:(long)reg = COPYD.L(in:(double)reg)
        emit "stfdu %in, -8(sp)"
        emit "lwz %out.0, 4(sp)"
        emit "lwz %out.1, 0(sp)"
        emit "addi sp, sp, 8"
        cost 16;



/* Memory operations */

    /* Stores */

	STORE.D(addr:address, value:(double)reg)
        emit "sfd %value, %addr"
		cost 4;

	STORE.L(addr:address, value:(long)reg)
		emit "stw %value.0, 4+%addr"
		emit "stw %value.1, 0+%addr"
		cost 8;

	STORE.I(addr:address, value:(int)reg)
		emit "stw %value, %addr"
		cost 4;

	STOREH.I(addr:address, value:(int)ushortX)
		emit "sth %value, %addr"
		cost 4;

    STOREH.I(ADD.I(left:(int)reg, right:(int)reg), value:(int)ushortX)
        emit "sthx %value, %left, %right"
        cost 4;

	STOREB.I(addr:address, value:(int)ushortX)
		emit "sth %value, %addr"
		cost 4;

    STOREB.I(addr:address, value:(int)ubyteX)
		emit "stb %value, %addr"
		cost 4;

    STOREB.I(ADD.I(left:(int)reg, right:(int)reg), value:(int)ubyteX)
        emit "stbx %value, %left, %right"
        cost 4;

    /* Loads */

	out:(int)reg = LOAD.I(addr:address)
		emit "lwz %out, %addr"
		cost 4;

    out:(long)reg = LOAD.L(addr:address)
        emit "lwz %out.0, 4+%addr"
        emit "lwz %out.1, 0+%addr"
        cost 8;

    out:(double)reg = LOAD.D(addr:address)
        emit "lfsd %out, %addr"
        cost 4;

	out:(int)ushort0 = LOADH.I(addr:address)
		emit "lhz %out, %addr"
		cost 4;

	out:(int)ubyte0 = LOADB.I(addr:address)
		emit "lbz %out, %addr"
		cost 4;

    /* ubyte intrinsics */

    out:(int)ubyteX = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> ubyteX"
        cost 1;

    out:(int)ubyte0 = in:(int)ubyteX
        emit "andi %out, %in, 0xff ! ubyteX -> ubyte0"
        cost 4;

    out:(int)reg = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> reg"
        cost 4;

    out:(int)ubyteX = in:(int)reg
        with %out == %in
        emit "! reg -> ubyteX"
        cost 1;

    /* ushort intrinsics */

    out:(int)ushortX = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> ushortX"
        cost 1;

    out:(int)ushort0 = in:(int)ushortX
        emit "andi %out, %in, 0xff ! ushortX -> ushort0"
        cost 4;

    out:(int)reg = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> reg"
        cost 4;

    out:(int)ushortX = in:(int)reg
        with %out == %in
        emit "! reg -> ushortX"
        cost 1;


/* Extensions and conversions */

    out:(int)reg = EXTENDB.I(in:(int)reg)
        emit "extsb %out, %in"
        cost 4;

    out:(int)reg = EXTENDH.I(in:(int)reg)
        emit "extsh %out, %in"
        cost 4;

    out:(int)reg = FROMSI.I(in:(int)reg)
        with %out == %in
        emit "! FROMSI.I(int) -> int"
        cost 1;

    out:(int)reg = FROMUI.I(in:(int)reg)
        with %out == %in
        emit "! FROMUI.I(int) -> int"
        cost 1;

    out:(long)reg = FROMSI.L(in:(int)reg)
        emit "mr %out.0, %in"
        emit "srawi %out.1, %out.0, 31"
        cost 8;

    out:(int)reg = FROMD.I(in:(double)reg)
        with corrupted(volatile)
        emit "bl .fromd2i"
        cost 4;

    out:(long)reg = FROMF.L(in:(double)reg)
        with corrupted(volatile)
        emit "bl .fromf2l"
        cost 4;

    out:(long)reg = FROMSI.D(in:(double)reg)
        with corrupted(volatile)
        emit "bl .fromsi2d"
        cost 4;

#if 0
	/* byte conversions */

    out:(int)ubyte0 = CIU14(in:(int)ubyte0)
        with %out == %in
        emit "! CIU14(ubyte0) -> ubyte0"
        cost 1;
        
    out:(int)ubyte0 = CIU41(in:(int)ubyte0)
        with %out == %in
        emit "! CIU41(ubyte0) -> ubyte0"
        cost 1;
        
    out:(int)ubyteX = CIU41(in:(int)ubyteX)
        with %out == %in
        emit "! CIU41(ubyteX) -> ubyteX"
        cost 1;
        
    out:(int)reg = CII14(in:(int)ubyteX)
        emit "extsb %out, %in ! CII14(ubyteX) -> reg"
        cost 4;

    /* short conversions */

    out:(int)ushort0 = CIU24(in:(int)ushort0)
        with %out == %in
        emit "! CIU24(ushort0) -> ushort0"
        cost 1;
        
    out:(int)ushort0 = CIU42(in:(int)ushort0)
        with %out == %in
        emit "! CIU42(ushort0) -> ushort0"
        cost 1;
        
    out:(int)ushortX = CIU42(in:(int)ushortX)
        with %out == %in
        emit "! CIU42(ushortX) -> ushortX"
        cost 1;
        
    out:(int)reg = CII24(in:(int)ushort0)
        with %out == %in
        emit "! CII24(ushort0) -> reg"
        cost 4;
        
    out:(int)reg = CII24(in:(int)ushortX)
        emit "extsh %out, %in"
        cost 4;
#endif


/* Locals */

	out:(int)reg = in:LOCAL.I
		emit "addi %out, fp, $in"
		cost 4;

	address = in:LOCAL.I
		emit "$in(fp)";



/* Memory addressing modes */

	address = ADD.I(addr:(int)reg, offset:CONST.I)
        when signed_constant(%offset, 16)
		emit "$offset(%addr)";

	address = addr:(int)reg
		emit "0(%addr)";



/* Branches */

	JUMP(addr:BLOCK.I)
		emit "b $addr"
		cost 4;

	CJUMPEQ(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 12, 2, $true" /* IFTRUE EQ */
		emit "b $false"
		cost 8;

	CJUMPLE(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 4, 1, $true" /* IFFALSE GT */
        emit "b $false"
		cost 8;

	CJUMPLT(value:(cr)cr, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "bc 12, 0, $true" /* IFTRUE LT */
        emit "b $false"
		cost 8;

	CALL(dest:LABEL.I)
        with corrupted(volatile)
		emit "bl $dest"
		cost 4;

	out:(ret)reg = CALL.I(dest:LABEL.I)
        with corrupted(volatile)
		emit "bl $dest"
		cost 4;

	out:(pret)reg = CALL.L(dest:LABEL.I)
        with corrupted(volatile)
		emit "bl $dest"
		cost 4;

    CALL(dest:(int)reg)
        with corrupted(volatile)
        emit "mtspr ctr, %dest"
        emit "bcctrl 20, 0, 0"
        cost 8;

    out:(ret)reg = CALL.I(dest:(int)reg)
        with corrupted(volatile)
        emit "mtspr ctr, %dest"
        emit "bcctrl 20, 0, 0"
        cost 8;

    out:(pret)reg = CALL.L(dest:(int)reg)
        with corrupted(volatile)
        emit "mtspr ctr, %dest"
        emit "bcctrl 20, 0, 0"
        cost 8;

    JUMP(dest:LABEL.I)
        emit "b $dest"
        cost 4;



/* Comparisons */

	cr:(cr)cr = COMPARESI.I(left:(int)reg, right:(int)reg)
        emit "cmp %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPARESI.I(left:(int)reg, right:CONST.I)
        when signed_constant(%right, 16)
        emit "cmpi %cr, 0, %left, $right"
		cost 4;

	cr:(cr)cr = COMPAREUI.I(left:(int)reg, right:(int)reg)
        emit "cmpl %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPAREUI.I(left:(int)reg, right:CONST.I)
        when signed_constant(%right, 16)
        emit "cmpli %cr, 0, %left, $right"
		cost 4;

    out:(cr)cr = COMPARESI.I(in:(cr)cr, result:CONST.I)
        when specific_constant(%result, 0)
        with %out == %in
        emit "! COMPARESI.I(cr, 0)"
        cost 4;



/* Booleans */

    out:(int)reg = IFEQ.I(in:(cr)cr)
        emit "mfcr %out" /* get cr0 */
        emit "rlwinm %out, %out, [32-2], 2, 31" /* extract just EQ */
        cost 8;

    out:(int)reg = IFEQ.I(in:(int)reg)
        emit "cntlzw %out, %in" /* returns 0..32 */
        emit "rlwinm %out, %out, [32-5], 5, 31" /* if 32, return 1, otherwise 0 */
        cost 8;

    out:(int)reg = IFLT.I(in:(cr)cr)
        emit "mfcr %out" /* get cr0 */
        emit "andi. %out, %out, 1" /* leave just LT */
        cost 8;

    out:(int)reg = IFLE.I(in:(cr)cr)
        emit "mfcr %out"                        /* get cr0 */
        emit "andi. %out, %out, 5"              /* leave just LT and EQ */
        emit "cntlzw %out, %out"                /* returns 0..32 */
        emit "rlwinm %out, %out, [32-5], 5, 31" /* if 32, return 1, otherwise 0 */
        emit "xori %out, %out, 1"               /* negate */
        cost 8;



/* Conversions */

#if 0
    out:(int)reg = CIU44(in:(int)reg)
        with %out == %in
        emit "! ciu44"
        cost 4;

    out:(int)reg = CUI44(in:(int)reg)
        with %out == %in
        emit "! cui44"
        cost 4;
#endif

/* ALU operations */

    #define ALUR(name, instr) \
        out:(int)reg = name(left:(int)reg, right:(int)reg) \
            emit instr " %out, %left, %right"              \
            cost 4;                                        \

    #define ALUC(name, instr) \
        out:(int)reg = name(left:(int)reg, right:CONST.I)  \
            when signed_constant(%right, 16)               \
            emit instr " %out, %left, $right"              \
            cost 4;                                        \

    #define ALUC_reversed(name, instr) \
        out:(int)reg = name(left:CONST.I, right:(int)reg)  \
            when signed_constant(%left, 16)                \
            emit instr " %out, %right, $left"              \
            cost 4;                                        \

    #define ALUCC(name, instr) \
        ALUC(name, instr) \
        ALUC_reversed(name, instr)

    ALUR(ADD.I, "add")
    ALUCC(ADD.I, "addi")

	out:(int)reg = SUB.I(left:(int)reg, right:(int)reg)
		emit "subf %out, %left, %right"
		cost 4;

	out:(int)reg = SUB.I(left:(int)reg, right:CONST.I)
		emit "addi %out, %left, -[$right]"
		cost 4;

	out:(int)reg = MOD.I(left:(int)reg, right:(int)reg)
		emit "divw %out, %left, %right"
        emit "mullw %out, %out, %right"
        emit "subf %out, %out, %left"
		cost 12;

	out:(int)reg = MODU.I(left:(int)reg, right:(int)reg)
		emit "divwu %out, %left, %right"
        emit "mullw %out, %out, %right"
        emit "subf %out, %out, %left"
		cost 12;

    ALUR(MUL.I, "mullw")
    ALUCC(MUL.I, "mulli")

    ALUR(DIV.I, "divw")
    ALUR(DIVU.I, "divwu")

    ALUR(ASL.I, "slw")

    ALUR(LSL.I, "slw")

    out:(int)reg = NEG.I(left:(int)reg)
        emit "neg %out, %left"
        cost 4;

    out:(int)reg = NOT.I(left:(int)reg)
        emit "cntlzw %out, %left"
        emit "rlwinm %out, %out, 32-5, 5, 31"
        cost 8;

    ALUR(AND.I, "and")
    ALUCC(AND.I, "andi.")

    ALUR(OR.I, "or")
    ALUCC(OR.I, "ori")

    ALUR(EOR.I, "xor")
    ALUCC(EOR.I, "xori")

	out:(int)reg = value:LABEL.I
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:BLOCK.I
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:CONST.I
		emit "li %out, $value"
		cost 8;


/* FPU operations */

    #define FPU4R(name, instr) \
        out:(float)reg = name(left:(float)reg, right:(float)reg) \
            emit instr " %out, %left, %right"                    \
            cost 4;                                              \

    #define FPU8R(name, instr) \
        out:(double)reg = name(left:(double)reg, right:(double)reg) \
            emit instr " %out, %left, %right"                       \
            cost 4;                                                 \

    out:(float)reg = LOAD.F(addr:address)
        emit "lfs %out, %addr"
        cost 4;
        
    out:(double)reg = LOAD.D(addr:address)
        emit "lfd %out, %addr"
        cost 4;
        
	out:(float)reg = value:CONST.F
		emit "lfs %out, address-containing-$value"
		cost 8;

    FPU4R(ADDF.F, "fadds")
    FPU8R(ADDF.D, "fadd")

    FPU4R(SUBF.F, "fsubs")
    FPU8R(SUBF.D, "fsub")

    FPU4R(MULF.F, "fmuls")
    FPU8R(MULF.D, "fmul")

    FPU4R(DIVF.F, "fdivs")
    FPU8R(DIVF.D, "fdiv")

    out:(float)reg = NEGF.F(left:(float)reg)
        emit "fneg %out, %left"
        cost 4;

    out:(double)reg = NEGF.D(left:(double)reg)
        emit "fneg %out, %left"
        cost 4;

	cr:(cr)cr = COMPAREF.I(left:(float)reg, right:(float)reg)
        emit "fcmpu %cr, %left, %right"
		cost 4;

	cr:(cr)cr = COMPARED.I(left:(double)reg, right:(double)reg)
        emit "fcmpu %cr, %left, %right"
		cost 4;

    #if 0
    out:(ret)reg = CFI44(val:(fret)reg)
        with corrupted(volatile)
        emit "bl .cfi44"
        cost 4;

    out:(fret)reg = CIF44(val:(ret)reg)
        with corrupted(volatile)
        emit "bl .cif44"
        cost 4;

    out:(ret)reg = CFI84(val:(dret)reg)
        with corrupted(volatile)
        emit "bl .cfi84"
        cost 4;

    out:(dret)reg = CIF48(val:(ret)reg)
        with corrupted(volatile)
        emit "bl .cif48"
        cost 4;

    out:(float)reg = CFF84(val:(double)reg)
        emit "frsp %out, %val"
        cost 4;

    out:(double)reg = CFF48(val:(float)reg)
        emit "fmr %out, %val"
        cost 1;
    #endif

/* vim: set sw=4 ts=4 expandtab : */

