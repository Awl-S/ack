REGISTERS

    /* Registers are allocated top down; the order here is odd in order to make
     * sure that non-volatile registers get allocated from r31 (or f31) down.
     *
     * Attributes ending in an exclamation mark must match exactly when copying
     * a register into another register (e.g. for eviction).
     */

    r12 "r12" bytes4! int! volatile; 
    r11 "r11" bytes4! int! volatile; 
    r10 "r10" bytes4! int! volatile; 
    r9  "r9"  bytes4! int! volatile;
    r8  "r8"  bytes4! int! volatile;
    r7  "r7"  bytes4! int! volatile;
    r6  "r6"  bytes4! int! volatile;
    r5  "r5"  bytes4! int! volatile;
    r4  "r4"  bytes4! int! volatile;
    r3  "r3"  bytes4! int! ret volatile;

    r31 "r31" bytes4! int!; 
    r30 "r30" bytes4! int!; 
    r29 "r29" bytes4! int!; 
    r28 "r28" bytes4! int!; 
    r27 "r27" bytes4! int!; 
    r26 "r26" bytes4! int!; 
    r25 "r25" bytes4! int!; 
    r24 "r24" bytes4! int!; 
    r23 "r23" bytes4! int!; 
    r22 "r22" bytes4! int!; 
    r21 "r21" bytes4! int!; 
    r20 "r20" bytes4! int!; 
    r19 "r19" bytes4! int!; 
    r18 "r18" bytes4! int!; 
    r17 "r17" bytes4! int!; 
    r16 "r16" bytes4! int!;
    r15 "r15" bytes4! int!;
    r14 "r14" bytes4! int!;

    f14 "f14" bytes4! float! volatile;
    f13 "f13" bytes4! float! volatile;
    f12 "f12" bytes4! float! volatile;
    f11 "f11" bytes4! float! volatile;
    f10 "f10" bytes4! float! volatile;
    f9  "f9"  bytes4! float! volatile;
    f8  "f8"  bytes4! float! volatile;
    f7  "f7"  bytes4! float! volatile;
    f6  "f6"  bytes4! float! volatile;
    f5  "f5"  bytes4! float! volatile;
    f4  "f4"  bytes4! float! volatile;
    f3  "f3"  bytes4! float! volatile;
    f2  "f2"  bytes4! float! volatile;
    f1  "f1"  bytes4! float! volatile;
    f0  "f0"  bytes4! float! volatile;

    f31 "f31" bytes4! float!;
    f30 "f30" bytes4! float!;
    f29 "f29" bytes4! float!;
    f28 "f28" bytes4! float!;
    f27 "f27" bytes4! float!;
    f26 "f26" bytes4! float!;
    f25 "f25" bytes4! float!;
    f24 "f24" bytes4! float!;
    f23 "f23" bytes4! float!;
    f22 "f22" bytes4! float!;
    f21 "f21" bytes4! float!;
    f20 "f20" bytes4! float!;
    f19 "f19" bytes4! float!;
    f18 "f18" bytes4! float!;
    f17 "f17" bytes4! float!;
    f16 "f16" bytes4! float!;
    f15 "f15" bytes4! float!;
            
	cr0 "cr0" cr!;



DECLARATIONS

	cr;
    ubyteX;   /* bottom 8 bits valid, the rest undefined */
    ubyte0;  /* bottom 8 bits valid, the rest 0 */
    ushortX;  /* bottom 16 bits valid, the rest undefined */
    ushort0; /* bottom 16 bits valid, the rest 0 */

	address fragment;



PATTERNS

/* Special */

	PAIR(BLOCK4, BLOCK4);



/* Miscellaneous special things */

	PUSH4(in:(int)reg)
		emit "stwu %in, -4(sp)"
		cost 4;

	out:(int)reg = POP4
		emit "lwz %out, 0(sp)"
        emit "addi sp, sp, 4"
		cost 8;

	out:(float)reg = POPF4
		emit "lfs %out, 0(sp)"
		emit "addi sp, sp, 4"
		cost 8;
		
	SETRET4(in:(ret)reg)
		emit "! setret4"
		cost 4;

    (ret)reg = GETRET4
        emit "! getret4"
        cost 1;

	STACKADJUST4(delta:CONST4)
        when signed_constant(%delta, 16)
		emit "addi sp, sp, $delta"
		cost 4;

    out:(int)reg = GETFP4
        emit "mr %out, fp"
        cost 4;

    out:(int)reg = FPTOARGS4(GETFP4)
        emit "addi %out, fp, 8"
        cost 4;

    out:(int)reg = FPTOARGS4(in:(int)reg)
        emit "addi %out, %in, 8"
        cost 4;



/* Memory operations */

    /* Stores */

	STORE4(addr:address, value:(int)reg)
		emit "stw %value, %addr"
		cost 4;

	STORE2(addr:address, value:(int)ushortX)
		emit "sth %value, %addr"
		cost 4;

    STORE2(ADD4(left:(int)reg, right:(int)reg), value:(int)ushortX)
        emit "sthx %value, %left, %right"
        cost 4;

    STORE1(addr:address, value:(int)ubyteX)
		emit "stb %value, %addr"
		cost 4;

    STORE1(ADD4(left:(int)reg, right:(int)reg), value:(int)ubyteX)
        emit "stbx %value, %left, %right"
        cost 4;

    /* Loads */

	out:(int)reg = LOAD4(addr:address)
		emit "lwz %out, %addr"
		cost 4;

	out:(int)ushort0 = LOAD2(addr:address)
		emit "lhz %out, %addr"
		cost 4;

	out:(int)ubyte0 = LOAD1(addr:address)
		emit "lbz %out, %addr"
		cost 4;

    /* ubyte intrinsics */

    out:(int)ubyteX = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> ubyteX"
        cost 1;

    out:(int)ubyte0 = in:(int)ubyteX
        emit "andi %out, %in, 0xff ! ubyteX -> ubyte0"
        cost 4;

    out:(int)reg = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> reg"
        cost 4;

    out:(int)ubyteX = in:(int)reg
        with %out == %in
        emit "! reg -> ubyteX"
        cost 1;

    /* ushort intrinsics */

    out:(int)ushortX = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> ushortX"
        cost 1;

    out:(int)ushort0 = in:(int)ushortX
        emit "andi %out, %in, 0xff ! ushortX -> ushort0"
        cost 4;

    out:(int)reg = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> reg"
        cost 4;

    out:(int)ushortX = in:(int)reg
        with %out == %in
        emit "! reg -> ushortX"
        cost 1;

	/* byte conversions */

    out:(int)ubyte0 = CIU14(in:(int)ubyte0)
        with %out == %in
        emit "! CIU14(ubyte0) -> ubyte0"
        cost 1;
        
    out:(int)ubyte0 = CIU41(in:(int)ubyte0)
        with %out == %in
        emit "! CIU41(ubyte0) -> ubyte0"
        cost 1;
        
    out:(int)ubyteX = CIU41(in:(int)ubyteX)
        with %out == %in
        emit "! CIU41(ubyteX) -> ubyteX"
        cost 1;
        
    out:(int)reg = CII14(in:(int)ubyteX)
        emit "extsb %out, %in ! CII14(ubyteX) -> reg"
        cost 4;

    /* short conversions */

    out:(int)ushort0 = CIU24(in:(int)ushort0)
        with %out == %in
        emit "! CIU24(ushort0) -> ushort0"
        cost 1;
        
    out:(int)ushort0 = CIU42(in:(int)ushort0)
        with %out == %in
        emit "! CIU42(ushort0) -> ushort0"
        cost 1;
        
    out:(int)ushortX = CIU42(in:(int)ushortX)
        with %out == %in
        emit "! CIU42(ushortX) -> ushortX"
        cost 1;
        
    out:(int)reg = CII24(in:(int)ushort0)
        with %out == %in
        emit "! CII24(ushort0) -> reg"
        cost 4;
        
    out:(int)reg = CII24(in:(int)ushortX)
        emit "extsh %out, %in"
        cost 4;


/* Locals */

	out:(int)reg = in:LOCAL4
		emit "addi %out, fp, $in"
		cost 4;

	address = in:LOCAL4
		emit "$in(fp)";



/* Memory addressing modes */

	address = ADD4(addr:(int)reg, offset:CONST4)
        when signed_constant(%offset, 16)
		emit "$offset(%addr)";

	address = addr:(int)reg
		emit "0(%addr)";



/* Branches */

	JUMP(addr:BLOCK4)
		emit "b $addr"
		cost 4;

	CJUMPEQ(value:(cr)cr, PAIR(true:BLOCK4, false:BLOCK4))
        emit "bc 12, 2, $true" /* IFTRUE EQ */
		emit "b $false"
		cost 8;

	CJUMPLE(value:(cr)cr, PAIR(true:BLOCK4, false:BLOCK4))
        emit "bc 4, 1, $true" /* IFFALSE GT */
        emit "b $false"
		cost 8;

	CJUMPLT(value:(cr)cr, PAIR(true:BLOCK4, false:BLOCK4))
        emit "bc 12, 0, $true" /* IFTRUE LT */
        emit "b $false"
		cost 8;

	CALL(dest:LABEL4)
        with corrupted(volatile)
		emit "bl $dest"
		cost 4;

    CALL(dest:(int)reg)
        with corrupted(volatile)
        emit "mtspr ctr, %dest"
        emit "bcctrl 20, 0, 0"
        cost 8;

    JUMP(dest:LABEL4)
        emit "b $dest"
        cost 4;



/* Comparisons */

	cr:(cr)cr = COMPARES4(left:(int)reg, right:(int)reg)
        emit "cmp %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPARES4(left:(int)reg, right:CONST4)
        when signed_constant(%right, 16)
        emit "cmpi %cr, 0, %left, $right"
		cost 4;

	cr:(cr)cr = COMPAREU4(left:(int)reg, right:(int)reg)
        emit "cmpl %cr, 0, %left, %right"
		cost 4;

	cr:(cr)cr = COMPAREU4(left:(int)reg, right:CONST4)
        when signed_constant(%right, 16)
        emit "cmpli %cr, 0, %left, $right"
		cost 4;

    cr:(cr)cr = COMPARES4(COMPARES4(left:(int)reg, right:(int)reg), result:CONST4)
        when specific_constant(%result, 0)
        emit "cmp %cr, 0, %left, %right"
        cost 4;

    cr:(cr)cr = COMPARES4(COMPARES4(left:(int)reg, right:CONST4), result:CONST4)
        when specific_constant(%result, 0)
        when signed_constant(%right, 16)
        emit "cmpi %cr, 0, %left, $right"
        cost 4;

    cr:(cr)cr = COMPARES4(COMPAREU4(left:(int)reg, right:(int)reg), result:CONST4)
        when specific_constant(%result, 0)
        emit "cmpl %cr, 0, %left, %right"
        cost 4;



/* Booleans */

    out:(int)reg = IFEQ4(in:(cr)cr)
        emit "mfcr %out" /* get cr0 */
        emit "rlwinmi %out, %out, 32-2, 2, 31" /* extract just EQ */
        cost 8;

    out:(int)reg = IFEQ4(in:(int)reg)
        emit "cntlzw %out, %in" /* returns 0..32 */
        emit "rlwinmi %out, %out, 32-5, 5, 31" /* if 32, return 1, otherwise 0 */
        cost 8;



/* Conversions */

    out:(int)reg = CIU44(in:(int)reg)
        with %out == %in
        emit "! ciu44"
        cost 4;

    out:(int)reg = CUI44(in:(int)reg)
        with %out == %in
        emit "! cui44"
        cost 4;


/* ALU operations */

	out:(int)reg = ADD4(left:(int)reg, right:(int)reg)
		emit "add %out, %left, %right"
		cost 4;

	out:(int)reg = ADD4(left:(int)reg, right:CONST4)
        when signed_constant(%right, 16)
		emit "addi %out, %left, $right"
		cost 4;

	out:(int)reg = ADD4(left:CONST4, right:(int)reg)
        when signed_constant(%left, 16)
		emit "addi %out, %right, $left"
		cost 4;

	out:(int)reg = SUB4(left:(int)reg, right:(int)reg)
		emit "subf %out, %left, %right"
		cost 4;

	out:(int)reg = SUB4(left:(int)reg, right:CONST4)
		emit "addi %out, %left, -[$right]"
		cost 4;

	out:(int)reg = MUL4(left:(int)reg, right:(int)reg)
		emit "mullw %out, %right, %left"
		cost 4;

	out:(int)reg = MOD4(left:(int)reg, right:(int)reg)
		emit "divw %out, %left, %right"
        emit "mullw %out, %out, %right"
        emit "subf %out, %out, %left"
		cost 12;

	out:(int)reg = MUL4(left:(int)reg, right:(int)reg)
		emit "mullw %out, %left, %right"
		cost 4;

	out:(int)reg = DIV4(left:(int)reg, right:(int)reg)
		emit "divw %out, %left, %right"
		cost 4;

    out:(int)reg = ASL4(left:(int)reg, right:(int)reg)
        emit "slw %out, %left, %right"
        cost 4;

    out:(int)reg = NEG4(left:(int)reg)
        emit "neg %out, %left"
        cost 4;

	out:(int)reg = AND4(left:CONST4, right:(int)reg)
		emit "andi. %out, %right, $left"
		cost 4;

	out:(int)reg = AND4(left:(int)reg, right:CONST4)
		emit "andi. %out, %left, $right"
		cost 4;

	out:(int)reg = AND4(left:(int)reg, right:(int)reg)
		emit "and %out, %left, %right"
		cost 4;

	out:(int)reg = OR4(left:(int)reg, right:(int)reg)
		emit "or %out, %right, %left"
		cost 4;

	out:(int)reg = EOR4(left:(int)reg, right:(int)reg)
		emit "xor %out, %right, %left"
		cost 4;

	out:(int)reg = value:LABEL4
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:BLOCK4
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:CONST4
		emit "li %out, $value"
		cost 8;


/* FPU operations */

	out:(float)reg = value:CONSTF4
		emit "lfs %out, address-containing-$value"
		cost 8;

	out:(float)reg = ADDF4(left:(float)reg, right:(float)reg)
		emit "fadds %out, %left, %right"
		cost 4;

	out:(float)reg = SUBF4(left:(float)reg, right:(float)reg)
		emit "fsubs %out, %left, %right"
		cost 4;


/* vim: set sw=4 ts=4 expandtab : */

