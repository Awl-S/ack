REGISTERS

    /* Registers are allocated top down. The odd order below is to make sure
     * that cheap registers get allocated first.
     *
     * Attributes may have at most one of: int, float, long, double. These
     * indicate that the register is used to store a value of that type. If
     * your register can store more than one type, create an alias. Registers
     * with none of these cannot be copied by the code generator (and so cannot
     * be moved from register to register or spilt).
     */

	r4                                            int volatile;
	r5                                            int volatile;
	r6                                            int volatile;
	r7                                            int volatile;
	r8                                            int volatile;
	r9                                            int volatile;
	r10                                           int volatile;
	r11                                           int volatile;
	r12                                           int volatile;
	r13                                           int volatile;
	r14                                           int volatile;
	r15                                           int volatile;
	r24                                           int volatile;
	r25                                           int volatile;
	r2                                            int volatile iret;
	r3                                            int volatile;

	r17 named("r16")                              int;
	r18 named("r18")                              int;
	r19 named("r19")                              int;
	r20 named("r20")                              int;
	r21 named("r21")                              int;
	r22 named("r22")                              int;
	r23 named("r23")                              int;

	r4r5    named("r4", "r5")   aliases(r4,  r5)  long volatile;
	r6r7    named("r6", "r7")   aliases(r6,  r7)  long volatile;
	r8r9    named("r8", "r9")   aliases(r8,  r9)  long volatile;
	r10r11  named("r10", "r11") aliases(r10, r11) long volatile;
	r12r13  named("r12", "r13") aliases(r12, r13) long volatile;
	r14r15  named("r14", "r15") aliases(r14, r15) long volatile;
	r24r25  named("r24", "r25") aliases(r24, r25) long volatile;
	r2r3    named("r2", "r3")   aliases(r2,  r3)  long volatile lret;

	f0                                            float volatile fret;
	f1                                            float volatile;
	f2                                            float volatile;
	f3                                            float volatile;
	f4                                            float volatile;
	f5                                            float volatile;
	f6                                            float volatile;
	f7                                            float volatile;
	f8                                            float volatile;
	f9                                            float volatile;
	f10                                           float volatile;
	f11                                           float volatile;
	f12                                           float volatile;
	f13                                           float volatile;
	f14                                           float volatile;
	f15                                           float volatile;
	f16                                           float volatile;
	f17                                           float volatile;
	f18                                           float volatile;
	f19                                           float volatile;

	f20                                           float;
	f21                                           float;
	f22                                           float;
	f23                                           float;
	f24                                           float;
	f25                                           float;
	f26                                           float;
	f27                                           float;
	f28                                           float;
	f29                                           float;
	f30                                           float;
    /* f31 is used by the compiler as a temporary. */

	d0  named("f0")  aliases(f0)                  double volatile dret;
	d1  named("f1")  aliases(f1)                  double volatile;
	d2  named("f2")  aliases(f2)                  double volatile;
	d3  named("f3")  aliases(f3)                  double volatile;
	d4  named("f4")  aliases(f4)                  double volatile;
	d5  named("f5")  aliases(f5)                  double volatile;
	d6  named("f6")  aliases(f6)                  double volatile;
	d7  named("f7")  aliases(f7)                  double volatile;
	d8  named("f8")  aliases(f8)                  double volatile;
	d9  named("f9")  aliases(f9)                  double volatile;
	d10 named("f10") aliases(f10)                 double volatile;
	d11 named("f11") aliases(f11)                 double volatile;
	d12 named("f12") aliases(f12)                 double volatile;
	d13 named("f13") aliases(f13)                 double volatile;
	d14 named("f14") aliases(f14)                 double volatile;
	d15 named("f15") aliases(f15)                 double volatile;
	d16 named("f16") aliases(f16)                 double volatile;
	d17 named("f17") aliases(f17)                 double volatile;
	d18 named("f18") aliases(f18)                 double volatile;
	d19 named("f19") aliases(f19)                 double volatile;

	d20 named("f20") aliases(f20)                 double;
	d21 named("f21") aliases(f21)                 double;
	d22 named("f22") aliases(f22)                 double;
	d23 named("f23") aliases(f23)                 double;
	d24 named("f24") aliases(f24)                 double;
	d25 named("f25") aliases(f25)                 double;
	d26 named("f26") aliases(f26)                 double;
	d27 named("f27") aliases(f27)                 double;
	d28 named("f28") aliases(f28)                 double;
	d29 named("f29") aliases(f29)                 double;
	d30 named("f30") aliases(f30)                 double;



DECLARATIONS

    ubyteX;   /* bottom 8 bits valid, the rest undefined */
    ubyte0;   /* bottom 8 bits valid, the rest 0 */
    ushortX;  /* bottom 16 bits valid, the rest undefined */
    ushort0;  /* bottom 16 bits valid, the rest 0 */

	address fragment;



PATTERNS

/* Special */

	PAIR(BLOCK.I, BLOCK.I);



/* Miscellaneous special things */

	PUSH.I(in:(int)reg)
		emit "addiu sp, sp, -4"
		emit "sw %in, 0(sp)"
		cost 8;

    PUSH.L(in:(long)reg)
        emit "addiu sp, sp, -8"
        emit "sw %in.0, 0(sp)"
        emit "sw %in.1, 4(sp)"
        cost 12;

	PUSH.F(in:(float)reg)
		emit "addiu sp, sp, -4"
		emit "swc1 %in, 0(sp)"
		cost 8;

	PUSH.D(in:(double)reg)
		emit "addiu sp, sp, -8"
		emit "sdc1 %in, 0(sp)"
		cost 8;

	out:(int)reg = POP.I
		emit "lw %out, 0(sp)"
        emit "addiu sp, sp, 4"
		cost 8;

    out:(long)reg = POP.L
        emit "lw %out.0, 4(sp)"
        emit "lw %out.1, 0(sp)"
        emit "addiu sp, sp, 8"
        cost 12;

	out:(float)reg = POP.F
		emit "lwc1 %out, 0(sp)"
		emit "addiu sp, sp, 4"
		cost 8;

	out:(double)reg = POP.D
		emit "ldc1 %out, 0(sp)"
		emit "addiu sp, sp, 8"
		cost 8;

	SETRET.I(in:(iret)reg)
		emit "! setret.i"
		cost 1;

    SETRET.L(in:(lret)reg)
        emit "! setret.l"
        cost 1;

	SETRET.F(in:(fret)reg)
		emit "! setret.f"
		cost 1;

	SETRET.D(in:(dret)reg)
		emit "! setret.d"
		cost 1;

	STACKADJUST.I(delta:CONST.I)
        when signed_constant(%delta, 16)
		emit "addiu sp, sp, $delta"
		cost 4;

	STACKADJUST.I(in:(int)reg)
		emit "addu sp, sp, %in"
		cost 4;

	STACKADJUST.I(NEG.I(in:(int)reg))
		emit "subu sp, sp, %in"
		cost 4;

    out:(int)reg = GETFP.I
        emit "mov %out, fp"
        cost 4;

    SETFP.I(in:(int)reg)
        emit "mov fp, %in"
        cost 4;

    out:(int)reg = CHAINFP.I(in:(int)reg)
        emit "lw %out, 0(%in)"
        cost 4;

    out:(int)reg = FPTOAB.I(GETFP.I)
        emit "addiu %out, fp, 8"
        cost 4;

    out:(int)reg = FPTOAB.I(in:(int)reg)
        emit "addiu %out, %in, 8"
        cost 4;

    out:(int)reg = FPTOLB.I(in:(int)reg)
        with %out == %in
        cost 1;

    out:(int)reg = GETSP.I
        emit "mov %out, sp"
        cost 4;

    SETSP.I(in:(int)reg)
        emit "mov sp, %in"
        cost 4;

    out:(int)reg = ANY.I
        cost 1;

    out:(long)reg = ANY.L
        cost 1;



/* Memory operations */

    /* Stores */

	STORE.L(addr:address, value:(long)reg)
		emit "sw %value.0, 4+%addr"
		emit "sw %value.1, 0+%addr"
		cost 8;

	STORE.I(addr:address, value:(int)reg)
		emit "sw %value, %addr"
		cost 4;

	STOREH.I(addr:address, value:(int)ushortX)
		emit "sh %value, %addr"
		cost 4;

    STOREB.I(addr:address, value:(int)ubyteX)
		emit "sb %value, %addr"
		cost 4;

	STORE.F(addr:address, value:(float)reg)
		emit "swc1 %value, %addr"
		cost 4;

	STORE.D(addr:address, value:(double)reg)
		emit "sdc1 %value, %addr"
		cost 4;

    /* Loads */

	out:(int)reg = LOAD.I(addr:address)
		emit "lw %out, %addr"
		cost 4;

    /* We can't just load directly because %out.0 and %addr might share
     * a register, resulting in %addr being corrupted before %out.1 is
     * loaded. */
    out:(long)reg = LOAD.L(addr:address)
        emit "lw at, 4+%addr"
        emit "lw %out.1, 0+%addr"
        emit "mov %out.0, at"
        cost 12;

	out:(int)ushort0 = LOADH.I(addr:address)
		emit "lh %out, %addr"
		cost 4;

	out:(int)ubyte0 = LOADB.I(addr:address)
		emit "lb %out, %addr"
		cost 4;

	out:(float)reg = LOAD.F(addr:address)
		emit "lwc1 %out, %addr"
		cost 4;

	out:(double)reg = LOAD.D(addr:address)
		emit "ldc1 %out, %addr"
		cost 4;

    /* ubyte intrinsics */

    out:(int)ubyteX = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> ubyteX"
        cost 1;

    out:(int)ubyte0 = in:(int)ubyteX
        emit "andiu %out, %in, 0xff ! ubyteX -> ubyte0"
        cost 4;

    out:(int)reg = in:(int)ubyte0
        with %out == %in
        emit "! ubyte0 -> reg"
        cost 4;

    out:(int)ubyteX = in:(int)reg
        with %out == %in
        emit "! reg -> ubyteX"
        cost 1;

    /* ushort intrinsics */

    out:(int)ushortX = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> ushortX"
        cost 1;

    out:(int)ushort0 = in:(int)ushortX
        emit "andiu %out, %in, 0xffff ! ushortX -> ushort0"
        cost 4;

    out:(int)reg = in:(int)ushort0
        with %out == %in
        emit "! ushort0 -> reg"
        cost 4;

    out:(int)ushortX = in:(int)reg
        with %out == %in
        emit "! reg -> ushortX"
        cost 1;



/* Extensions and conversions */

    out:(int)reg = EXTENDB.I(in:(int)reg)
        emit "seb %out, %in"
        cost 4;

    out:(int)reg = EXTENDH.I(in:(int)reg)
        emit "seh %out, %in"
        cost 4;

    out:(int)reg = FROMSI.I(in:(int)reg)
        with %out == %in
        emit "! FROMSI.I(int) -> int"
        cost 1;

    out:(int)reg = FROMUI.I(in:(int)reg)
        with %out == %in
        emit "! FROMUI.I(int) -> int"
        cost 1;

    out:(long)reg = FROMSI.L(in:(int)reg)
        emit "mov %out.0, %in"
        emit "sra %out.1, %in, 31"
        cost 8;

    out:(long)reg = FROMUI.L(in:(int)reg)
        emit "mr %out.0, %in"
        emit "li %out.1, 0"
        cost 8;

    out:(lret)reg = FROMIPAIR.L(in1:(int)reg, in2:(int)reg)
        emit "mov %out.0, %in1"
        emit "mov %out.1, %in2"
        cost 8;
    
    out:(int)reg = FROML0.I(in:(long)reg)
        emit "mov %out, %in.0"
        cost 4;

    out:(int)reg = FROML1.I(in:(long)reg)
        emit "mov %out, %in.1"
        cost 4;



/* Locals */

	out:(int)reg = in:LOCAL.I
		emit "addiu %out, fp, $in"
		cost 4;

	address = in:LOCAL.I
		emit "$in(fp)";



/* Memory addressing modes */

	address = ADD.I(addr:(int)reg, offset:CONST.I)
        when signed_constant(%offset, 16)
		emit "$offset(%addr)";

	address = addr:(int)reg
		emit "0(%addr)";



/* Branches */

	JUMP(addr:BLOCK.I)
		emit "b $addr"
        emit "nop"
		cost 8;

	FARJUMP(addr:LABEL.I)
        with corrupted(volatile)
		emit "b $addr"
        emit "nop"
		cost 8;

    JUMP(dest:(int)reg)
        emit "jr %dest"
        emit "nop"
        cost 8;

	CJUMPEQ(COMPARESI.I(left:(int)reg, right:(int)reg), PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "beq %left, %right, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 16;

	CJUMPLT(COMPARESI.I(left:(int)reg, right:(int)reg), PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "slt at, %left, %right"
        emit "bne at, zero, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 20;

	CJUMPLT(COMPAREUI.I(left:(int)reg, right:(int)reg), PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "sltu at, %left, %right"
        emit "bne at, zero, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 20;

	CJUMPLT(COMPARESI.I(left:(int)reg, right:CONST.I), PAIR(true:BLOCK.I, false:BLOCK.I))
        when specific_constant(%right, 0)
        emit "bltz %left, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 16;

	CJUMPLE(COMPARESI.I(left:(int)reg, right:(int)reg), PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "sle at, %left, %right"
        emit "bne at, zero, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 20;

	CJUMPLE(COMPAREUI.I(left:(int)reg, right:(int)reg), PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "sleu at, %left, %right"
        emit "bne at, zero, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 20;

	CJUMPLE(COMPARESI.I(left:(int)reg, right:CONST.I), PAIR(true:BLOCK.I, false:BLOCK.I))
        when specific_constant(%right, 0)
        emit "blez %left, $true"
        emit "nop"
        emit "b $false"
        emit "nop"
        cost 16;

    COMPAREUI.I(left:(int)reg, right:(int)reg);

    #define CALLLABEL(insn) \
        insn (dest:LABEL.I) \
            with corrupted(volatile) \
            emit "bal $dest" \
            emit "nop" \
            cost 8;

    CALLLABEL(CALL)
    out:(iret)reg = CALLLABEL(CALL.I)
    out:(lret)reg = CALLLABEL(CALL.L)

    #define CALLINDIRECT(insn) \
        insn (dest:(int)reg) \
            with corrupted(volatile) \
            emit "jalr %dest" \
            emit "nop" \
            cost 8;

    CALLINDIRECT(CALL)
    out:(iret)reg = CALLINDIRECT(CALL.I)
    out:(lret)reg = CALLINDIRECT(CALL.L)

    JUMP(dest:LABEL.I)
        emit "b $dest"
        emit "nop"
        cost 8;



/* Comparisons */

	/* The COMPARE nodes return tristate integer values; -1, 0 or 1. */

    out:(int)reg = COMPARESI.I(left:(int)reg, right:(int)reg)
        emit "slt at, %left, %right"
        emit "bne at, zero, 1f"
        emit "li %out, -1" /* delay slot */
        emit "slt %out, %right, %left"
        emit "1:"
        cost 20;

    out:(int)reg = COMPAREUI.I(left:(int)reg, right:(int)reg)
        emit "sltu at, %left, %right"
        emit "bne at, zero, 1f"
        emit "li %out, -1" /* delay slot */
        emit "sltu %out, %right, %left"
        emit "1:"
        cost 20;

    out:(int)reg = COMPARED.I(left:(double)reg, right:(double)reg)
        emit "c.lt.d 0, %left, %right"
        emit "bc1t 0, 1f"
        emit "li %out, -1" /* delay slot */
        emit "c.lt.d 0, %right, %left"
        emit "li %out, 1"
        emit "movf %out, zero, 0"
        cost 28;

/* Booleans */

	/* If 0 then 1, else 0 */
	out:(int)reg = IFEQ.I(in:(int)reg)
		emit "sleu %out, %in, zero"
		cost 4;

	/* If -1 then 1, else 0 */
	out:(int)reg = IFLT.I(in:(int)reg)
		emit "slt %out, %in, zero"
		cost 4;

	/* If 1 or 0 then 1, else 0 */
	out:(int)reg = IFLE.I(in:(int)reg)
		emit "sle %out, %in, zero"
		cost 4;



/* Conversions */

#if 0
    out:(int)reg = CIU44(in:(int)reg)
        with %out == %in
        emit "! ciu44"
        cost 4;

    out:(int)reg = CUI44(in:(int)reg)
        with %out == %in
        emit "! cui44"
        cost 4;
#endif

/* ALU operations */

	/* reg + reg */
    #define ALUR(name, instr) \
        out:(int)reg = name(left:(int)reg, right:(int)reg) \
            emit instr " %out, %left, %right"              \
            cost 4;                                        \

	/* reg + const */
    #define ALUC(name, instr) \
        out:(int)reg = name(left:(int)reg, right:CONST.I)  \
            when signed_constant(%right, 16)               \
            emit instr " %out, %left, $right"              \
            cost 4;                                        \

	/* const + reg */
    #define ALUC_reversed(name, instr) \
        out:(int)reg = name(left:CONST.I, right:(int)reg)  \
            when signed_constant(%left, 16)                \
            emit instr " %out, %right, $left"              \
            cost 4;                                        \

	/* reg + const AND const + reg */
    #define ALUCC(name, instr) \
        ALUC(name, instr) \
        ALUC_reversed(name, instr)

    ALUR(ADD.I, "addu")
    ALUCC(ADD.I, "addiu")

	out:(int)reg = SUB.I(left:(int)reg, right:(int)reg)
		emit "subu %out, %right, %left"
		cost 4;

	out:(int)reg = SUB.I(left:(int)reg, right:CONST.I)
		emit "addiu %out, %left, -[$right]"
		cost 4;

	out:(int)reg = MOD.I(left:(int)reg, right:(int)reg)
		emit "div %left, %right"
		emit "mfhi %out"
		cost 8;

	out:(int)reg = MODU.I(left:(int)reg, right:(int)reg)
		emit "divu %left, %right"
		emit "mfhi %out"
		cost 8;

    ALUR(MUL.I, "mul")

    ALUR(DIV.I, "divw")
    ALUR(DIVU.I, "divwu")

    ALUR(ASL.I, "sllv")
    ALUC(ASL.I, "sll")
    ALUR(ASR.I, "srav")
    ALUC(ASR.I, "sra")

    ALUR(LSL.I, "sllv")
    ALUC(LSL.I, "sll")
    ALUR(LSR.I, "srlv")
    ALUC(LSR.I, "srl")

    out:(int)reg = NEG.I(left:(int)reg)
        emit "neg %out, %left"
        cost 4;

    out:(int)reg = NOT.I(in:(int)reg)
        emit "nor %out, %in, %in"
        cost 4;

    ALUR(AND.I, "and")
    ALUCC(AND.I, "andi.")

    ALUR(OR.I, "or")
    ALUCC(OR.I, "ori")

    ALUR(EOR.I, "xor")
    ALUCC(EOR.I, "xori")

	out:(int)reg = value:LABEL.I
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:BLOCK.I
		emit "la %out, $value"
		cost 4;

	out:(int)reg = value:CONST.I
		emit "li %out, $value"
		cost 4;



/* FPU operations */

	/* Doubles */

	out:(double)reg = ADDF.D(left:(double)reg, right:(double)reg)
		emit "add.d %out, %left, %right"
		cost 4;

	out:(double)reg = SUBF.D(left:(double)reg, right:(double)reg)
		emit "sub.d %out, %left, %right"
		cost 4;

	out:(double)reg = MULF.D(left:(double)reg, right:(double)reg)
		emit "mul.d %out, %left, %right"
		cost 4;

	out:(double)reg = DIVF.D(left:(double)reg, right:(double)reg)
		emit "div.d %out, %left, %right"
		cost 4;

	out:(double)reg = FROMSI.D(in:(int)reg)
		emit "mtc1 %out, %in"
		emit "cvt.d.w %out, %out"
		cost 4;

	/* Floats */

	out:(float)reg = ADDF.F(left:(float)reg, right:(float)reg)
		emit "add.d %out, %left, %right"
		cost 4;

	out:(float)reg = SUBF.F(left:(float)reg, right:(float)reg)
		emit "sub.d %out, %left, %right"
		cost 4;

	out:(float)reg = MULF.F(left:(float)reg, right:(float)reg)
		emit "mul.d %out, %left, %right"
		cost 4;

	out:(float)reg = DIVF.F(left:(float)reg, right:(float)reg)
		emit "div.d %out, %left, %right"
		cost 4;

	out:(float)reg = FROMSI.F(in:(int)reg)
		emit "mtc1 %out, %in"
		emit "cvt.s.w %out, %out"
		cost 4;

/* vim: set sw=4 ts=4 expandtab : */

