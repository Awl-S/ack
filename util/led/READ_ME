You may want to change mach.c in this directory.

Archives MUST have a table of contents. Arch in subdirectory arch
automatically makes one when you change an archive.

Several changes in the assembler were needed to have it generate the 
necessary output.
A contextual diff follows. You can apply them as follows:
patch -d /usr/em/philips/mach/68000/as < READ_ME

*** comm0.h.old	Thu Dec  6 16:18:39 1984
--- comm0.h	Thu Dec  6 17:49:51 1984
***************
*** 213,218
  
  /*
   * extra type bits out of S_ETC, internal use only
   * S_COM:
   *  - symbols declared by .comm
   * S_VAR:

--- 213,219 -----
  
  /*
   * extra type bits out of S_ETC, internal use only
+ #ifndef DUK
   * S_COM:
   *  - symbols declared by .comm
  #endif DUK
***************
*** 215,220
   * extra type bits out of S_ETC, internal use only
   * S_COM:
   *  - symbols declared by .comm
   * S_VAR:
   *  - type not known at end of PASS_1 (S_VAR|S_UND)
   *  - value not known at end of PASS_2 (S_VAR|S_ABS)

--- 216,222 -----
  #ifndef DUK
   * S_COM:
   *  - symbols declared by .comm
+ #endif DUK
   * S_VAR:
   *  - type not known at end of PASS_1 (S_VAR|S_UND)
   *  - value not known at end of PASS_2 (S_VAR|S_ABS)
***************
*** 221,226
   * S_DOT:
   *  - dot expression
   */
  #define	S_COM		0x0100
  #define	S_VAR		0x0200
  #define	S_DOT		0x0400

--- 223,229 -----
   * S_DOT:
   *  - dot expression
   */
+ #ifndef DUK
  #define	S_COM		0x0100
  #endif DUK
  #define	S_VAR		0x0200
***************
*** 222,227
   *  - dot expression
   */
  #define	S_COM		0x0100
  #define	S_VAR		0x0200
  #define	S_DOT		0x0400
  /* should be tested by preprocessor

--- 225,231 -----
   */
  #ifndef DUK
  #define	S_COM		0x0100
+ #endif DUK
  #define	S_VAR		0x0200
  #define	S_DOT		0x0400
  /* should be tested by preprocessor
*** comm2.y.old	Thu Dec  6 16:19:07 1984
--- comm2.y	Thu Dec  6 16:02:19 1984
***************
*** 229,234
  			{
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
  					newrelo($1.typ, (int)$<y_word>0);
  #endif
  				emitx($1.val, (int)$<y_word>0);

--- 229,239 -----
  			{
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
+ #ifdef DUK
+ 					newrelo($1.typ,
+ 						(int)$<y_word>0 | RELBR | RELWR
+ 					);
+ #else DUK
  					newrelo($1.typ, (int)$<y_word>0);
  #endif DUK
  #endif
***************
*** 230,235
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
  					newrelo($1.typ, (int)$<y_word>0);
  #endif
  				emitx($1.val, (int)$<y_word>0);
  			}

--- 235,241 -----
  					);
  #else DUK
  					newrelo($1.typ, (int)$<y_word>0);
+ #endif DUK
  #endif
  				emitx($1.val, (int)$<y_word>0);
  			}
***************
*** 237,242
  			{
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
  					newrelo($3.typ, (int)$<y_word>0);
  #endif
  				emitx($3.val, (int)$<y_word>0);

--- 243,253 -----
  			{
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
+ #ifdef DUK
+ 					newrelo($3.typ,
+ 						(int)$<y_word>0 | RELBR | RELWR
+ 					);
+ #else DUK
  					newrelo($3.typ, (int)$<y_word>0);
  #endif DUK
  #endif
***************
*** 238,243
  #ifdef RELOCATION
  				if (rflag != 0 && PASS_RELO)
  					newrelo($3.typ, (int)$<y_word>0);
  #endif
  				emitx($3.val, (int)$<y_word>0);
  			}

--- 249,255 -----
  					);
  #else DUK
  					newrelo($3.typ, (int)$<y_word>0);
+ #endif DUK
  #endif
  				emitx($3.val, (int)$<y_word>0);
  			}
*** comm3.c.old	Wed Jul 11 09:22:24 1984
--- comm3.c	Fri Dec  7 13:06:26 1984
***************
*** 11,16
  
  struct outhead	outhead = {
  	O_MAGIC, O_STAMP, 0
  #ifdef BYTES_REVERSED
  	| HF_BREV
  #endif

--- 11,17 -----
  
  struct outhead	outhead = {
  	O_MAGIC, O_STAMP, 0
+ #ifndef DUK
  #ifdef BYTES_REVERSED
  	| HF_BREV
  #endif
***************
*** 17,22
  #ifdef WORDS_REVERSED
  	| HF_WREV
  #endif
  };
  
  #include	"y.tab.h"

--- 18,24 -----
  #ifdef WORDS_REVERSED
  	| HF_WREV
  #endif
+ #endif DUK
  };
  
  #include	"y.tab.h"
*** comm5.c.old	Thu Dec  6 16:19:40 1984
--- comm5.c	Thu Oct 11 14:03:27 1984
***************
*** 162,167
  #endif
  	case STRING:
  		p = stringbuf;
  		*p++ = n = getc(tempfile); break;
  	case OP_EQ:
  	case OP_NE:

--- 162,172 -----
  #endif
  	case STRING:
  		p = stringbuf;
+ #ifdef DUK
+ 		*p++ = n = getc(tempfile);
+ 		p[n] = '\0';
+ 		break;
+ #else DUK
  		*p++ = n = getc(tempfile); break;
  #endif DUK
  	case OP_EQ:
***************
*** 163,168
  	case STRING:
  		p = stringbuf;
  		*p++ = n = getc(tempfile); break;
  	case OP_EQ:
  	case OP_NE:
  	case OP_LE:

--- 168,174 -----
  		break;
  #else DUK
  		*p++ = n = getc(tempfile); break;
+ #endif DUK
  	case OP_EQ:
  	case OP_NE:
  	case OP_LE:
***************
*** 354,359
  			break;
  		if (c == '\\')
  			c = inescape();
  		if (p >= &stringbuf[STRINGMAX])
  			fatal("string buffer overflow");
  		*p++ = c;

--- 360,368 -----
  			break;
  		if (c == '\\')
  			c = inescape();
+ #ifdef DUK
+ 		if (p >= &stringbuf[STRINGMAX - 1])
+ #else DUK
  		if (p >= &stringbuf[STRINGMAX])
  #endif DUK
  			fatal("string buffer overflow");
***************
*** 355,360
  		if (c == '\\')
  			c = inescape();
  		if (p >= &stringbuf[STRINGMAX])
  			fatal("string buffer overflow");
  		*p++ = c;
  	}

--- 364,370 -----
  		if (p >= &stringbuf[STRINGMAX - 1])
  #else DUK
  		if (p >= &stringbuf[STRINGMAX])
+ #endif DUK
  			fatal("string buffer overflow");
  		*p++ = c;
  	}
***************
*** 359,364
  		*p++ = c;
  	}
  	stringbuf[0] = p - stringbuf - 1;
  	return(STRING);
  }
  

--- 369,377 -----
  		*p++ = c;
  	}
  	stringbuf[0] = p - stringbuf - 1;
+ #ifdef DUK
+ 	*p = '\0';
+ #endif DUK
  	return(STRING);
  }
  
*** comm6.c.old	Thu Dec  6 16:20:22 1984
--- comm6.c	Wed Oct  3 15:59:31 1984
***************
*** 106,111
  		sp = &sect[typ - S_MIN];
  		sp->s_item = ip;
  		sp->s_lign = ALIGNSECT;
  		ip->i_type = typ | S_EXT;
  		ip->i_valu = 0;
  	} else if (typ >= S_MIN) {

--- 106,114 -----
  		sp = &sect[typ - S_MIN];
  		sp->s_item = ip;
  		sp->s_lign = ALIGNSECT;
+ #ifdef DUK
+ 		ip->i_type = typ;
+ #else DUK
  		ip->i_type = typ | S_EXT;
  #endif DUK
  		ip->i_valu = 0;
***************
*** 107,112
  		sp->s_item = ip;
  		sp->s_lign = ALIGNSECT;
  		ip->i_type = typ | S_EXT;
  		ip->i_valu = 0;
  	} else if (typ >= S_MIN) {
  		sp = &sect[typ - S_MIN];

--- 110,116 -----
  		ip->i_type = typ;
  #else DUK
  		ip->i_type = typ | S_EXT;
+ #endif DUK
  		ip->i_valu = 0;
  	} else if (typ >= S_MIN) {
  		sp = &sect[typ - S_MIN];
***************
*** 180,185
  		 * for possible relocation
  		 */
  		ip->i_valu = outhead.oh_nname;
  	newsymb(ip->i_name, S_EXT|DOTTYP, (short)0, val);
  #endif
  }

--- 184,192 -----
  		 * for possible relocation
  		 */
  		ip->i_valu = outhead.oh_nname;
+ #ifdef DUK
+ 	newsymb(ip->i_name, S_COM|S_EXT|DOTTYP, (short)0, val);
+ #else DUK
  	newsymb(ip->i_name, S_EXT|DOTTYP, (short)0, val);
  #endif DUK
  #endif
***************
*** 181,186
  		 */
  		ip->i_valu = outhead.oh_nname;
  	newsymb(ip->i_name, S_EXT|DOTTYP, (short)0, val);
  #endif
  }
  

--- 188,194 -----
  	newsymb(ip->i_name, S_COM|S_EXT|DOTTYP, (short)0, val);
  #else DUK
  	newsymb(ip->i_name, S_EXT|DOTTYP, (short)0, val);
+ #endif DUK
  #endif
  }
  
***************
*** 255,260
  short s;
  {
  	struct outrelo outrelo;
  
  	if (rflag == 0)
  		return;

--- 263,271 -----
  short s;
  {
  	struct outrelo outrelo;
+ #ifdef DUK
+ 	int	iscomm;
+ #endif DUK
  
  	if (rflag == 0)
  		return;
***************
*** 272,277
  	 *	b=a
  	 *  a:	.data2	0
  	 */
  	s &= ~S_COM;
  	if ((n & RELPC) == 0 && s == S_ABS)
  		return;

--- 283,291 -----
  	 *	b=a
  	 *  a:	.data2	0
  	 */
+ #ifdef DUK
+ 	iscomm = s & S_COM;
+ #endif DUK
  	s &= ~S_COM;
  	if ((n & RELPC) == 0 && s == S_ABS)
  		return;
***************
*** 285,290
  	outrelo.or_type = (char)n;
  	outrelo.or_sect = (char)DOTTYP;
  #ifndef ASLD
  	if (s == S_UND) {
  		assert(relonami != 0);
  		outrelo.or_nami = relonami-1;

--- 299,307 -----
  	outrelo.or_type = (char)n;
  	outrelo.or_sect = (char)DOTTYP;
  #ifndef ASLD
+ #ifdef DUK
+ 	if (s == S_UND || iscomm) {
+ #else DUK
  	if (s == S_UND) {
  #endif DUK
  		assert(relonami != 0);
***************
*** 286,291
  	outrelo.or_sect = (char)DOTTYP;
  #ifndef ASLD
  	if (s == S_UND) {
  		assert(relonami != 0);
  		outrelo.or_nami = relonami-1;
  		relonami = 0;

--- 303,309 -----
  	if (s == S_UND || iscomm) {
  #else DUK
  	if (s == S_UND) {
+ #endif DUK
  		assert(relonami != 0);
  		outrelo.or_nami = relonami-1;
  		relonami = 0;
*** comm7.c.old	Thu Dec  6 16:20:50 1984
--- comm7.c	Wed Oct  3 16:35:31 1984
***************
*** 19,24
  		return(ip->i_valu);
  	return(ip->i_valu + sect[typ].s_base);
  #else
  	if ((ip->i_type & S_TYP) == S_UND) {
  		if (pass == PASS_3) {
  			if (relonami != 0)

--- 19,27 -----
  		return(ip->i_valu);
  	return(ip->i_valu + sect[typ].s_base);
  #else
+ #ifdef DUK
+ 	if ((ip->i_type & S_TYP) == S_UND || (ip->i_type & S_COM)) {
+ #else DUK
  	if ((ip->i_type & S_TYP) == S_UND) {
  #endif DUK
  		if (pass == PASS_3) {
***************
*** 20,25
  	return(ip->i_valu + sect[typ].s_base);
  #else
  	if ((ip->i_type & S_TYP) == S_UND) {
  		if (pass == PASS_3) {
  			if (relonami != 0)
  				serror("relocation error");

--- 23,29 -----
  	if ((ip->i_type & S_TYP) == S_UND || (ip->i_type & S_COM)) {
  #else DUK
  	if ((ip->i_type & S_TYP) == S_UND) {
+ #endif DUK
  		if (pass == PASS_3) {
  			if (relonami != 0)
  				serror("relocation error");
*** mach0.c.old	Thu Dec  6 16:21:11 1984
--- mach0.c	Fri Sep 14 14:15:54 1984
***************
*** 1,3
  /* @(#)mach0.c	1.5 */
  /*
   * Motorola 68000/68010 options

--- 1,4 -----
+ #define DUK
  /* @(#)mach0.c	1.5 */
  /*
   * Motorola 68000/68010 options
*** mach4.c.old	Thu Dec  6 16:21:30 1984
--- mach4.c	Thu Dec  6 16:05:00 1984
***************
*** 21,26
  				fit(fitw($4.val));
  				emit2($1 | $2);
  #ifdef RELOCATION
  				newrelo($4.typ, RELPC|RELO2);
  #endif
  				emit2(loww($4.val));

--- 21,29 -----
  				fit(fitw($4.val));
  				emit2($1 | $2);
  #ifdef RELOCATION
+ #ifdef DUK
+ 				newrelo($4.typ, RELPC|RELO2|RELBR|RELWR);
+ #else DUK
  				newrelo($4.typ, RELPC|RELO2);
  #endif DUK
  #endif
***************
*** 22,27
  				emit2($1 | $2);
  #ifdef RELOCATION
  				newrelo($4.typ, RELPC|RELO2);
  #endif
  				emit2(loww($4.val));
  			}

--- 25,31 -----
  				newrelo($4.typ, RELPC|RELO2|RELBR|RELWR);
  #else DUK
  				newrelo($4.typ, RELPC|RELO2);
+ #endif DUK
  #endif
  				emit2(loww($4.val));
  			}
*** mach5.c.old	Thu Dec  6 16:21:54 1984
--- mach5.c	Thu Dec  6 16:07:05 1984
***************
*** 37,42
  #ifdef RELOCATION
  	RELOMOVE(relonami, rel_1);
  	if (flag & ~0xFF)
  		newrelo(exp_1.typ, flag>>8);
  #endif
  	if (flag & PUTL)

--- 37,45 -----
  #ifdef RELOCATION
  	RELOMOVE(relonami, rel_1);
  	if (flag & ~0xFF)
+ #ifdef DUK
+ 		newrelo(exp_1.typ, (flag>>8) | RELBR | RELWR);
+ #else DUK
  		newrelo(exp_1.typ, flag>>8);
  #endif DUK
  #endif
***************
*** 38,43
  	RELOMOVE(relonami, rel_1);
  	if (flag & ~0xFF)
  		newrelo(exp_1.typ, flag>>8);
  #endif
  	if (flag & PUTL)
  		emit4(exp_1.val);

--- 41,47 -----
  		newrelo(exp_1.typ, (flag>>8) | RELBR | RELWR);
  #else DUK
  		newrelo(exp_1.typ, flag>>8);
+ #endif DUK
  #endif
  	if (flag & PUTL)
  		emit4(exp_1.val);
***************
*** 357,362
  		fit(fitw(exp.val));
  		emit2(opc);
  #ifdef RELOCATION
  		newrelo(exp.typ, RELPC|RELO2);
  #endif
  		emit2(loww(exp.val));

--- 361,369 -----
  		fit(fitw(exp.val));
  		emit2(opc);
  #ifdef RELOCATION
+ #ifdef DUK
+ 		newrelo(exp.typ, RELPC|RELO2|RELBR|RELWR);
+ #else DUK
  		newrelo(exp.typ, RELPC|RELO2);
  #endif DUK
  #endif
***************
*** 358,363
  		emit2(opc);
  #ifdef RELOCATION
  		newrelo(exp.typ, RELPC|RELO2);
  #endif
  		emit2(loww(exp.val));
  	}

--- 365,371 -----
  		newrelo(exp.typ, RELPC|RELO2|RELBR|RELWR);
  #else DUK
  		newrelo(exp.typ, RELPC|RELO2);
+ #endif DUK
  #endif
  		emit2(loww(exp.val));
  	}
