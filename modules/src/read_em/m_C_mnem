EM_TABLE=../../../etc/em_table
echo "switch(opcode) {"
for i in - cdflnorswz p b
do
	list=`./argtype $i $EM_TABLE`
	case $i in
	-)	args='()'
		echo "/* no arguments */"
		;;
	cdflnorswz)
		args='(arg->em_cst)'
		echo "/* one integer constant argument */"
		;;
	p)
		args='(arg->em_pnam)'
		echo "/* a procedure name argument */"
		;;
	b)

: Grumbl, an instruction label as argument is encoded in a sp_cst2

		args='((label) (arg->em_cst))'
		echo "/* An instruction label argument */"
		;;
	esac
	for i in $list
	do
		cat << EOF
	case op_$i:
		C_$i$args;
		break;
EOF
	done
done
list=`./argtype g $EM_TABLE`
cat << 'EOF'
	default:
/* a "g" argument */
		if (arg->em_argtype == nof_ptyp) {
			switch(opcode) {
				default:
					EM_error = "Illegal mnemonic";
					break;
EOF
for i in $list
do
	cat << EOF
				case op_$i:
					C_${i}_dlb(arg->em_dlb, arg->em_noff);
					break;
EOF
done
cat << 'EOF'
			}
		}
		else if (arg->em_argtype == sof_ptyp) {
			switch(opcode) {
				default:
					EM_error = "Illegal mnemonic";
					break;
EOF
for i in $list
do
	cat << EOF
				case op_$i:
					C_${i}_dnam(arg->em_dnam, arg->em_soff);
					break;
EOF
done
cat << 'EOF'
			}
		}
		else /*argtype == cst_ptyp */ {
			switch(opcode) {
				default:
					EM_error = "Illegal mnemonic";
					break;
EOF
for i in $list
do
	cat << EOF
				case op_$i:
					C_$i(arg->em_cst);
					break;
EOF
done
cat << 'EOF'
			}
		}
}
EOF
